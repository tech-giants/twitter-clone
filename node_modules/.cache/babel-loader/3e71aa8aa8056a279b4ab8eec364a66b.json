{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/**\n * Gets the value at path of object\n * @param {object} obj object to query\n * @param {string} path query path\n * @returns {any} - if {@param path} requests element from array, then `undefined` will be returned\n */\n\nconst getProperty = (obj, path) => {\n  let name = path.split(\".\");\n\n  for (let i = 0; i < name.length - 1; i++) {\n    obj = obj[name[i]];\n    if (typeof obj !== \"object\" || !obj || Array.isArray(obj)) return;\n  }\n\n  return obj[name.pop()];\n};\n/**\n * Sets the value at path of object. Stops execution, if {@param path} requests element from array to be set\n * @param {object} obj object to query\n * @param {string} path query path\n * @param {any} value value to be set\n * @returns {void}\n */\n\n\nconst setProperty = (obj, path, value) => {\n  let name = path.split(\".\");\n\n  for (let i = 0; i < name.length - 1; i++) {\n    if (typeof obj[name[i]] !== \"object\" && obj[name[i]] !== undefined) return;\n    if (Array.isArray(obj[name[i]])) return;\n    if (!obj[name[i]]) obj[name[i]] = {};\n    obj = obj[name[i]];\n  }\n\n  obj[name.pop()] = value;\n};\n/**\n * @typedef {'call' | 'make' | 'append'} ConfigType\n */\n\n/**\n * @typedef {(options: object) => any} MakeConfigHandler\n */\n\n/**\n * @typedef {(value: any, options: object) => any} CallConfigHandler\n */\n\n/**\n * @typedef {any[]} AppendConfigValues\n */\n\n\nclass OptionsDefaulter {\n  constructor() {\n    /**\n     * Stores default options settings or functions for computing them\n     */\n    this.defaults = {};\n    /**\n     * Stores configuration for options\n     * @type {{[key: string]: ConfigType}}\n     */\n\n    this.config = {};\n  }\n  /**\n   * Enhancing {@param options} with default values\n   * @param {object} options provided options\n   * @returns {object} - enhanced options\n   * @throws {Error} - will throw error, if configuration value is other then `undefined` or {@link ConfigType}\n   */\n\n\n  process(options) {\n    options = Object.assign({}, options);\n\n    for (let name in this.defaults) {\n      switch (this.config[name]) {\n        /**\n         * If {@link ConfigType} doesn't specified and current value is `undefined`, then default value will be assigned\n         */\n        case undefined:\n          if (getProperty(options, name) === undefined) {\n            setProperty(options, name, this.defaults[name]);\n          }\n\n          break;\n\n        /**\n         * Assign result of {@link CallConfigHandler}\n         */\n\n        case \"call\":\n          setProperty(options, name, this.defaults[name].call(this, getProperty(options, name), options));\n          break;\n\n        /**\n         * Assign result of {@link MakeConfigHandler}, if current value is `undefined`\n         */\n\n        case \"make\":\n          if (getProperty(options, name) === undefined) {\n            setProperty(options, name, this.defaults[name].call(this, options));\n          }\n\n          break;\n\n        /**\n         * Adding {@link AppendConfigValues} at the end of the current array\n         */\n\n        case \"append\":\n          {\n            let oldValue = getProperty(options, name);\n\n            if (!Array.isArray(oldValue)) {\n              oldValue = [];\n            }\n\n            oldValue.push(...this.defaults[name]);\n            setProperty(options, name, oldValue);\n            break;\n          }\n\n        default:\n          throw new Error(\"OptionsDefaulter cannot process \" + this.config[name]);\n      }\n    }\n\n    return options;\n  }\n  /**\n   * Builds up default values\n   * @param {string} name option path\n   * @param {ConfigType | any} config if {@param def} is provided, then only {@link ConfigType} is allowed\n   * @param {MakeConfigHandler | CallConfigHandler | AppendConfigValues} [def] defaults\n   * @returns {void}\n   */\n\n\n  set(name, config, def) {\n    if (def !== undefined) {\n      this.defaults[name] = def;\n      this.config[name] = config;\n    } else {\n      this.defaults[name] = config;\n      delete this.config[name];\n    }\n  }\n\n}\n\nmodule.exports = OptionsDefaulter;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/OptionsDefaulter.js"],"names":["getProperty","obj","path","name","split","i","length","Array","isArray","pop","setProperty","value","undefined","OptionsDefaulter","constructor","defaults","config","process","options","Object","assign","call","oldValue","push","Error","set","def","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n/**\n * Gets the value at path of object\n * @param {object} obj object to query\n * @param {string} path query path\n * @returns {any} - if {@param path} requests element from array, then `undefined` will be returned\n */\nconst getProperty = (obj, path) => {\n\tlet name = path.split(\".\");\n\tfor (let i = 0; i < name.length - 1; i++) {\n\t\tobj = obj[name[i]];\n\t\tif (typeof obj !== \"object\" || !obj || Array.isArray(obj)) return;\n\t}\n\treturn obj[name.pop()];\n};\n\n/**\n * Sets the value at path of object. Stops execution, if {@param path} requests element from array to be set\n * @param {object} obj object to query\n * @param {string} path query path\n * @param {any} value value to be set\n * @returns {void}\n */\nconst setProperty = (obj, path, value) => {\n\tlet name = path.split(\".\");\n\tfor (let i = 0; i < name.length - 1; i++) {\n\t\tif (typeof obj[name[i]] !== \"object\" && obj[name[i]] !== undefined) return;\n\t\tif (Array.isArray(obj[name[i]])) return;\n\t\tif (!obj[name[i]]) obj[name[i]] = {};\n\t\tobj = obj[name[i]];\n\t}\n\tobj[name.pop()] = value;\n};\n\n/**\n * @typedef {'call' | 'make' | 'append'} ConfigType\n */\n/**\n * @typedef {(options: object) => any} MakeConfigHandler\n */\n/**\n * @typedef {(value: any, options: object) => any} CallConfigHandler\n */\n/**\n * @typedef {any[]} AppendConfigValues\n */\n\nclass OptionsDefaulter {\n\tconstructor() {\n\t\t/**\n\t\t * Stores default options settings or functions for computing them\n\t\t */\n\t\tthis.defaults = {};\n\t\t/**\n\t\t * Stores configuration for options\n\t\t * @type {{[key: string]: ConfigType}}\n\t\t */\n\t\tthis.config = {};\n\t}\n\n\t/**\n\t * Enhancing {@param options} with default values\n\t * @param {object} options provided options\n\t * @returns {object} - enhanced options\n\t * @throws {Error} - will throw error, if configuration value is other then `undefined` or {@link ConfigType}\n\t */\n\tprocess(options) {\n\t\toptions = Object.assign({}, options);\n\t\tfor (let name in this.defaults) {\n\t\t\tswitch (this.config[name]) {\n\t\t\t\t/**\n\t\t\t\t * If {@link ConfigType} doesn't specified and current value is `undefined`, then default value will be assigned\n\t\t\t\t */\n\t\t\t\tcase undefined:\n\t\t\t\t\tif (getProperty(options, name) === undefined) {\n\t\t\t\t\t\tsetProperty(options, name, this.defaults[name]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/**\n\t\t\t\t * Assign result of {@link CallConfigHandler}\n\t\t\t\t */\n\t\t\t\tcase \"call\":\n\t\t\t\t\tsetProperty(\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tthis.defaults[name].call(this, getProperty(options, name), options)\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\t/**\n\t\t\t\t * Assign result of {@link MakeConfigHandler}, if current value is `undefined`\n\t\t\t\t */\n\t\t\t\tcase \"make\":\n\t\t\t\t\tif (getProperty(options, name) === undefined) {\n\t\t\t\t\t\tsetProperty(options, name, this.defaults[name].call(this, options));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/**\n\t\t\t\t * Adding {@link AppendConfigValues} at the end of the current array\n\t\t\t\t */\n\t\t\t\tcase \"append\": {\n\t\t\t\t\tlet oldValue = getProperty(options, name);\n\t\t\t\t\tif (!Array.isArray(oldValue)) {\n\t\t\t\t\t\toldValue = [];\n\t\t\t\t\t}\n\t\t\t\t\toldValue.push(...this.defaults[name]);\n\t\t\t\t\tsetProperty(options, name, oldValue);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\"OptionsDefaulter cannot process \" + this.config[name]\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\t/**\n\t * Builds up default values\n\t * @param {string} name option path\n\t * @param {ConfigType | any} config if {@param def} is provided, then only {@link ConfigType} is allowed\n\t * @param {MakeConfigHandler | CallConfigHandler | AppendConfigValues} [def] defaults\n\t * @returns {void}\n\t */\n\tset(name, config, def) {\n\t\tif (def !== undefined) {\n\t\t\tthis.defaults[name] = def;\n\t\t\tthis.config[name] = config;\n\t\t} else {\n\t\t\tthis.defaults[name] = config;\n\t\t\tdelete this.config[name];\n\t\t}\n\t}\n}\n\nmodule.exports = OptionsDefaulter;\n"]},"metadata":{},"sourceType":"script"}