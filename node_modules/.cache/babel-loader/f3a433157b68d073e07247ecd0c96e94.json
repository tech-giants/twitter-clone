{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"./util/Queue\");\n\nconst addToSet = (a, b) => {\n  for (const item of b) {\n    a.add(item);\n  }\n};\n\nclass FlagDependencyExportsPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyExportsPlugin\", compilation => {\n      compilation.hooks.finishModules.tap(\"FlagDependencyExportsPlugin\", modules => {\n        const dependencies = new Map();\n        const queue = new Queue();\n        let module;\n        let moduleWithExports;\n        let moduleProvidedExports;\n        let providedExportsAreTemporary;\n\n        const processDependenciesBlock = depBlock => {\n          for (const dep of depBlock.dependencies) {\n            if (processDependency(dep)) return true;\n          }\n\n          for (const variable of depBlock.variables) {\n            for (const dep of variable.dependencies) {\n              if (processDependency(dep)) return true;\n            }\n          }\n\n          for (const block of depBlock.blocks) {\n            if (processDependenciesBlock(block)) return true;\n          }\n\n          return false;\n        };\n\n        const processDependency = dep => {\n          const exportDesc = dep.getExports && dep.getExports();\n          if (!exportDesc) return;\n          moduleWithExports = true;\n          const exports = exportDesc.exports; // break early if it's only in the worst state\n\n          if (module.buildMeta.providedExports === true) {\n            return true;\n          } // break if it should move to the worst state\n\n\n          if (exports === true) {\n            module.buildMeta.providedExports = true;\n            return true;\n          } // merge in new exports\n\n\n          if (Array.isArray(exports)) {\n            addToSet(moduleProvidedExports, exports);\n          } // store dependencies\n\n\n          const exportDeps = exportDesc.dependencies;\n\n          if (exportDeps) {\n            providedExportsAreTemporary = true;\n\n            for (const exportDependency of exportDeps) {\n              // add dependency for this module\n              const set = dependencies.get(exportDependency);\n\n              if (set === undefined) {\n                dependencies.set(exportDependency, new Set([module]));\n              } else {\n                set.add(module);\n              }\n            }\n          }\n\n          return false;\n        };\n\n        const notifyDependencies = () => {\n          const deps = dependencies.get(module);\n\n          if (deps !== undefined) {\n            for (const dep of deps) {\n              queue.enqueue(dep);\n            }\n          }\n        };\n\n        const notifyDependenciesIfDifferent = (set, array) => {\n          const deps = dependencies.get(module);\n\n          if (deps !== undefined) {\n            if (set.size === array.length) {\n              let i = 0;\n              let different = false;\n\n              for (const item of set) {\n                if (item !== array[i++]) {\n                  different = true;\n                  break;\n                }\n              }\n\n              if (!different) return;\n            }\n\n            for (const dep of deps) {\n              queue.enqueue(dep);\n            }\n          }\n        }; // Start with all modules without provided exports\n\n\n        for (const module of modules) {\n          if (module.buildInfo.temporaryProvidedExports) {\n            // Clear exports when they are temporary\n            // and recreate them\n            module.buildMeta.providedExports = null;\n            queue.enqueue(module);\n          } else if (!module.buildMeta.providedExports) {\n            queue.enqueue(module);\n          }\n        }\n\n        while (queue.length > 0) {\n          module = queue.dequeue();\n\n          if (module.buildMeta.providedExports !== true) {\n            moduleWithExports = module.buildMeta && module.buildMeta.exportsType;\n            moduleProvidedExports = new Set();\n            providedExportsAreTemporary = false;\n            processDependenciesBlock(module);\n            module.buildInfo.temporaryProvidedExports = providedExportsAreTemporary;\n\n            if (!moduleWithExports) {\n              notifyDependencies();\n              module.buildMeta.providedExports = true;\n            } else if (module.buildMeta.providedExports === true) {\n              notifyDependencies();\n            } else if (!module.buildMeta.providedExports) {\n              notifyDependencies();\n              module.buildMeta.providedExports = Array.from(moduleProvidedExports);\n            } else {\n              notifyDependenciesIfDifferent(moduleProvidedExports, module.buildMeta.providedExports);\n              module.buildMeta.providedExports = Array.from(moduleProvidedExports);\n            }\n          }\n        }\n      });\n      const providedExportsCache = new WeakMap();\n      compilation.hooks.rebuildModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        providedExportsCache.set(module, module.buildMeta.providedExports);\n      });\n      compilation.hooks.finishRebuildingModule.tap(\"FlagDependencyExportsPlugin\", module => {\n        module.buildMeta.providedExports = providedExportsCache.get(module);\n      });\n    });\n  }\n\n}\n\nmodule.exports = FlagDependencyExportsPlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/FlagDependencyExportsPlugin.js"],"names":["Queue","require","addToSet","a","b","item","add","FlagDependencyExportsPlugin","apply","compiler","hooks","compilation","tap","finishModules","modules","dependencies","Map","queue","module","moduleWithExports","moduleProvidedExports","providedExportsAreTemporary","processDependenciesBlock","depBlock","dep","processDependency","variable","variables","block","blocks","exportDesc","getExports","exports","buildMeta","providedExports","Array","isArray","exportDeps","exportDependency","set","get","undefined","Set","notifyDependencies","deps","enqueue","notifyDependenciesIfDifferent","array","size","length","i","different","buildInfo","temporaryProvidedExports","dequeue","exportsType","from","providedExportsCache","WeakMap","rebuildModule","finishRebuildingModule"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"./util/Queue\");\n\nconst addToSet = (a, b) => {\n\tfor (const item of b) {\n\t\ta.add(item);\n\t}\n};\n\nclass FlagDependencyExportsPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tcompilation.hooks.finishModules.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodules => {\n\t\t\t\t\t\tconst dependencies = new Map();\n\n\t\t\t\t\t\tconst queue = new Queue();\n\n\t\t\t\t\t\tlet module;\n\t\t\t\t\t\tlet moduleWithExports;\n\t\t\t\t\t\tlet moduleProvidedExports;\n\t\t\t\t\t\tlet providedExportsAreTemporary;\n\n\t\t\t\t\t\tconst processDependenciesBlock = depBlock => {\n\t\t\t\t\t\t\tfor (const dep of depBlock.dependencies) {\n\t\t\t\t\t\t\t\tif (processDependency(dep)) return true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const variable of depBlock.variables) {\n\t\t\t\t\t\t\t\tfor (const dep of variable.dependencies) {\n\t\t\t\t\t\t\t\t\tif (processDependency(dep)) return true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const block of depBlock.blocks) {\n\t\t\t\t\t\t\t\tif (processDependenciesBlock(block)) return true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processDependency = dep => {\n\t\t\t\t\t\t\tconst exportDesc = dep.getExports && dep.getExports();\n\t\t\t\t\t\t\tif (!exportDesc) return;\n\t\t\t\t\t\t\tmoduleWithExports = true;\n\t\t\t\t\t\t\tconst exports = exportDesc.exports;\n\t\t\t\t\t\t\t// break early if it's only in the worst state\n\t\t\t\t\t\t\tif (module.buildMeta.providedExports === true) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// break if it should move to the worst state\n\t\t\t\t\t\t\tif (exports === true) {\n\t\t\t\t\t\t\t\tmodule.buildMeta.providedExports = true;\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// merge in new exports\n\t\t\t\t\t\t\tif (Array.isArray(exports)) {\n\t\t\t\t\t\t\t\taddToSet(moduleProvidedExports, exports);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// store dependencies\n\t\t\t\t\t\t\tconst exportDeps = exportDesc.dependencies;\n\t\t\t\t\t\t\tif (exportDeps) {\n\t\t\t\t\t\t\t\tprovidedExportsAreTemporary = true;\n\t\t\t\t\t\t\t\tfor (const exportDependency of exportDeps) {\n\t\t\t\t\t\t\t\t\t// add dependency for this module\n\t\t\t\t\t\t\t\t\tconst set = dependencies.get(exportDependency);\n\t\t\t\t\t\t\t\t\tif (set === undefined) {\n\t\t\t\t\t\t\t\t\t\tdependencies.set(exportDependency, new Set([module]));\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tset.add(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst notifyDependencies = () => {\n\t\t\t\t\t\t\tconst deps = dependencies.get(module);\n\t\t\t\t\t\t\tif (deps !== undefined) {\n\t\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst notifyDependenciesIfDifferent = (set, array) => {\n\t\t\t\t\t\t\tconst deps = dependencies.get(module);\n\t\t\t\t\t\t\tif (deps !== undefined) {\n\t\t\t\t\t\t\t\tif (set.size === array.length) {\n\t\t\t\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\t\t\t\tlet different = false;\n\t\t\t\t\t\t\t\t\tfor (const item of set) {\n\t\t\t\t\t\t\t\t\t\tif (item !== array[i++]) {\n\t\t\t\t\t\t\t\t\t\t\tdifferent = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!different) return;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const dep of deps) {\n\t\t\t\t\t\t\t\t\tqueue.enqueue(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Start with all modules without provided exports\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tif (module.buildInfo.temporaryProvidedExports) {\n\t\t\t\t\t\t\t\t// Clear exports when they are temporary\n\t\t\t\t\t\t\t\t// and recreate them\n\t\t\t\t\t\t\t\tmodule.buildMeta.providedExports = null;\n\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t} else if (!module.buildMeta.providedExports) {\n\t\t\t\t\t\t\t\tqueue.enqueue(module);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\t\t\tmodule = queue.dequeue();\n\n\t\t\t\t\t\t\tif (module.buildMeta.providedExports !== true) {\n\t\t\t\t\t\t\t\tmoduleWithExports =\n\t\t\t\t\t\t\t\t\tmodule.buildMeta && module.buildMeta.exportsType;\n\t\t\t\t\t\t\t\tmoduleProvidedExports = new Set();\n\t\t\t\t\t\t\t\tprovidedExportsAreTemporary = false;\n\t\t\t\t\t\t\t\tprocessDependenciesBlock(module);\n\t\t\t\t\t\t\t\tmodule.buildInfo.temporaryProvidedExports = providedExportsAreTemporary;\n\t\t\t\t\t\t\t\tif (!moduleWithExports) {\n\t\t\t\t\t\t\t\t\tnotifyDependencies();\n\t\t\t\t\t\t\t\t\tmodule.buildMeta.providedExports = true;\n\t\t\t\t\t\t\t\t} else if (module.buildMeta.providedExports === true) {\n\t\t\t\t\t\t\t\t\tnotifyDependencies();\n\t\t\t\t\t\t\t\t} else if (!module.buildMeta.providedExports) {\n\t\t\t\t\t\t\t\t\tnotifyDependencies();\n\t\t\t\t\t\t\t\t\tmodule.buildMeta.providedExports = Array.from(\n\t\t\t\t\t\t\t\t\t\tmoduleProvidedExports\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnotifyDependenciesIfDifferent(\n\t\t\t\t\t\t\t\t\t\tmoduleProvidedExports,\n\t\t\t\t\t\t\t\t\t\tmodule.buildMeta.providedExports\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tmodule.buildMeta.providedExports = Array.from(\n\t\t\t\t\t\t\t\t\t\tmoduleProvidedExports\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tconst providedExportsCache = new WeakMap();\n\t\t\t\tcompilation.hooks.rebuildModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tprovidedExportsCache.set(module, module.buildMeta.providedExports);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.finishRebuildingModule.tap(\n\t\t\t\t\t\"FlagDependencyExportsPlugin\",\n\t\t\t\t\tmodule => {\n\t\t\t\t\t\tmodule.buildMeta.providedExports = providedExportsCache.get(module);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = FlagDependencyExportsPlugin;\n"]},"metadata":{},"sourceType":"script"}