{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst figgyPudding = require('figgy-pudding');\n\nconst Transform = require('stream').Transform;\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/;\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nconst SsriOpts = figgyPudding({\n  algorithms: {\n    default: ['sha512']\n  },\n  error: {\n    default: false\n  },\n  integrity: {},\n  options: {\n    default: []\n  },\n  pickAlgorithm: {\n    default: () => getPrioritizedHash\n  },\n  Promise: {\n    default: () => Promise\n  },\n  sep: {\n    default: ' '\n  },\n  single: {\n    default: false\n  },\n  size: {},\n  strict: {\n    default: false\n  }\n});\n\nclass Hash {\n  get isHash() {\n    return true;\n  }\n\n  constructor(hash, opts) {\n    opts = SsriOpts(opts);\n    const strict = !!opts.strict;\n    this.source = hash.trim(); // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n    const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n    if (!match) {\n      return;\n    }\n\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n      return;\n    }\n\n    this.algorithm = match[1];\n    this.digest = match[2];\n    const rawOpts = match[3];\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : [];\n  }\n\n  hexDigest() {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!( // The spec has very restricted productions for algorithms.\n      // https://www.w3.org/TR/CSP2/#source-list-syntax\n      SPEC_ALGORITHMS.some(x => x === this.algorithm) && // Usually, if someone insists on using a \"different\" base64, we\n      // leave it as-is, since there's multiple standards, and the\n      // specified is not a URL-safe variant.\n      // https://www.w3.org/TR/CSP2/#base64_value\n      this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n      // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n      // https://tools.ietf.org/html/rfc5234#appendix-B.1\n      (this.options || []).every(opt => opt.match(VCHAR_REGEX)))) {\n        return '';\n      }\n    }\n\n    const options = this.options && this.options.length ? `?${this.options.join('?')}` : '';\n    return `${this.algorithm}-${this.digest}${options}`;\n  }\n\n}\n\nclass Integrity {\n  get isIntegrity() {\n    return true;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n\n  toString(opts) {\n    opts = SsriOpts(opts);\n    let sep = opts.sep || ' ';\n\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ');\n    }\n\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts);\n      }).filter(x => x.length).join(sep);\n    }).filter(x => x.length).join(sep);\n  }\n\n  concat(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n    return parse(`${this.toString(opts)} ${other}`, opts);\n  }\n\n  hexDigest() {\n    return parse(this, {\n      single: true\n    }).hexDigest();\n  }\n\n  match(integrity, opts) {\n    opts = SsriOpts(opts);\n    const other = parse(integrity, opts);\n    const algo = other.pickAlgorithm(opts);\n    return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n  }\n\n  pickAlgorithm(opts) {\n    opts = SsriOpts(opts);\n    const pickAlgorithm = opts.pickAlgorithm;\n    const keys = Object.keys(this);\n\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);\n    }\n\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc;\n    });\n  }\n\n}\n\nmodule.exports.parse = parse;\n\nfunction parse(sri, opts) {\n  opts = SsriOpts(opts);\n\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\n\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.stringify = stringify;\n\nfunction stringify(obj, opts) {\n  opts = SsriOpts(opts);\n\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\n\nmodule.exports.fromHex = fromHex;\n\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts);\n  const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n  return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n}\n\nmodule.exports.fromData = fromData;\n\nfunction fromData(data, opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64');\n    const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.fromStream = fromStream;\n\nfunction fromStream(stream, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const istream = integrityStream(opts);\n  return new P((resolve, reject) => {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    let sri;\n    istream.on('integrity', s => {\n      sri = s;\n    });\n    istream.on('end', () => resolve(sri));\n    istream.on('data', () => {});\n  });\n}\n\nmodule.exports.checkData = checkData;\n\nfunction checkData(data, sri, opts) {\n  opts = SsriOpts(opts);\n  sri = parse(sri, opts);\n\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n\n  const algorithm = sri.pickAlgorithm(opts);\n  const digest = crypto.createHash(algorithm).update(data).digest('base64');\n  const newSri = parse({\n    algorithm,\n    digest\n  });\n  const match = newSri.match(sri, opts);\n\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n    err.code = 'EINTEGRITY';\n    err.found = newSri;\n    err.expected = sri;\n    err.algorithm = algorithm;\n    err.sri = sri;\n    throw err;\n  }\n}\n\nmodule.exports.checkStream = checkStream;\n\nfunction checkStream(stream, sri, opts) {\n  opts = SsriOpts(opts);\n  const P = opts.Promise || Promise;\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }));\n  return new P((resolve, reject) => {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    let sri;\n    checker.on('verified', s => {\n      sri = s;\n    });\n    checker.on('end', () => resolve(sri));\n    checker.on('data', () => {});\n  });\n}\n\nmodule.exports.integrityStream = integrityStream;\n\nfunction integrityStream(opts) {\n  opts = SsriOpts(opts); // For verification\n\n  const sri = opts.integrity && parse(opts.integrity, opts);\n  const goodSri = sri && Object.keys(sri).length;\n  const algorithm = goodSri && sri.pickAlgorithm(opts);\n  const digests = goodSri && sri[algorithm]; // Calculating stream\n\n  const algorithms = Array.from(new Set(opts.algorithms.concat(algorithm ? [algorithm] : [])));\n  const hashes = algorithms.map(crypto.createHash);\n  let streamSize = 0;\n  const stream = new Transform({\n    transform(chunk, enc, cb) {\n      streamSize += chunk.length;\n      hashes.forEach(h => h.update(chunk, enc));\n      cb(null, chunk, enc);\n    }\n\n  }).on('end', () => {\n    const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`;\n    }).join(' '), opts); // Integrity verification mode\n\n    const match = goodSri && newSri.match(sri, opts);\n\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`);\n      err.code = 'EBADSIZE';\n      err.found = streamSize;\n      err.expected = opts.size;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`);\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = digests;\n      err.algorithm = algorithm;\n      err.sri = sri;\n      stream.emit('error', err);\n    } else {\n      stream.emit('size', streamSize);\n      stream.emit('integrity', newSri);\n      match && stream.emit('verified', match);\n    }\n  });\n  return stream;\n}\n\nmodule.exports.create = createIntegrity;\n\nfunction createIntegrity(opts) {\n  opts = SsriOpts(opts);\n  const algorithms = opts.algorithms;\n  const optString = opts.options.length ? `?${opts.options.join('?')}` : '';\n  const hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc));\n      return this;\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64');\n        const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm;\n\n          if (!acc[algo]) {\n            acc[algo] = [];\n          }\n\n          acc[algo].push(hash);\n        }\n\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\nconst DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\n\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/node_modules/ssri/index.js"],"names":["crypto","require","figgyPudding","Transform","SPEC_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","SsriOpts","algorithms","default","error","integrity","options","pickAlgorithm","getPrioritizedHash","Promise","sep","single","size","strict","Hash","isHash","constructor","hash","opts","source","trim","match","some","a","algorithm","digest","rawOpts","slice","split","hexDigest","Buffer","from","toString","toJSON","x","every","opt","length","join","Integrity","isIntegrity","replace","Object","keys","map","k","prototype","call","filter","concat","other","stringify","parse","algo","find","otherhash","Error","JSON","reduce","acc","module","exports","sri","_parse","fullSri","string","push","obj","fromHex","optString","fromData","data","createHash","update","fromStream","stream","P","istream","integrityStream","resolve","reject","pipe","on","s","checkData","assign","code","newSri","err","found","expected","checkStream","checker","goodSri","digests","Array","Set","hashes","streamSize","transform","chunk","enc","cb","forEach","h","i","emit","create","createIntegrity","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","has","algo1","algo2","indexOf","toLowerCase"],"mappings":"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","sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst figgyPudding = require('figgy-pudding')\nconst Transform = require('stream').Transform\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst SsriOpts = figgyPudding({\n  algorithms: {default: ['sha512']},\n  error: {default: false},\n  integrity: {},\n  options: {default: []},\n  pickAlgorithm: {default: () => getPrioritizedHash},\n  Promise: {default: () => Promise},\n  sep: {default: ' '},\n  single: {default: false},\n  size: {},\n  strict: {default: false}\n})\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    opts = SsriOpts(opts)\n    const strict = !!opts.strict\n    this.source = hash.trim()\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n      ? STRICT_SRI_REGEX\n      : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    this.options = rawOpts ? rawOpts.slice(1).split('?') : []\n  }\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = SsriOpts(opts)\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n    ? `?${this.options.join('?')}`\n    : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n  toString (opts) {\n    opts = SsriOpts(opts)\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n  concat (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = typeof integrity === 'string'\n    ? integrity\n    : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n  hexDigest () {\n    return parse(this, {single: true}).hexDigest()\n  }\n  match (integrity, opts) {\n    opts = SsriOpts(opts)\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n  pickAlgorithm (opts) {\n    opts = SsriOpts(opts)\n    const pickAlgorithm = opts.pickAlgorithm\n    const keys = Object.keys(this)\n    if (!keys.length) {\n      throw new Error(`No algorithms available for ${\n        JSON.stringify(this.toString())\n      }`)\n    }\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  opts = SsriOpts(opts)\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  opts = SsriOpts(opts)\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  opts = SsriOpts(opts)\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = opts.options && opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n       opts\n    )\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = SsriOpts(opts)\n  const P = opts.Promise || Promise\n  const istream = integrityStream(opts)\n  return new P((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = SsriOpts(opts)\n  sri = parse(sri, opts)\n  if (!Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({algorithm, digest})\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = SsriOpts(opts)\n  const P = opts.Promise || Promise\n  const checker = integrityStream(opts.concat({\n    integrity: sri\n  }))\n  return new P((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts) {\n  opts = SsriOpts(opts)\n  // For verification\n  const sri = opts.integrity && parse(opts.integrity, opts)\n  const goodSri = sri && Object.keys(sri).length\n  const algorithm = goodSri && sri.pickAlgorithm(opts)\n  const digests = goodSri && sri[algorithm]\n  // Calculating stream\n  const algorithms = Array.from(\n    new Set(opts.algorithms.concat(algorithm ? [algorithm] : []))\n  )\n  const hashes = algorithms.map(crypto.createHash)\n  let streamSize = 0\n  const stream = new Transform({\n    transform (chunk, enc, cb) {\n      streamSize += chunk.length\n      hashes.forEach(h => h.update(chunk, enc))\n      cb(null, chunk, enc)\n    }\n  }).on('end', () => {\n    const optString = (opts.options && opts.options.length)\n    ? `?${opts.options.join('?')}`\n    : ''\n    const newSri = parse(hashes.map((h, i) => {\n      return `${algorithms[i]}-${h.digest('base64')}${optString}`\n    }).join(' '), opts)\n    // Integrity verification mode\n    const match = goodSri && newSri.match(sri, opts)\n    if (typeof opts.size === 'number' && streamSize !== opts.size) {\n      const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`)\n      err.code = 'EBADSIZE'\n      err.found = streamSize\n      err.expected = opts.size\n      err.sri = sri\n      stream.emit('error', err)\n    } else if (opts.integrity && !match) {\n      const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = digests\n      err.algorithm = algorithm\n      err.sri = sri\n      stream.emit('error', err)\n    } else {\n      stream.emit('size', streamSize)\n      stream.emit('integrity', newSri)\n      match && stream.emit('verified', match)\n    }\n  })\n  return stream\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = SsriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = opts.options.length\n  ? `?${opts.options.join('?')}`\n  : ''\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n  ? algo1\n  : algo2\n}\n"]},"metadata":{},"sourceType":"script"}