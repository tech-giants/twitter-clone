{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AliasPlugin = require(\"enhanced-resolve/lib/AliasPlugin\");\n\nconst ParserHelpers = require(\"../ParserHelpers\");\n\nconst nodeLibsBrowser = require(\"node-libs-browser\");\n\nmodule.exports = class NodeSourcePlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  apply(compiler) {\n    const options = this.options;\n\n    if (options === false) {\n      // allow single kill switch to turn off this plugin\n      return;\n    }\n\n    const getPathToModule = (module, type) => {\n      if (type === true || type === undefined && nodeLibsBrowser[module]) {\n        if (!nodeLibsBrowser[module]) {\n          throw new Error(`No browser version for node.js core module ${module} available`);\n        }\n\n        return nodeLibsBrowser[module];\n      } else if (type === \"mock\") {\n        return require.resolve(`node-libs-browser/mock/${module}`);\n      } else if (type === \"empty\") {\n        return require.resolve(\"node-libs-browser/mock/empty\");\n      } else {\n        return module;\n      }\n    };\n\n    const addExpression = (parser, name, module, type, suffix) => {\n      suffix = suffix || \"\";\n      parser.hooks.expression.for(name).tap(\"NodeSourcePlugin\", () => {\n        if (parser.state.module && parser.state.module.resource === getPathToModule(module, type)) return;\n        const mockModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, getPathToModule(module, type));\n        return ParserHelpers.addParsedVariableToModule(parser, name, mockModule + suffix);\n      });\n    };\n\n    compiler.hooks.compilation.tap(\"NodeSourcePlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      const handler = (parser, parserOptions) => {\n        if (parserOptions.node === false) return;\n        let localOptions = options;\n\n        if (parserOptions.node) {\n          localOptions = Object.assign({}, localOptions, parserOptions.node);\n        }\n\n        if (localOptions.global) {\n          parser.hooks.expression.for(\"global\").tap(\"NodeSourcePlugin\", () => {\n            const retrieveGlobalModule = ParserHelpers.requireFileAsExpression(parser.state.module.context, require.resolve(\"../../buildin/global\"));\n            return ParserHelpers.addParsedVariableToModule(parser, \"global\", retrieveGlobalModule);\n          });\n        }\n\n        if (localOptions.process) {\n          const processType = localOptions.process;\n          addExpression(parser, \"process\", \"process\", processType);\n        }\n\n        if (localOptions.console) {\n          const consoleType = localOptions.console;\n          addExpression(parser, \"console\", \"console\", consoleType);\n        }\n\n        const bufferType = localOptions.Buffer;\n\n        if (bufferType) {\n          addExpression(parser, \"Buffer\", \"buffer\", bufferType, \".Buffer\");\n        }\n\n        if (localOptions.setImmediate) {\n          const setImmediateType = localOptions.setImmediate;\n          addExpression(parser, \"setImmediate\", \"timers\", setImmediateType, \".setImmediate\");\n          addExpression(parser, \"clearImmediate\", \"timers\", setImmediateType, \".clearImmediate\");\n        }\n      };\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"NodeSourcePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"NodeSourcePlugin\", handler);\n    });\n    compiler.hooks.afterResolvers.tap(\"NodeSourcePlugin\", compiler => {\n      for (const lib of Object.keys(nodeLibsBrowser)) {\n        if (options[lib] !== false) {\n          compiler.resolverFactory.hooks.resolver.for(\"normal\").tap(\"NodeSourcePlugin\", resolver => {\n            new AliasPlugin(\"described-resolve\", {\n              name: lib,\n              onlyModule: true,\n              alias: getPathToModule(lib, options[lib])\n            }, \"resolve\").apply(resolver);\n          });\n        }\n      }\n    });\n  }\n\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/node/NodeSourcePlugin.js"],"names":["AliasPlugin","require","ParserHelpers","nodeLibsBrowser","module","exports","NodeSourcePlugin","constructor","options","apply","compiler","getPathToModule","type","undefined","Error","resolve","addExpression","parser","name","suffix","hooks","expression","for","tap","state","resource","mockModule","requireFileAsExpression","context","addParsedVariableToModule","compilation","normalModuleFactory","handler","parserOptions","node","localOptions","Object","assign","global","retrieveGlobalModule","process","processType","console","consoleType","bufferType","Buffer","setImmediate","setImmediateType","afterResolvers","lib","keys","resolverFactory","resolver","onlyModule","alias"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\nconst AliasPlugin = require(\"enhanced-resolve/lib/AliasPlugin\");\nconst ParserHelpers = require(\"../ParserHelpers\");\nconst nodeLibsBrowser = require(\"node-libs-browser\");\n\nmodule.exports = class NodeSourcePlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tif (options === false) {\n\t\t\t// allow single kill switch to turn off this plugin\n\t\t\treturn;\n\t\t}\n\n\t\tconst getPathToModule = (module, type) => {\n\t\t\tif (type === true || (type === undefined && nodeLibsBrowser[module])) {\n\t\t\t\tif (!nodeLibsBrowser[module]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No browser version for node.js core module ${module} available`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn nodeLibsBrowser[module];\n\t\t\t} else if (type === \"mock\") {\n\t\t\t\treturn require.resolve(`node-libs-browser/mock/${module}`);\n\t\t\t} else if (type === \"empty\") {\n\t\t\t\treturn require.resolve(\"node-libs-browser/mock/empty\");\n\t\t\t} else {\n\t\t\t\treturn module;\n\t\t\t}\n\t\t};\n\n\t\tconst addExpression = (parser, name, module, type, suffix) => {\n\t\t\tsuffix = suffix || \"\";\n\t\t\tparser.hooks.expression.for(name).tap(\"NodeSourcePlugin\", () => {\n\t\t\t\tif (\n\t\t\t\t\tparser.state.module &&\n\t\t\t\t\tparser.state.module.resource === getPathToModule(module, type)\n\t\t\t\t)\n\t\t\t\t\treturn;\n\t\t\t\tconst mockModule = ParserHelpers.requireFileAsExpression(\n\t\t\t\t\tparser.state.module.context,\n\t\t\t\t\tgetPathToModule(module, type)\n\t\t\t\t);\n\t\t\t\treturn ParserHelpers.addParsedVariableToModule(\n\t\t\t\t\tparser,\n\t\t\t\t\tname,\n\t\t\t\t\tmockModule + suffix\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"NodeSourcePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tif (parserOptions.node === false) return;\n\n\t\t\t\t\tlet localOptions = options;\n\t\t\t\t\tif (parserOptions.node) {\n\t\t\t\t\t\tlocalOptions = Object.assign({}, localOptions, parserOptions.node);\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.global) {\n\t\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t\t.for(\"global\")\n\t\t\t\t\t\t\t.tap(\"NodeSourcePlugin\", () => {\n\t\t\t\t\t\t\t\tconst retrieveGlobalModule = ParserHelpers.requireFileAsExpression(\n\t\t\t\t\t\t\t\t\tparser.state.module.context,\n\t\t\t\t\t\t\t\t\trequire.resolve(\"../../buildin/global\")\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn ParserHelpers.addParsedVariableToModule(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\"global\",\n\t\t\t\t\t\t\t\t\tretrieveGlobalModule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.process) {\n\t\t\t\t\t\tconst processType = localOptions.process;\n\t\t\t\t\t\taddExpression(parser, \"process\", \"process\", processType);\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.console) {\n\t\t\t\t\t\tconst consoleType = localOptions.console;\n\t\t\t\t\t\taddExpression(parser, \"console\", \"console\", consoleType);\n\t\t\t\t\t}\n\t\t\t\t\tconst bufferType = localOptions.Buffer;\n\t\t\t\t\tif (bufferType) {\n\t\t\t\t\t\taddExpression(parser, \"Buffer\", \"buffer\", bufferType, \".Buffer\");\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.setImmediate) {\n\t\t\t\t\t\tconst setImmediateType = localOptions.setImmediate;\n\t\t\t\t\t\taddExpression(\n\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\"setImmediate\",\n\t\t\t\t\t\t\t\"timers\",\n\t\t\t\t\t\t\tsetImmediateType,\n\t\t\t\t\t\t\t\".setImmediate\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\taddExpression(\n\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\"clearImmediate\",\n\t\t\t\t\t\t\t\"timers\",\n\t\t\t\t\t\t\tsetImmediateType,\n\t\t\t\t\t\t\t\".clearImmediate\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"NodeSourcePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"NodeSourcePlugin\", handler);\n\t\t\t}\n\t\t);\n\t\tcompiler.hooks.afterResolvers.tap(\"NodeSourcePlugin\", compiler => {\n\t\t\tfor (const lib of Object.keys(nodeLibsBrowser)) {\n\t\t\t\tif (options[lib] !== false) {\n\t\t\t\t\tcompiler.resolverFactory.hooks.resolver\n\t\t\t\t\t\t.for(\"normal\")\n\t\t\t\t\t\t.tap(\"NodeSourcePlugin\", resolver => {\n\t\t\t\t\t\t\tnew AliasPlugin(\n\t\t\t\t\t\t\t\t\"described-resolve\",\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: lib,\n\t\t\t\t\t\t\t\t\tonlyModule: true,\n\t\t\t\t\t\t\t\t\talias: getPathToModule(lib, options[lib])\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\"resolve\"\n\t\t\t\t\t\t\t).apply(resolver);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}