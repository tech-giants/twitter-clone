{"ast":null,"code":"'use strict';\n\nconst DEFAULT_OPTIONS = {\n  workerOptions: {},\n  maxCallsPerWorker: Infinity,\n  maxConcurrentWorkers: (require('os').cpus() || {\n    length: 1\n  }).length,\n  maxConcurrentCallsPerWorker: 10,\n  maxConcurrentCalls: Infinity,\n  maxCallTime: Infinity // exceed this and the whole worker is terminated\n  ,\n  maxRetries: Infinity,\n  forcedKillTime: 100,\n  autoStart: false,\n  onChild: function () {}\n};\n\nconst fork = require('./fork'),\n      TimeoutError = require('errno').create('TimeoutError'),\n      ProcessTerminatedError = require('errno').create('ProcessTerminatedError'),\n      MaxConcurrentCallsError = require('errno').create('MaxConcurrentCallsError');\n\nfunction Farm(options, path) {\n  this.options = Object.assign({}, DEFAULT_OPTIONS, options);\n  this.path = path;\n  this.activeCalls = 0;\n} // make a handle to pass back in the form of an external API\n\n\nFarm.prototype.mkhandle = function (method) {\n  return function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {\n      let err = new MaxConcurrentCallsError('Too many concurrent calls (active: ' + this.activeCalls + ', queued: ' + this.callQueue.length + ')');\n      if (typeof args[args.length - 1] == 'function') return process.nextTick(args[args.length - 1].bind(null, err));\n      throw err;\n    }\n\n    this.addCall({\n      method: method,\n      callback: args.pop(),\n      args: args,\n      retries: 0\n    });\n  }.bind(this);\n}; // a constructor of sorts\n\n\nFarm.prototype.setup = function (methods) {\n  let iface;\n\n  if (!methods) {\n    // single-function export\n    iface = this.mkhandle();\n  } else {\n    // multiple functions on the export\n    iface = {};\n    methods.forEach(function (m) {\n      iface[m] = this.mkhandle(m);\n    }.bind(this));\n  }\n\n  this.searchStart = -1;\n  this.childId = -1;\n  this.children = {};\n  this.activeChildren = 0;\n  this.callQueue = [];\n\n  if (this.options.autoStart) {\n    while (this.activeChildren < this.options.maxConcurrentWorkers) this.startChild();\n  }\n\n  return iface;\n}; // when a child exits, check if there are any outstanding jobs and requeue them\n\n\nFarm.prototype.onExit = function (childId) {\n  // delay this to give any sends a chance to finish\n  setTimeout(function () {\n    let doQueue = false;\n\n    if (this.children[childId] && this.children[childId].activeCalls) {\n      this.children[childId].calls.forEach(function (call, i) {\n        if (!call) return;else if (call.retries >= this.options.maxRetries) {\n          this.receive({\n            idx: i,\n            child: childId,\n            args: [new ProcessTerminatedError('cancel after ' + call.retries + ' retries!')]\n          });\n        } else {\n          call.retries++;\n          this.callQueue.unshift(call);\n          doQueue = true;\n        }\n      }.bind(this));\n    }\n\n    this.stopChild(childId);\n    doQueue && this.processQueue();\n  }.bind(this), 10);\n}; // start a new worker\n\n\nFarm.prototype.startChild = function () {\n  this.childId++;\n  let forked = fork(this.path, this.options.workerOptions),\n      id = this.childId,\n      c = {\n    send: forked.send,\n    child: forked.child,\n    calls: [],\n    activeCalls: 0,\n    exitCode: null\n  };\n  this.options.onChild(forked.child);\n  forked.child.on('message', function (data) {\n    if (data.owner !== 'farm') {\n      return;\n    }\n\n    this.receive(data);\n  }.bind(this));\n  forked.child.once('exit', function (code) {\n    c.exitCode = code;\n    this.onExit(id);\n  }.bind(this));\n  this.activeChildren++;\n  this.children[id] = c;\n}; // stop a worker, identified by id\n\n\nFarm.prototype.stopChild = function (childId) {\n  let child = this.children[childId];\n\n  if (child) {\n    child.send({\n      owner: 'farm',\n      event: 'die'\n    });\n    setTimeout(function () {\n      if (child.exitCode === null) child.child.kill('SIGKILL');\n    }, this.options.forcedKillTime).unref();\n    delete this.children[childId];\n    this.activeChildren--;\n  }\n}; // called from a child process, the data contains information needed to\n// look up the child and the original call so we can invoke the callback\n\n\nFarm.prototype.receive = function (data) {\n  let idx = data.idx,\n      childId = data.child,\n      args = data.args,\n      child = this.children[childId],\n      call;\n\n  if (!child) {\n    return console.error('Worker Farm: Received message for unknown child. ' + 'This is likely as a result of premature child death, ' + 'the operation will have been re-queued.');\n  }\n\n  call = child.calls[idx];\n\n  if (!call) {\n    return console.error('Worker Farm: Received message for unknown index for existing child. ' + 'This should not happen!');\n  }\n\n  if (this.options.maxCallTime !== Infinity) clearTimeout(call.timer);\n\n  if (args[0] && args[0].$error == '$error') {\n    let e = args[0];\n\n    switch (e.type) {\n      case 'TypeError':\n        args[0] = new TypeError(e.message);\n        break;\n\n      case 'RangeError':\n        args[0] = new RangeError(e.message);\n        break;\n\n      case 'EvalError':\n        args[0] = new EvalError(e.message);\n        break;\n\n      case 'ReferenceError':\n        args[0] = new ReferenceError(e.message);\n        break;\n\n      case 'SyntaxError':\n        args[0] = new SyntaxError(e.message);\n        break;\n\n      case 'URIError':\n        args[0] = new URIError(e.message);\n        break;\n\n      default:\n        args[0] = new Error(e.message);\n    }\n\n    args[0].type = e.type;\n    args[0].stack = e.stack; // Copy any custom properties to pass it on.\n\n    Object.keys(e).forEach(function (key) {\n      args[0][key] = e[key];\n    });\n  }\n\n  process.nextTick(function () {\n    call.callback.apply(null, args);\n  });\n  delete child.calls[idx];\n  child.activeCalls--;\n  this.activeCalls--;\n\n  if (child.calls.length >= this.options.maxCallsPerWorker && !Object.keys(child.calls).length) {\n    // this child has finished its run, kill it\n    this.stopChild(childId);\n  } // allow any outstanding calls to be processed\n\n\n  this.processQueue();\n};\n\nFarm.prototype.childTimeout = function (childId) {\n  let child = this.children[childId],\n      i;\n  if (!child) return;\n\n  for (i in child.calls) {\n    this.receive({\n      idx: i,\n      child: childId,\n      args: [new TimeoutError('worker call timed out!')]\n    });\n  }\n\n  this.stopChild(childId);\n}; // send a call to a worker, identified by id\n\n\nFarm.prototype.send = function (childId, call) {\n  let child = this.children[childId],\n      idx = child.calls.length;\n  child.calls.push(call);\n  child.activeCalls++;\n  this.activeCalls++;\n  child.send({\n    owner: 'farm',\n    idx: idx,\n    child: childId,\n    method: call.method,\n    args: call.args\n  });\n\n  if (this.options.maxCallTime !== Infinity) {\n    call.timer = setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime);\n  }\n}; // a list of active worker ids, in order, but the starting offset is\n// shifted each time this method is called, so we work our way through\n// all workers when handing out jobs\n\n\nFarm.prototype.childKeys = function () {\n  let cka = Object.keys(this.children),\n      cks;\n  if (this.searchStart >= cka.length - 1) this.searchStart = 0;else this.searchStart++;\n  cks = cka.splice(0, this.searchStart);\n  return cka.concat(cks);\n}; // Calls are added to a queue, this processes the queue and is called\n// whenever there might be a chance to send more calls to the workers.\n// The various options all impact on when we're able to send calls,\n// they may need to be kept in a queue until a worker is ready.\n\n\nFarm.prototype.processQueue = function () {\n  let cka,\n      i = 0,\n      childId;\n  if (!this.callQueue.length) return this.ending && this.end();\n  if (this.activeChildren < this.options.maxConcurrentWorkers) this.startChild();\n\n  for (cka = this.childKeys(); i < cka.length; i++) {\n    childId = +cka[i];\n\n    if (this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker && this.children[childId].calls.length < this.options.maxCallsPerWorker) {\n      this.send(childId, this.callQueue.shift());\n      if (!this.callQueue.length) return this.ending && this.end();\n    }\n    /*else {\n    console.log(\n      , this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n      , this.children[childId].calls.length < this.options.maxCallsPerWorker\n      , this.children[childId].calls.length , this.options.maxCallsPerWorker)\n    }*/\n\n  }\n\n  if (this.ending) this.end();\n}; // add a new call to the call queue, then trigger a process of the queue\n\n\nFarm.prototype.addCall = function (call) {\n  if (this.ending) return this.end(); // don't add anything new to the queue\n\n  this.callQueue.push(call);\n  this.processQueue();\n}; // kills child workers when they're all done\n\n\nFarm.prototype.end = function (callback) {\n  let complete = true;\n  if (this.ending === false) return;\n  if (callback) this.ending = callback;else if (this.ending == null) this.ending = true;\n  Object.keys(this.children).forEach(function (child) {\n    if (!this.children[child]) return;\n    if (!this.children[child].activeCalls) this.stopChild(child);else complete = false;\n  }.bind(this));\n\n  if (complete && typeof this.ending == 'function') {\n    process.nextTick(function () {\n      this.ending();\n      this.ending = false;\n    }.bind(this));\n  }\n};\n\nmodule.exports = Farm;\nmodule.exports.TimeoutError = TimeoutError;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/worker-farm/lib/farm.js"],"names":["DEFAULT_OPTIONS","workerOptions","maxCallsPerWorker","Infinity","maxConcurrentWorkers","require","cpus","length","maxConcurrentCallsPerWorker","maxConcurrentCalls","maxCallTime","maxRetries","forcedKillTime","autoStart","onChild","fork","TimeoutError","create","ProcessTerminatedError","MaxConcurrentCallsError","Farm","options","path","Object","assign","activeCalls","prototype","mkhandle","method","args","Array","slice","call","arguments","callQueue","err","process","nextTick","bind","addCall","callback","pop","retries","setup","methods","iface","forEach","m","searchStart","childId","children","activeChildren","startChild","onExit","setTimeout","doQueue","calls","i","receive","idx","child","unshift","stopChild","processQueue","forked","id","c","send","exitCode","on","data","owner","once","code","event","kill","unref","console","error","clearTimeout","timer","$error","e","type","TypeError","message","RangeError","EvalError","ReferenceError","SyntaxError","URIError","Error","stack","keys","key","apply","childTimeout","push","childKeys","cka","cks","splice","concat","ending","end","shift","complete","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst DEFAULT_OPTIONS = {\n          workerOptions               : {}\n        , maxCallsPerWorker           : Infinity\n        , maxConcurrentWorkers        : (require('os').cpus() || { length: 1 }).length\n        , maxConcurrentCallsPerWorker : 10\n        , maxConcurrentCalls          : Infinity\n        , maxCallTime                 : Infinity // exceed this and the whole worker is terminated\n        , maxRetries                  : Infinity\n        , forcedKillTime              : 100\n        , autoStart                   : false\n        , onChild                     : function() {}\n      }\n\nconst fork                    = require('./fork')\n    , TimeoutError            = require('errno').create('TimeoutError')\n    , ProcessTerminatedError  = require('errno').create('ProcessTerminatedError')\n    , MaxConcurrentCallsError = require('errno').create('MaxConcurrentCallsError')\n\n\nfunction Farm (options, path) {\n  this.options     = Object.assign({}, DEFAULT_OPTIONS, options)\n  this.path        = path\n  this.activeCalls = 0\n}\n\n\n// make a handle to pass back in the form of an external API\nFarm.prototype.mkhandle = function (method) {\n  return function () {\n    let args = Array.prototype.slice.call(arguments)\n    if (this.activeCalls + this.callQueue.length >= this.options.maxConcurrentCalls) {\n      let err = new MaxConcurrentCallsError('Too many concurrent calls (active: ' + this.activeCalls + ', queued: ' + this.callQueue.length + ')')\n      if (typeof args[args.length - 1] == 'function')\n        return process.nextTick(args[args.length - 1].bind(null, err))\n      throw err\n    }\n    this.addCall({\n        method   : method\n      , callback : args.pop()\n      , args     : args\n      , retries  : 0\n    })\n  }.bind(this)\n}\n\n\n// a constructor of sorts\nFarm.prototype.setup = function (methods) {\n  let iface\n  if (!methods) { // single-function export\n    iface = this.mkhandle()\n  } else { // multiple functions on the export\n    iface = {}\n    methods.forEach(function (m) {\n      iface[m] = this.mkhandle(m)\n    }.bind(this))\n  }\n\n  this.searchStart    = -1\n  this.childId        = -1\n  this.children       = {}\n  this.activeChildren = 0\n  this.callQueue      = []\n\n  if (this.options.autoStart) {\n    while (this.activeChildren < this.options.maxConcurrentWorkers)\n      this.startChild()\n  }\n\n  return iface\n}\n\n\n// when a child exits, check if there are any outstanding jobs and requeue them\nFarm.prototype.onExit = function (childId) {\n  // delay this to give any sends a chance to finish\n  setTimeout(function () {\n    let doQueue = false\n    if (this.children[childId] && this.children[childId].activeCalls) {\n      this.children[childId].calls.forEach(function (call, i) {\n        if (!call) return\n        else if (call.retries >= this.options.maxRetries) {\n          this.receive({\n              idx   : i\n            , child : childId\n            , args  : [ new ProcessTerminatedError('cancel after ' + call.retries + ' retries!') ]\n          })\n        } else {\n          call.retries++\n          this.callQueue.unshift(call)\n          doQueue = true\n        }\n      }.bind(this))\n    }\n    this.stopChild(childId)\n    doQueue && this.processQueue()\n  }.bind(this), 10)\n}\n\n\n// start a new worker\nFarm.prototype.startChild = function () {\n  this.childId++\n\n  let forked = fork(this.path, this.options.workerOptions)\n    , id     = this.childId\n    , c      = {\n          send        : forked.send\n        , child       : forked.child\n        , calls       : []\n        , activeCalls : 0\n        , exitCode    : null\n      }\n\n  this.options.onChild(forked.child);\n\n  forked.child.on('message', function(data) {\n    if (data.owner !== 'farm') {\n      return;\n    }\n    this.receive(data);\n  }.bind(this))\n  forked.child.once('exit', function (code) {\n    c.exitCode = code\n    this.onExit(id)\n  }.bind(this))\n\n  this.activeChildren++\n  this.children[id] = c\n}\n\n\n// stop a worker, identified by id\nFarm.prototype.stopChild = function (childId) {\n  let child = this.children[childId]\n  if (child) {\n    child.send({owner: 'farm', event: 'die'})\n    setTimeout(function () {\n      if (child.exitCode === null)\n        child.child.kill('SIGKILL')\n    }, this.options.forcedKillTime).unref()\n    ;delete this.children[childId]\n    this.activeChildren--\n  }\n}\n\n\n// called from a child process, the data contains information needed to\n// look up the child and the original call so we can invoke the callback\nFarm.prototype.receive = function (data) {\n  let idx     = data.idx\n    , childId = data.child\n    , args    = data.args\n    , child   = this.children[childId]\n    , call\n\n  if (!child) {\n    return console.error(\n        'Worker Farm: Received message for unknown child. '\n      + 'This is likely as a result of premature child death, '\n      + 'the operation will have been re-queued.'\n    )\n  }\n\n  call = child.calls[idx]\n  if (!call) {\n    return console.error(\n        'Worker Farm: Received message for unknown index for existing child. '\n      + 'This should not happen!'\n    )\n  }\n\n  if (this.options.maxCallTime !== Infinity)\n    clearTimeout(call.timer)\n\n  if (args[0] && args[0].$error == '$error') {\n    let e = args[0]\n    switch (e.type) {\n      case 'TypeError': args[0] = new TypeError(e.message); break\n      case 'RangeError': args[0] = new RangeError(e.message); break\n      case 'EvalError': args[0] = new EvalError(e.message); break\n      case 'ReferenceError': args[0] = new ReferenceError(e.message); break\n      case 'SyntaxError': args[0] = new SyntaxError(e.message); break\n      case 'URIError': args[0] = new URIError(e.message); break\n      default: args[0] = new Error(e.message)\n    }\n    args[0].type = e.type\n    args[0].stack = e.stack\n\n    // Copy any custom properties to pass it on.\n    Object.keys(e).forEach(function(key) {\n      args[0][key] = e[key];\n    });\n  }\n\n  process.nextTick(function () {\n    call.callback.apply(null, args)\n  })\n\n  ;delete child.calls[idx]\n  child.activeCalls--\n  this.activeCalls--\n\n  if (child.calls.length >= this.options.maxCallsPerWorker\n      && !Object.keys(child.calls).length) {\n    // this child has finished its run, kill it\n    this.stopChild(childId)\n  }\n\n  // allow any outstanding calls to be processed\n  this.processQueue()\n}\n\n\nFarm.prototype.childTimeout = function (childId) {\n  let child = this.children[childId]\n    , i\n\n  if (!child)\n    return\n\n  for (i in child.calls) {\n    this.receive({\n        idx   : i\n      , child : childId\n      , args  : [ new TimeoutError('worker call timed out!') ]\n    })\n  }\n  this.stopChild(childId)\n}\n\n\n// send a call to a worker, identified by id\nFarm.prototype.send = function (childId, call) {\n  let child = this.children[childId]\n    , idx   = child.calls.length\n\n  child.calls.push(call)\n  child.activeCalls++\n  this.activeCalls++\n\n  child.send({\n      owner  : 'farm'\n    , idx    : idx\n    , child  : childId\n    , method : call.method\n    , args   : call.args\n  })\n\n  if (this.options.maxCallTime !== Infinity) {\n    call.timer =\n      setTimeout(this.childTimeout.bind(this, childId), this.options.maxCallTime)\n  }\n}\n\n\n// a list of active worker ids, in order, but the starting offset is\n// shifted each time this method is called, so we work our way through\n// all workers when handing out jobs\nFarm.prototype.childKeys = function () {\n  let cka = Object.keys(this.children)\n    , cks\n\n  if (this.searchStart >= cka.length - 1)\n    this.searchStart = 0\n  else\n    this.searchStart++\n\n  cks = cka.splice(0, this.searchStart)\n\n  return cka.concat(cks)\n}\n\n\n// Calls are added to a queue, this processes the queue and is called\n// whenever there might be a chance to send more calls to the workers.\n// The various options all impact on when we're able to send calls,\n// they may need to be kept in a queue until a worker is ready.\nFarm.prototype.processQueue = function () {\n  let cka, i = 0, childId\n\n  if (!this.callQueue.length)\n    return this.ending && this.end()\n\n  if (this.activeChildren < this.options.maxConcurrentWorkers)\n    this.startChild()\n\n  for (cka = this.childKeys(); i < cka.length; i++) {\n    childId = +cka[i]\n    if (this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n        && this.children[childId].calls.length < this.options.maxCallsPerWorker) {\n\n      this.send(childId, this.callQueue.shift())\n      if (!this.callQueue.length)\n        return this.ending && this.end()\n    } /*else {\n      console.log(\n        , this.children[childId].activeCalls < this.options.maxConcurrentCallsPerWorker\n        , this.children[childId].calls.length < this.options.maxCallsPerWorker\n        , this.children[childId].calls.length , this.options.maxCallsPerWorker)\n    }*/\n  }\n\n  if (this.ending)\n    this.end()\n}\n\n\n// add a new call to the call queue, then trigger a process of the queue\nFarm.prototype.addCall = function (call) {\n  if (this.ending)\n    return this.end() // don't add anything new to the queue\n  this.callQueue.push(call)\n  this.processQueue()\n}\n\n\n// kills child workers when they're all done\nFarm.prototype.end = function (callback) {\n  let complete = true\n  if (this.ending === false)\n    return\n  if (callback)\n    this.ending = callback\n  else if (this.ending == null)\n    this.ending = true\n  Object.keys(this.children).forEach(function (child) {\n    if (!this.children[child])\n      return\n    if (!this.children[child].activeCalls)\n      this.stopChild(child)\n    else\n      complete = false\n  }.bind(this))\n\n  if (complete && typeof this.ending == 'function') {\n    process.nextTick(function () {\n      this.ending()\n      this.ending = false\n    }.bind(this))\n  }\n}\n\n\nmodule.exports              = Farm\nmodule.exports.TimeoutError = TimeoutError\n"]},"metadata":{},"sourceType":"script"}