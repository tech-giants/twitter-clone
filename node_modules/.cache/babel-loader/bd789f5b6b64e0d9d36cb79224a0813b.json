{"ast":null,"code":"\"use strict\";\n/**\n * intersect creates Set containing the intersection of elements between all sets\n * @param {Set[]} sets an array of sets being checked for shared elements\n * @returns {Set<TODO>} returns a new Set containing the intersecting items\n */\n\nconst intersect = sets => {\n  if (sets.length === 0) return new Set();\n  if (sets.length === 1) return new Set(sets[0]);\n  let minSize = Infinity;\n  let minIndex = -1;\n\n  for (let i = 0; i < sets.length; i++) {\n    const size = sets[i].size;\n\n    if (size < minSize) {\n      minIndex = i;\n      minSize = size;\n    }\n  }\n\n  const current = new Set(sets[minIndex]);\n\n  for (let i = 0; i < sets.length; i++) {\n    if (i === minIndex) continue;\n    const set = sets[i];\n\n    for (const item of current) {\n      if (!set.has(item)) {\n        current.delete(item);\n      }\n    }\n  }\n\n  return current;\n};\n/**\n * Checks if a set is the subset of another set\n * @param {Set<TODO>} bigSet a Set which contains the original elements to compare against\n * @param {Set<TODO>} smallSet the set whos elements might be contained inside of bigSet\n * @returns {boolean} returns true if smallSet contains all elements inside of the bigSet\n */\n\n\nconst isSubset = (bigSet, smallSet) => {\n  if (bigSet.size < smallSet.size) return false;\n\n  for (const item of smallSet) {\n    if (!bigSet.has(item)) return false;\n  }\n\n  return true;\n};\n\nexports.intersect = intersect;\nexports.isSubset = isSubset;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/util/SetHelpers.js"],"names":["intersect","sets","length","Set","minSize","Infinity","minIndex","i","size","current","set","item","has","delete","isSubset","bigSet","smallSet","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMA,SAAS,GAAGC,IAAI,IAAI;AACzB,MAAIA,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB,OAAO,IAAIC,GAAJ,EAAP;AACvB,MAAIF,IAAI,CAACC,MAAL,KAAgB,CAApB,EAAuB,OAAO,IAAIC,GAAJ,CAAQF,IAAI,CAAC,CAAD,CAAZ,CAAP;AACvB,MAAIG,OAAO,GAAGC,QAAd;AACA,MAAIC,QAAQ,GAAG,CAAC,CAAhB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACC,MAAzB,EAAiCK,CAAC,EAAlC,EAAsC;AACrC,UAAMC,IAAI,GAAGP,IAAI,CAACM,CAAD,CAAJ,CAAQC,IAArB;;AACA,QAAIA,IAAI,GAAGJ,OAAX,EAAoB;AACnBE,MAAAA,QAAQ,GAAGC,CAAX;AACAH,MAAAA,OAAO,GAAGI,IAAV;AACA;AACD;;AACD,QAAMC,OAAO,GAAG,IAAIN,GAAJ,CAAQF,IAAI,CAACK,QAAD,CAAZ,CAAhB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACC,MAAzB,EAAiCK,CAAC,EAAlC,EAAsC;AACrC,QAAIA,CAAC,KAAKD,QAAV,EAAoB;AACpB,UAAMI,GAAG,GAAGT,IAAI,CAACM,CAAD,CAAhB;;AACA,SAAK,MAAMI,IAAX,IAAmBF,OAAnB,EAA4B;AAC3B,UAAI,CAACC,GAAG,CAACE,GAAJ,CAAQD,IAAR,CAAL,EAAoB;AACnBF,QAAAA,OAAO,CAACI,MAAR,CAAeF,IAAf;AACA;AACD;AACD;;AACD,SAAOF,OAAP;AACA,CAvBD;AAyBA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMK,QAAQ,GAAG,CAACC,MAAD,EAASC,QAAT,KAAsB;AACtC,MAAID,MAAM,CAACP,IAAP,GAAcQ,QAAQ,CAACR,IAA3B,EAAiC,OAAO,KAAP;;AACjC,OAAK,MAAMG,IAAX,IAAmBK,QAAnB,EAA6B;AAC5B,QAAI,CAACD,MAAM,CAACH,GAAP,CAAWD,IAAX,CAAL,EAAuB,OAAO,KAAP;AACvB;;AACD,SAAO,IAAP;AACA,CAND;;AAQAM,OAAO,CAACjB,SAAR,GAAoBA,SAApB;AACAiB,OAAO,CAACH,QAAR,GAAmBA,QAAnB","sourcesContent":["\"use strict\";\n\n/**\n * intersect creates Set containing the intersection of elements between all sets\n * @param {Set[]} sets an array of sets being checked for shared elements\n * @returns {Set<TODO>} returns a new Set containing the intersecting items\n */\nconst intersect = sets => {\n\tif (sets.length === 0) return new Set();\n\tif (sets.length === 1) return new Set(sets[0]);\n\tlet minSize = Infinity;\n\tlet minIndex = -1;\n\tfor (let i = 0; i < sets.length; i++) {\n\t\tconst size = sets[i].size;\n\t\tif (size < minSize) {\n\t\t\tminIndex = i;\n\t\t\tminSize = size;\n\t\t}\n\t}\n\tconst current = new Set(sets[minIndex]);\n\tfor (let i = 0; i < sets.length; i++) {\n\t\tif (i === minIndex) continue;\n\t\tconst set = sets[i];\n\t\tfor (const item of current) {\n\t\t\tif (!set.has(item)) {\n\t\t\t\tcurrent.delete(item);\n\t\t\t}\n\t\t}\n\t}\n\treturn current;\n};\n\n/**\n * Checks if a set is the subset of another set\n * @param {Set<TODO>} bigSet a Set which contains the original elements to compare against\n * @param {Set<TODO>} smallSet the set whos elements might be contained inside of bigSet\n * @returns {boolean} returns true if smallSet contains all elements inside of the bigSet\n */\nconst isSubset = (bigSet, smallSet) => {\n\tif (bigSet.size < smallSet.size) return false;\n\tfor (const item of smallSet) {\n\t\tif (!bigSet.has(item)) return false;\n\t}\n\treturn true;\n};\n\nexports.intersect = intersect;\nexports.isSubset = isSubset;\n"]},"metadata":{},"sourceType":"script"}