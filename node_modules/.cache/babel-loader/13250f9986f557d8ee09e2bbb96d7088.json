{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function (sourceNode, sourceMapConsumer, sourceFile, removeGeneratedCodeForSourceFile) {\n  // The following notations are used to name stuff:\n  // Left <------------> Middle <-------------------> Right\n  // Input arguments:\n  //        sourceNode                                       - Code mapping from Left to Middle\n  //                   sourceFile                            - Name of a Middle file\n  //                              sourceMapConsumer          - Code mapping from Middle to Right\n  // Variables:\n  //           l2m                      m2r\n  // Left <-----------------------------------------> Right\n  // Variables:\n  //                       l2r\n  var l2rResult = new SourceNode();\n  var l2rOutput = [];\n  var middleSourceContents = {};\n  var m2rMappingsByLine = {};\n  var rightSourceContentsSet = {};\n  var rightSourceContentsLines = {}; // Store all mappings by generated line\n\n  sourceMapConsumer.eachMapping(function (mapping) {\n    (m2rMappingsByLine[mapping.generatedLine] = m2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n  }, null, SourceMapConsumer.GENERATED_ORDER); // Store all source contents\n\n  sourceNode.walkSourceContents(function (source, content) {\n    middleSourceContents[\"$\" + source] = content;\n  });\n  var middleSource = middleSourceContents[\"$\" + sourceFile];\n  var middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined; // Walk all left to middle mappings\n\n  sourceNode.walk(function (chunk, middleMapping) {\n    var source; // Find a mapping from middle to right\n\n    if (middleMapping.source === sourceFile && middleMapping.line && m2rMappingsByLine[middleMapping.line]) {\n      var m2rBestFit;\n      var m2rMappings = m2rMappingsByLine[middleMapping.line]; // Note: if this becomes a performance problem, use binary search\n\n      for (var i = 0; i < m2rMappings.length; i++) {\n        if (m2rMappings[i].generatedColumn <= middleMapping.column) {\n          m2rBestFit = m2rMappings[i];\n        }\n      }\n\n      if (m2rBestFit) {\n        var allowMiddleName = false;\n        var middleLine;\n        var rightSourceContent;\n        var rightSourceContentLines;\n        var rightSource = m2rBestFit.source; // Check if we have middle and right source for this mapping\n        // Then we could have an \"identify\" mapping\n\n        if (middleSourceLines && rightSource && (middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) && ((rightSourceContentLines = rightSourceContentsLines[rightSource]) || (rightSourceContent = sourceMapConsumer.sourceContentFor(rightSource, true)))) {\n          if (!rightSourceContentLines) {\n            rightSourceContentLines = rightSourceContentsLines[rightSource] = rightSourceContent.split(\"\\n\");\n          }\n\n          var rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\n          if (rightLine) {\n            var offset = middleMapping.column - m2rBestFit.generatedColumn;\n\n            if (offset > 0) {\n              var middlePart = middleLine.slice(m2rBestFit.generatedColumn, middleMapping.column);\n              var rightPart = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + offset);\n\n              if (middlePart === rightPart) {\n                // When original and generated code is equal we assume we have an \"identity\" mapping\n                // In this case we can offset the original position\n                m2rBestFit = Object.assign({}, m2rBestFit, {\n                  originalColumn: m2rBestFit.originalColumn + offset,\n                  generatedColumn: middleMapping.column\n                });\n              }\n            }\n\n            if (!m2rBestFit.name && middleMapping.name) {\n              allowMiddleName = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + middleMapping.name.length) === middleMapping.name;\n            }\n          }\n        } // Construct a left to right node from the found middle to right mapping\n\n\n        source = m2rBestFit.source;\n        l2rOutput.push(new SourceNode(m2rBestFit.originalLine, m2rBestFit.originalColumn, source, chunk, allowMiddleName ? middleMapping.name : m2rBestFit.name)); // Set the source contents once\n\n        if (!(\"$\" + source in rightSourceContentsSet)) {\n          rightSourceContentsSet[\"$\" + source] = true;\n          var sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n\n          if (sourceContent) {\n            l2rResult.setSourceContent(source, sourceContent);\n          }\n        }\n\n        return;\n      }\n    }\n\n    if (removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile || !middleMapping.source) {\n      // Construct a left to middle node with only generated code\n      // Because user do not want mappings to middle sources\n      // Or this chunk has no mapping\n      l2rOutput.push(chunk);\n      return;\n    } // Construct a left to middle node\n\n\n    source = middleMapping.source;\n    l2rOutput.push(new SourceNode(middleMapping.line, middleMapping.column, source, chunk, middleMapping.name));\n\n    if (\"$\" + source in middleSourceContents) {\n      if (!(\"$\" + source in rightSourceContentsSet)) {\n        l2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n        delete middleSourceContents[\"$\" + source];\n      }\n    }\n  }); // Put output into the resulting SourceNode\n\n  l2rResult.add(l2rOutput);\n  return l2rResult;\n};\n\nmodule.exports = applySourceMap;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack-sources/lib/applySourceMap.js"],"names":["SourceNode","require","SourceMapConsumer","applySourceMap","sourceNode","sourceMapConsumer","sourceFile","removeGeneratedCodeForSourceFile","l2rResult","l2rOutput","middleSourceContents","m2rMappingsByLine","rightSourceContentsSet","rightSourceContentsLines","eachMapping","mapping","generatedLine","push","GENERATED_ORDER","walkSourceContents","source","content","middleSource","middleSourceLines","split","undefined","walk","chunk","middleMapping","line","m2rBestFit","m2rMappings","i","length","generatedColumn","column","allowMiddleName","middleLine","rightSourceContent","rightSourceContentLines","rightSource","sourceContentFor","rightLine","originalLine","offset","middlePart","slice","rightPart","originalColumn","Object","assign","name","sourceContent","setSourceContent","add","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function(\n\tsourceNode,\n\tsourceMapConsumer,\n\tsourceFile,\n\tremoveGeneratedCodeForSourceFile\n) {\n\t// The following notations are used to name stuff:\n\t// Left <------------> Middle <-------------------> Right\n\t// Input arguments:\n\t//        sourceNode                                       - Code mapping from Left to Middle\n\t//                   sourceFile                            - Name of a Middle file\n\t//                              sourceMapConsumer          - Code mapping from Middle to Right\n\t// Variables:\n\t//           l2m                      m2r\n\t// Left <-----------------------------------------> Right\n\t// Variables:\n\t//                       l2r\n\n\tvar l2rResult = new SourceNode();\n\tvar l2rOutput = [];\n\n\tvar middleSourceContents = {};\n\n\tvar m2rMappingsByLine = {};\n\n\tvar rightSourceContentsSet = {};\n\tvar rightSourceContentsLines = {};\n\n\t// Store all mappings by generated line\n\tsourceMapConsumer.eachMapping(\n\t\tfunction(mapping) {\n\t\t\t(m2rMappingsByLine[mapping.generatedLine] =\n\t\t\t\tm2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n\t\t},\n\t\tnull,\n\t\tSourceMapConsumer.GENERATED_ORDER\n\t);\n\n\t// Store all source contents\n\tsourceNode.walkSourceContents(function(source, content) {\n\t\tmiddleSourceContents[\"$\" + source] = content;\n\t});\n\n\tvar middleSource = middleSourceContents[\"$\" + sourceFile];\n\tvar middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined;\n\n\t// Walk all left to middle mappings\n\tsourceNode.walk(function(chunk, middleMapping) {\n\t\tvar source;\n\n\t\t// Find a mapping from middle to right\n\t\tif(\n\t\t\tmiddleMapping.source === sourceFile &&\n\t\t\tmiddleMapping.line &&\n\t\t\tm2rMappingsByLine[middleMapping.line]\n\t\t) {\n\t\t\tvar m2rBestFit;\n\t\t\tvar m2rMappings = m2rMappingsByLine[middleMapping.line];\n\t\t\t// Note: if this becomes a performance problem, use binary search\n\t\t\tfor(var i = 0; i < m2rMappings.length; i++) {\n\t\t\t\tif(m2rMappings[i].generatedColumn <= middleMapping.column) {\n\t\t\t\t\tm2rBestFit = m2rMappings[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(m2rBestFit) {\n\t\t\t\tvar allowMiddleName = false;\n\t\t\t\tvar middleLine;\n\t\t\t\tvar rightSourceContent;\n\t\t\t\tvar rightSourceContentLines;\n\t\t\t\tvar rightSource = m2rBestFit.source;\n\t\t\t\t// Check if we have middle and right source for this mapping\n\t\t\t\t// Then we could have an \"identify\" mapping\n\t\t\t\tif(\n\t\t\t\t\tmiddleSourceLines &&\n\t\t\t\t\trightSource &&\n\t\t\t\t\t(middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) &&\n\t\t\t\t\t((rightSourceContentLines = rightSourceContentsLines[rightSource]) ||\n\t\t\t\t\t\t(rightSourceContent = sourceMapConsumer.sourceContentFor(\n\t\t\t\t\t\t\trightSource,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)))\n\t\t\t\t) {\n\t\t\t\t\tif(!rightSourceContentLines) {\n\t\t\t\t\t\trightSourceContentLines = rightSourceContentsLines[\n\t\t\t\t\t\t\trightSource\n\t\t\t\t\t\t] = rightSourceContent.split(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tvar rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\t\t\t\t\tif(rightLine) {\n\t\t\t\t\t\tvar offset = middleMapping.column - m2rBestFit.generatedColumn;\n\t\t\t\t\t\tif(offset > 0) {\n\t\t\t\t\t\t\tvar middlePart = middleLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.generatedColumn,\n\t\t\t\t\t\t\t\tmiddleMapping.column\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvar rightPart = rightLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + offset\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif(middlePart === rightPart) {\n\t\t\t\t\t\t\t\t// When original and generated code is equal we assume we have an \"identity\" mapping\n\t\t\t\t\t\t\t\t// In this case we can offset the original position\n\t\t\t\t\t\t\t\tm2rBestFit = Object.assign({}, m2rBestFit, {\n\t\t\t\t\t\t\t\t\toriginalColumn: m2rBestFit.originalColumn + offset,\n\t\t\t\t\t\t\t\t\tgeneratedColumn: middleMapping.column\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!m2rBestFit.name && middleMapping.name) {\n\t\t\t\t\t\t\tallowMiddleName =\n\t\t\t\t\t\t\t\trightLine.slice(\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + middleMapping.name.length\n\t\t\t\t\t\t\t\t) === middleMapping.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Construct a left to right node from the found middle to right mapping\n\t\t\t\tsource = m2rBestFit.source;\n\t\t\t\tl2rOutput.push(\n\t\t\t\t\tnew SourceNode(\n\t\t\t\t\t\tm2rBestFit.originalLine,\n\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tallowMiddleName ? middleMapping.name : m2rBestFit.name\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t// Set the source contents once\n\t\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\t\trightSourceContentsSet[\"$\" + source] = true;\n\t\t\t\t\tvar sourceContent = sourceMapConsumer.sourceContentFor(source, true);\n\t\t\t\t\tif(sourceContent) {\n\t\t\t\t\t\tl2rResult.setSourceContent(source, sourceContent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif((removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile) || !middleMapping.source) {\n\t\t\t// Construct a left to middle node with only generated code\n\t\t\t// Because user do not want mappings to middle sources\n\t\t\t// Or this chunk has no mapping\n\t\t\tl2rOutput.push(chunk);\n\t\t\treturn;\n\t\t}\n\n\t\t// Construct a left to middle node\n\t\tsource = middleMapping.source;\n\t\tl2rOutput.push(\n\t\t\tnew SourceNode(\n\t\t\t\tmiddleMapping.line,\n\t\t\t\tmiddleMapping.column,\n\t\t\t\tsource,\n\t\t\t\tchunk,\n\t\t\t\tmiddleMapping.name\n\t\t\t)\n\t\t);\n\t\tif(\"$\" + source in middleSourceContents) {\n\t\t\tif(!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\tl2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n\t\t\t\tdelete middleSourceContents[\"$\" + source];\n\t\t\t}\n\t\t}\n\t});\n\n\t// Put output into the resulting SourceNode\n\tl2rResult.add(l2rOutput);\n\treturn l2rResult;\n};\n\nmodule.exports = applySourceMap;\n"]},"metadata":{},"sourceType":"script"}