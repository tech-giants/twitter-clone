{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst base64VLQ = require(\"./base64-vlq\");\n\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\n\nconst getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nconst LINE_MAPPING = \";AAAA\";\n\nclass SingleLineNode {\n  constructor(generatedCode, source, originalSource, line) {\n    this.generatedCode = generatedCode;\n    this.originalSource = originalSource;\n    this.source = source;\n    this.line = line || 1;\n    this._numberOfLines = getNumberOfLines(this.generatedCode);\n    this._endsWithNewLine = generatedCode[generatedCode.length - 1] === \"\\n\";\n  }\n\n  clone() {\n    return new SingleLineNode(this.generatedCode, this.source, this.originalSource, this.line);\n  }\n\n  getGeneratedCode() {\n    return this.generatedCode;\n  }\n\n  getMappings(mappingsContext) {\n    if (!this.generatedCode) return \"\";\n    const lines = this._numberOfLines;\n    const sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);\n    let mappings = \"A\"; // generated column 0\n\n    if (mappingsContext.unfinishedGeneratedLine) mappings = \",\" + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);\n    mappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index\n\n    mappings += base64VLQ.encode(this.line - mappingsContext.currentOriginalLine); // original line index\n\n    mappings += \"A\"; // original column 0\n\n    mappingsContext.currentSource = sourceIdx;\n    mappingsContext.currentOriginalLine = this.line;\n    const unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode);\n    mappings += Array(lines).join(LINE_MAPPING);\n\n    if (unfinishedGeneratedLine === 0) {\n      mappings += \";\";\n    } else {\n      if (lines !== 0) mappings += LINE_MAPPING;\n    }\n\n    return mappings;\n  }\n\n  getNormalizedNodes() {\n    return [this];\n  }\n\n  mapGeneratedCode(fn) {\n    const generatedCode = fn(this.generatedCode);\n    return new SingleLineNode(generatedCode, this.source, this.originalSource, this.line);\n  }\n\n  merge(otherNode) {\n    if (otherNode instanceof SingleLineNode) {\n      return this.mergeSingleLineNode(otherNode);\n    }\n\n    return false;\n  }\n\n  mergeSingleLineNode(otherNode) {\n    if (this.source === otherNode.source && this.originalSource === otherNode.originalSource) {\n      if (this.line === otherNode.line) {\n        this.generatedCode += otherNode.generatedCode;\n        this._numberOfLines += otherNode._numberOfLines;\n        this._endsWithNewLine = otherNode._endsWithNewLine;\n        return this;\n      } else if (this.line + 1 === otherNode.line && this._endsWithNewLine && this._numberOfLines === 1 && otherNode._numberOfLines <= 1) {\n        return new SourceNode(this.generatedCode + otherNode.generatedCode, this.source, this.originalSource, this.line);\n      }\n    }\n\n    return false;\n  }\n\n}\n\nmodule.exports = SingleLineNode;\n\nconst SourceNode = require(\"./SourceNode\"); // circular dependency","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/source-list-map/lib/SingleLineNode.js"],"names":["base64VLQ","require","getNumberOfLines","getUnfinishedLine","LINE_MAPPING","SingleLineNode","constructor","generatedCode","source","originalSource","line","_numberOfLines","_endsWithNewLine","length","clone","getGeneratedCode","getMappings","mappingsContext","lines","sourceIdx","ensureSource","mappings","unfinishedGeneratedLine","encode","currentSource","currentOriginalLine","Array","join","getNormalizedNodes","mapGeneratedCode","fn","merge","otherNode","mergeSingleLineNode","SourceNode","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\nconst getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nconst LINE_MAPPING = \";AAAA\";\n\nclass SingleLineNode {\n\n\tconstructor(generatedCode, source, originalSource, line) {\n\t\tthis.generatedCode = generatedCode;\n\t\tthis.originalSource = originalSource;\n\t\tthis.source = source;\n\t\tthis.line = line || 1;\n\t\tthis._numberOfLines = getNumberOfLines(this.generatedCode);\n\t\tthis._endsWithNewLine = generatedCode[generatedCode.length - 1] === \"\\n\";\n\t}\n\n\tclone() {\n\t\treturn new SingleLineNode(this.generatedCode, this.source, this.originalSource, this.line);\n\t}\n\n\tgetGeneratedCode() {\n\t\treturn this.generatedCode;\n\t}\n\n\tgetMappings(mappingsContext) {\n\t\tif(!this.generatedCode)\n\t\t\treturn \"\";\n\t\tconst lines = this._numberOfLines;\n\t\tconst sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);\n\t\tlet mappings = \"A\"; // generated column 0\n\t\tif(mappingsContext.unfinishedGeneratedLine)\n\t\t\tmappings = \",\" + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);\n\t\tmappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index\n\t\tmappings += base64VLQ.encode(this.line - mappingsContext.currentOriginalLine); // original line index\n\t\tmappings += \"A\"; // original column 0\n\t\tmappingsContext.currentSource = sourceIdx;\n\t\tmappingsContext.currentOriginalLine = this.line;\n\t\tconst unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode)\n\t\tmappings += Array(lines).join(LINE_MAPPING);\n\t\tif(unfinishedGeneratedLine === 0) {\n\t\t\tmappings += \";\";\n\t\t} else {\n\t\t\tif(lines !== 0)\n\t\t\t\tmappings += LINE_MAPPING;\n\t\t}\n\t\treturn mappings;\n\t}\n\n\tgetNormalizedNodes() {\n\t\treturn [this];\n\t}\n\n\tmapGeneratedCode(fn) {\n\t\tconst generatedCode = fn(this.generatedCode);\n\t\treturn new SingleLineNode(generatedCode, this.source, this.originalSource, this.line);\n\t}\n\n\tmerge(otherNode) {\n\t\tif(otherNode instanceof SingleLineNode) {\n\t\t\treturn this.mergeSingleLineNode(otherNode);\n\t\t}\n\t\treturn false;\n\t}\n\n\tmergeSingleLineNode(otherNode) {\n\t\tif(this.source === otherNode.source &&\n\t\t\tthis.originalSource === otherNode.originalSource) {\n\t\t\tif(this.line === otherNode.line) {\n\t\t\t\tthis.generatedCode += otherNode.generatedCode;\n\t\t\t\tthis._numberOfLines += otherNode._numberOfLines;\n\t\t\t\tthis._endsWithNewLine = otherNode._endsWithNewLine;\n\t\t\t\treturn this;\n\t\t\t} else if(this.line + 1 === otherNode.line && \n\t\t\t\tthis._endsWithNewLine &&\n\t\t\t\tthis._numberOfLines === 1 && \n\t\t\t\totherNode._numberOfLines <= 1) {\n\t\t\t\treturn new SourceNode(this.generatedCode + otherNode.generatedCode, this.source, this.originalSource, this.line);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}\n\nmodule.exports = SingleLineNode;\n\nconst SourceNode = require(\"./SourceNode\"); // circular dependency\n"]},"metadata":{},"sourceType":"script"}