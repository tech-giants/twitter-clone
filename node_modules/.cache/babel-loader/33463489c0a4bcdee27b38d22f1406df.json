{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n/* istanbul ignore next */\n\n\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown';\n/* istanbul ignore next */\n\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync';\n/* istanbul ignore next */\n\nconst needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\\./) && !process.version.match(/v10\\.[6-9]/);\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er;\n  }\n};\n/* istanbul ignore next */\n\n\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er;\n  }\n};\n/* istanbul ignore next */\n\n\nconst handleEISDIR = needEISDIRHandled ? (path, uid, gid, cb) => er => {\n  // Node prior to v10 had a very questionable implementation of\n  // fs.lchown, which would always try to call fs.open on a directory\n  // Fall back to fs.chown in those cases.\n  if (!er || er.code !== 'EISDIR') cb(er);else fs.chown(path, uid, gid, cb);\n} : (_, __, ___, cb) => cb;\n/* istanbul ignore next */\n\nconst handleEISDirSync = needEISDIRHandled ? (path, uid, gid) => {\n  try {\n    return lchownSync(path, uid, gid);\n  } catch (er) {\n    if (er.code !== 'EISDIR') throw er;\n    chownSync(path, uid, gid);\n  }\n} : (path, uid, gid) => lchownSync(path, uid, gid); // fs.readdir could only accept an options object as of node v6\n\nconst nodeVersion = process.version;\n\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb);\n\nlet readdirSync = (path, options) => fs.readdirSync(path, options);\n/* istanbul ignore next */\n\n\nif (/^v4\\./.test(nodeVersion)) readdir = (path, options, cb) => fs.readdir(path, cb);\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null);\n  }));\n};\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string') return fs.lstat(path.resolve(p, child), (er, stats) => {\n    // Skip ENOENT error\n    if (er) return cb(er.code !== 'ENOENT' ? er : null);\n    stats.name = child;\n    chownrKid(p, stats, uid, gid, cb);\n  });\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er) return cb(er);\n      const cpath = path.resolve(p, child.name);\n      chown(cpath, uid, gid, cb);\n    });\n  } else {\n    const cpath = path.resolve(p, child.name);\n    chown(cpath, uid, gid, cb);\n  }\n};\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, {\n    withFileTypes: true\n  }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT') return cb();else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP') return cb(er);\n    }\n\n    if (er || !children.length) return chown(p, uid, gid, cb);\n    let len = children.length;\n    let errState = null;\n\n    const then = er => {\n      if (errState) return;\n      if (er) return cb(errState = er);\n      if (--len === 0) return chown(p, uid, gid, cb);\n    };\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then));\n  });\n};\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child));\n      stats.name = child;\n      child = stats;\n    } catch (er) {\n      if (er.code === 'ENOENT') return;else throw er;\n    }\n  }\n\n  if (child.isDirectory()) chownrSync(path.resolve(p, child.name), uid, gid);\n  handleEISDirSync(path.resolve(p, child.name), uid, gid);\n};\n\nconst chownrSync = (p, uid, gid) => {\n  let children;\n\n  try {\n    children = readdirSync(p, {\n      withFileTypes: true\n    });\n  } catch (er) {\n    if (er.code === 'ENOENT') return;else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP') return handleEISDirSync(p, uid, gid);else throw er;\n  }\n\n  if (children && children.length) children.forEach(child => chownrKidSync(p, child, uid, gid));\n  return handleEISDirSync(p, uid, gid);\n};\n\nmodule.exports = chownr;\nchownr.sync = chownrSync;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/node_modules/chownr/chownr.js"],"names":["fs","require","path","LCHOWN","lchown","LCHOWNSYNC","lchownSync","needEISDIRHandled","process","version","match","uid","gid","er","code","chownSync","handleEISDIR","cb","chown","_","__","___","handleEISDirSync","nodeVersion","readdir","options","readdirSync","test","cpath","chownrKid","p","child","lstat","resolve","stats","name","isDirectory","chownr","withFileTypes","children","length","len","errState","then","forEach","chownrKidSync","lstatSync","chownrSync","module","exports","sync"],"mappings":"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","sourcesContent":["'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n"]},"metadata":{},"sourceType":"script"}