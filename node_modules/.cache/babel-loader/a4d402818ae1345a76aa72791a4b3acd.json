{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst base64VLQ = require(\"./base64-vlq\");\n\nconst SourceNode = require(\"./SourceNode\");\n\nconst CodeNode = require(\"./CodeNode\");\n\nconst SourceListMap = require(\"./SourceListMap\");\n\nmodule.exports = function fromStringWithSourceMap(code, map) {\n  const sources = map.sources;\n  const sourcesContent = map.sourcesContent;\n  const mappings = map.mappings.split(\";\");\n  const lines = code.split(\"\\n\");\n  const nodes = [];\n  let currentNode = null;\n  let currentLine = 1;\n  let currentSourceIdx = 0;\n  let currentSourceNodeLine;\n\n  function addCode(generatedCode) {\n    if (currentNode && currentNode instanceof CodeNode) {\n      currentNode.addGeneratedCode(generatedCode);\n    } else if (currentNode && currentNode instanceof SourceNode && !generatedCode.trim()) {\n      currentNode.addGeneratedCode(generatedCode);\n      currentSourceNodeLine++;\n    } else {\n      currentNode = new CodeNode(generatedCode);\n      nodes.push(currentNode);\n    }\n  }\n\n  function addSource(generatedCode, source, originalSource, linePosition) {\n    if (currentNode && currentNode instanceof SourceNode && currentNode.source === source && currentSourceNodeLine === linePosition) {\n      currentNode.addGeneratedCode(generatedCode);\n      currentSourceNodeLine++;\n    } else {\n      currentNode = new SourceNode(generatedCode, source, originalSource, linePosition);\n      currentSourceNodeLine = linePosition + 1;\n      nodes.push(currentNode);\n    }\n  }\n\n  mappings.forEach(function (mapping, idx) {\n    let line = lines[idx];\n    if (typeof line === 'undefined') return;\n    if (idx !== lines.length - 1) line += \"\\n\";\n    if (!mapping) return addCode(line);\n    mapping = {\n      value: 0,\n      rest: mapping\n    };\n    let lineAdded = false;\n\n    while (mapping.rest) lineAdded = processMapping(mapping, line, lineAdded) || lineAdded;\n\n    if (!lineAdded) addCode(line);\n  });\n\n  if (mappings.length < lines.length) {\n    let idx = mappings.length;\n\n    while (!lines[idx].trim() && idx < lines.length - 1) {\n      addCode(lines[idx] + \"\\n\");\n      idx++;\n    }\n\n    addCode(lines.slice(idx).join(\"\\n\"));\n  }\n\n  return new SourceListMap(nodes);\n\n  function processMapping(mapping, line, ignore) {\n    if (mapping.rest && mapping.rest[0] !== \",\") {\n      base64VLQ.decode(mapping.rest, mapping);\n    }\n\n    if (!mapping.rest) return false;\n\n    if (mapping.rest[0] === \",\") {\n      mapping.rest = mapping.rest.substr(1);\n      return false;\n    }\n\n    base64VLQ.decode(mapping.rest, mapping);\n    const sourceIdx = mapping.value + currentSourceIdx;\n    currentSourceIdx = sourceIdx;\n    let linePosition;\n\n    if (mapping.rest && mapping.rest[0] !== \",\") {\n      base64VLQ.decode(mapping.rest, mapping);\n      linePosition = mapping.value + currentLine;\n      currentLine = linePosition;\n    } else {\n      linePosition = currentLine;\n    }\n\n    if (mapping.rest) {\n      const next = mapping.rest.indexOf(\",\");\n      mapping.rest = next === -1 ? \"\" : mapping.rest.substr(next);\n    }\n\n    if (!ignore) {\n      addSource(line, sources ? sources[sourceIdx] : null, sourcesContent ? sourcesContent[sourceIdx] : null, linePosition);\n      return true;\n    }\n  }\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/source-list-map/lib/fromStringWithSourceMap.js"],"names":["base64VLQ","require","SourceNode","CodeNode","SourceListMap","module","exports","fromStringWithSourceMap","code","map","sources","sourcesContent","mappings","split","lines","nodes","currentNode","currentLine","currentSourceIdx","currentSourceNodeLine","addCode","generatedCode","addGeneratedCode","trim","push","addSource","source","originalSource","linePosition","forEach","mapping","idx","line","length","value","rest","lineAdded","processMapping","slice","join","ignore","decode","substr","sourceIdx","next","indexOf"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst SourceNode = require(\"./SourceNode\");\nconst CodeNode = require(\"./CodeNode\");\nconst SourceListMap = require(\"./SourceListMap\");\n\nmodule.exports = function fromStringWithSourceMap(code, map) {\n\tconst sources = map.sources;\n\tconst sourcesContent = map.sourcesContent;\n\tconst mappings = map.mappings.split(\";\");\n\tconst lines = code.split(\"\\n\");\n\tconst nodes = [];\n\tlet currentNode = null;\n\tlet currentLine = 1;\n\tlet currentSourceIdx = 0;\n\tlet currentSourceNodeLine;\n\tfunction addCode(generatedCode) {\n\t\tif(currentNode && currentNode instanceof CodeNode) {\n\t\t\tcurrentNode.addGeneratedCode(generatedCode);\n\t\t} else if(currentNode && currentNode instanceof SourceNode && !generatedCode.trim()) {\n\t\t\tcurrentNode.addGeneratedCode(generatedCode);\n\t\t\tcurrentSourceNodeLine++;\n\t\t} else {\n\t\t\tcurrentNode = new CodeNode(generatedCode);\n\t\t\tnodes.push(currentNode);\n\t\t}\n\t}\n\tfunction addSource(generatedCode, source, originalSource, linePosition) {\n\t\tif(currentNode && currentNode instanceof SourceNode &&\n\t\t\tcurrentNode.source === source &&\n\t\t\tcurrentSourceNodeLine === linePosition\n\t\t) {\n\t\t\tcurrentNode.addGeneratedCode(generatedCode);\n\t\t\tcurrentSourceNodeLine++;\n\t\t} else {\n\t\t\tcurrentNode = new SourceNode(generatedCode, source, originalSource, linePosition);\n\t\t\tcurrentSourceNodeLine = linePosition + 1;\n\t\t\tnodes.push(currentNode);\n\t\t}\n\t}\n\tmappings.forEach(function(mapping, idx) {\n\t\tlet line = lines[idx];\n\t\tif(typeof line === 'undefined') return;\n\t\tif(idx !== lines.length - 1) line += \"\\n\";\n\t\tif(!mapping)\n\t\t\treturn addCode(line);\n\t\tmapping = { value: 0, rest: mapping };\n\t\tlet lineAdded = false;\n\t\twhile(mapping.rest)\n\t\t\tlineAdded = processMapping(mapping, line, lineAdded) || lineAdded;\n\t\tif(!lineAdded)\n\t\t\taddCode(line);\n\t});\n\tif(mappings.length < lines.length) {\n\t\tlet idx = mappings.length;\n\t\twhile(!lines[idx].trim() && idx < lines.length-1) {\n\t\t\taddCode(lines[idx] + \"\\n\");\n\t\t\tidx++;\n\t\t}\n\t\taddCode(lines.slice(idx).join(\"\\n\"));\n\t}\n\treturn new SourceListMap(nodes);\n\tfunction processMapping(mapping, line, ignore) {\n\t\tif(mapping.rest && mapping.rest[0] !== \",\") {\n\t\t\tbase64VLQ.decode(mapping.rest, mapping);\n\t\t}\n\t\tif(!mapping.rest)\n\t\t\treturn false;\n\t\tif(mapping.rest[0] === \",\") {\n\t\t\tmapping.rest = mapping.rest.substr(1);\n\t\t\treturn false;\n\t\t}\n\n\t\tbase64VLQ.decode(mapping.rest, mapping);\n\t\tconst sourceIdx = mapping.value + currentSourceIdx;\n\t\tcurrentSourceIdx = sourceIdx;\n\n\t\tlet linePosition;\n\t\tif(mapping.rest && mapping.rest[0] !== \",\") {\n\t\t\tbase64VLQ.decode(mapping.rest, mapping);\n\t\t\tlinePosition = mapping.value + currentLine;\n\t\t\tcurrentLine = linePosition;\n\t\t} else {\n\t\t\tlinePosition = currentLine;\n\t\t}\n\n\t\tif(mapping.rest) {\n\t\t\tconst next = mapping.rest.indexOf(\",\");\n\t\t\tmapping.rest = next === -1 ? \"\" : mapping.rest.substr(next);\n\t\t}\n\n\t\tif(!ignore) {\n\t\t\taddSource(line, sources ? sources[sourceIdx] : null, sourcesContent ? sourcesContent[sourceIdx] : null, linePosition)\n\t\t\treturn true;\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}