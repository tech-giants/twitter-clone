{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst {\n  Tapable,\n  HookMap,\n  SyncHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\n\nconst {\n  cachedCleverMerge\n} = require(\"./util/cleverMerge\");\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\n\nconst EMTPY_RESOLVE_OPTIONS = {};\nmodule.exports = class ResolverFactory extends Tapable {\n  constructor() {\n    super();\n    this.hooks = {\n      resolveOptions: new HookMap(() => new SyncWaterfallHook([\"resolveOptions\"])),\n      resolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\"]))\n    };\n\n    this._pluginCompat.tap(\"ResolverFactory\", options => {\n      let match;\n      match = /^resolve-options (.+)$/.exec(options.name);\n\n      if (match) {\n        this.hooks.resolveOptions.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n\n      match = /^resolver (.+)$/.exec(options.name);\n\n      if (match) {\n        this.hooks.resolver.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n        return true;\n      }\n    });\n\n    this.cache2 = new Map();\n  }\n\n  get(type, resolveOptions) {\n    resolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;\n    const ident = `${type}|${JSON.stringify(resolveOptions)}`;\n    const resolver = this.cache2.get(ident);\n    if (resolver) return resolver;\n\n    const newResolver = this._create(type, resolveOptions);\n\n    this.cache2.set(ident, newResolver);\n    return newResolver;\n  }\n\n  _create(type, resolveOptions) {\n    const originalResolveOptions = Object.assign({}, resolveOptions);\n    resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n    const resolver = Factory.createResolver(resolveOptions);\n\n    if (!resolver) {\n      throw new Error(\"No resolver created\");\n    }\n    /** @type {Map<Object, Resolver>} */\n\n\n    const childCache = new Map();\n\n    resolver.withOptions = options => {\n      const cacheEntry = childCache.get(options);\n      if (cacheEntry !== undefined) return cacheEntry;\n      const mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n      const resolver = this.get(type, mergedOptions);\n      childCache.set(options, resolver);\n      return resolver;\n    };\n\n    this.hooks.resolver.for(type).call(resolver, resolveOptions);\n    return resolver;\n  }\n\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/ResolverFactory.js"],"names":["Tapable","HookMap","SyncHook","SyncWaterfallHook","require","Factory","ResolverFactory","cachedCleverMerge","EMTPY_RESOLVE_OPTIONS","module","exports","constructor","hooks","resolveOptions","resolver","_pluginCompat","tap","options","match","exec","name","for","fn","cache2","Map","get","type","ident","JSON","stringify","newResolver","_create","set","originalResolveOptions","Object","assign","call","createResolver","Error","childCache","withOptions","cacheEntry","undefined","mergedOptions"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AAAEA,EAAAA,OAAF;AAAWC,EAAAA,OAAX;AAAoBC,EAAAA,QAApB;AAA8BC,EAAAA;AAA9B,IAAoDC,OAAO,CAAC,SAAD,CAAjE;;AACA,MAAMC,OAAO,GAAGD,OAAO,CAAC,kBAAD,CAAP,CAA4BE,eAA5C;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAwBH,OAAO,CAAC,oBAAD,CAArC;AAEA;;;AAEA,MAAMI,qBAAqB,GAAG,EAA9B;AAEAC,MAAM,CAACC,OAAP,GAAiB,MAAMJ,eAAN,SAA8BN,OAA9B,CAAsC;AACtDW,EAAAA,WAAW,GAAG;AACb;AACA,SAAKC,KAAL,GAAa;AACZC,MAAAA,cAAc,EAAE,IAAIZ,OAAJ,CACf,MAAM,IAAIE,iBAAJ,CAAsB,CAAC,gBAAD,CAAtB,CADS,CADJ;AAIZW,MAAAA,QAAQ,EAAE,IAAIb,OAAJ,CAAY,MAAM,IAAIC,QAAJ,CAAa,CAAC,UAAD,EAAa,gBAAb,CAAb,CAAlB;AAJE,KAAb;;AAMA,SAAKa,aAAL,CAAmBC,GAAnB,CAAuB,iBAAvB,EAA0CC,OAAO,IAAI;AACpD,UAAIC,KAAJ;AACAA,MAAAA,KAAK,GAAG,yBAAyBC,IAAzB,CAA8BF,OAAO,CAACG,IAAtC,CAAR;;AACA,UAAIF,KAAJ,EAAW;AACV,aAAKN,KAAL,CAAWC,cAAX,CACEQ,GADF,CACMH,KAAK,CAAC,CAAD,CADX,EAEEF,GAFF,CAEMC,OAAO,CAACK,EAAR,CAAWF,IAAX,IAAmB,uBAFzB,EAEkDH,OAAO,CAACK,EAF1D;AAGA,eAAO,IAAP;AACA;;AACDJ,MAAAA,KAAK,GAAG,kBAAkBC,IAAlB,CAAuBF,OAAO,CAACG,IAA/B,CAAR;;AACA,UAAIF,KAAJ,EAAW;AACV,aAAKN,KAAL,CAAWE,QAAX,CACEO,GADF,CACMH,KAAK,CAAC,CAAD,CADX,EAEEF,GAFF,CAEMC,OAAO,CAACK,EAAR,CAAWF,IAAX,IAAmB,uBAFzB,EAEkDH,OAAO,CAACK,EAF1D;AAGA,eAAO,IAAP;AACA;AACD,KAhBD;;AAiBA,SAAKC,MAAL,GAAc,IAAIC,GAAJ,EAAd;AACA;;AAEDC,EAAAA,GAAG,CAACC,IAAD,EAAOb,cAAP,EAAuB;AACzBA,IAAAA,cAAc,GAAGA,cAAc,IAAIL,qBAAnC;AACA,UAAMmB,KAAK,GAAI,GAAED,IAAK,IAAGE,IAAI,CAACC,SAAL,CAAehB,cAAf,CAA+B,EAAxD;AACA,UAAMC,QAAQ,GAAG,KAAKS,MAAL,CAAYE,GAAZ,CAAgBE,KAAhB,CAAjB;AACA,QAAIb,QAAJ,EAAc,OAAOA,QAAP;;AACd,UAAMgB,WAAW,GAAG,KAAKC,OAAL,CAAaL,IAAb,EAAmBb,cAAnB,CAApB;;AACA,SAAKU,MAAL,CAAYS,GAAZ,CAAgBL,KAAhB,EAAuBG,WAAvB;AACA,WAAOA,WAAP;AACA;;AAEDC,EAAAA,OAAO,CAACL,IAAD,EAAOb,cAAP,EAAuB;AAC7B,UAAMoB,sBAAsB,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBtB,cAAlB,CAA/B;AACAA,IAAAA,cAAc,GAAG,KAAKD,KAAL,CAAWC,cAAX,CAA0BQ,GAA1B,CAA8BK,IAA9B,EAAoCU,IAApC,CAAyCvB,cAAzC,CAAjB;AACA,UAAMC,QAAQ,GAAGT,OAAO,CAACgC,cAAR,CAAuBxB,cAAvB,CAAjB;;AACA,QAAI,CAACC,QAAL,EAAe;AACd,YAAM,IAAIwB,KAAJ,CAAU,qBAAV,CAAN;AACA;AACD;;;AACA,UAAMC,UAAU,GAAG,IAAIf,GAAJ,EAAnB;;AACAV,IAAAA,QAAQ,CAAC0B,WAAT,GAAuBvB,OAAO,IAAI;AACjC,YAAMwB,UAAU,GAAGF,UAAU,CAACd,GAAX,CAAeR,OAAf,CAAnB;AACA,UAAIwB,UAAU,KAAKC,SAAnB,EAA8B,OAAOD,UAAP;AAC9B,YAAME,aAAa,GAAGpC,iBAAiB,CAAC0B,sBAAD,EAAyBhB,OAAzB,CAAvC;AACA,YAAMH,QAAQ,GAAG,KAAKW,GAAL,CAASC,IAAT,EAAeiB,aAAf,CAAjB;AACAJ,MAAAA,UAAU,CAACP,GAAX,CAAef,OAAf,EAAwBH,QAAxB;AACA,aAAOA,QAAP;AACA,KAPD;;AAQA,SAAKF,KAAL,CAAWE,QAAX,CAAoBO,GAApB,CAAwBK,IAAxB,EAA8BU,IAA9B,CAAmCtB,QAAnC,EAA6CD,cAA7C;AACA,WAAOC,QAAP;AACA;;AA1DqD,CAAvD","sourcesContent":["/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst { Tapable, HookMap, SyncHook, SyncWaterfallHook } = require(\"tapable\");\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst { cachedCleverMerge } = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\nconst EMTPY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ResolverFactory extends Tapable {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tresolveOptions: new HookMap(\n\t\t\t\t() => new SyncWaterfallHook([\"resolveOptions\"])\n\t\t\t),\n\t\t\tresolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\"]))\n\t\t};\n\t\tthis._pluginCompat.tap(\"ResolverFactory\", options => {\n\t\t\tlet match;\n\t\t\tmatch = /^resolve-options (.+)$/.exec(options.name);\n\t\t\tif (match) {\n\t\t\t\tthis.hooks.resolveOptions\n\t\t\t\t\t.for(match[1])\n\t\t\t\t\t.tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tmatch = /^resolver (.+)$/.exec(options.name);\n\t\t\tif (match) {\n\t\t\t\tthis.hooks.resolver\n\t\t\t\t\t.for(match[1])\n\t\t\t\t\t.tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tthis.cache2 = new Map();\n\t}\n\n\tget(type, resolveOptions) {\n\t\tresolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;\n\t\tconst ident = `${type}|${JSON.stringify(resolveOptions)}`;\n\t\tconst resolver = this.cache2.get(ident);\n\t\tif (resolver) return resolver;\n\t\tconst newResolver = this._create(type, resolveOptions);\n\t\tthis.cache2.set(ident, newResolver);\n\t\treturn newResolver;\n\t}\n\n\t_create(type, resolveOptions) {\n\t\tconst originalResolveOptions = Object.assign({}, resolveOptions);\n\t\tresolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n\t\tconst resolver = Factory.createResolver(resolveOptions);\n\t\tif (!resolver) {\n\t\t\tthrow new Error(\"No resolver created\");\n\t\t}\n\t\t/** @type {Map<Object, Resolver>} */\n\t\tconst childCache = new Map();\n\t\tresolver.withOptions = options => {\n\t\t\tconst cacheEntry = childCache.get(options);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tconst mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\t\t\tconst resolver = this.get(type, mergedOptions);\n\t\t\tchildCache.set(options, resolver);\n\t\t\treturn resolver;\n\t\t};\n\t\tthis.hooks.resolver.for(type).call(resolver, resolveOptions);\n\t\treturn resolver;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}