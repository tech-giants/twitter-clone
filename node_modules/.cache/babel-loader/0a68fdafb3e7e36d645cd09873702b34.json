{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFocusable = isFocusable;\nexports.isClickableInput = isClickableInput;\nexports.getMouseEventOptions = getMouseEventOptions;\nexports.isLabelWithInternallyDisabledControl = isLabelWithInternallyDisabledControl;\nexports.getActiveElement = getActiveElement;\nexports.calculateNewValue = calculateNewValue;\nexports.setSelectionRangeIfNecessary = setSelectionRangeIfNecessary;\nexports.eventWrapper = eventWrapper;\nexports.isValidDateValue = isValidDateValue;\nexports.isValidInputTimeValue = isValidInputTimeValue;\nexports.buildTimeValue = buildTimeValue;\nexports.getValue = getValue;\nexports.getSelectionRange = getSelectionRange;\nexports.isContentEditable = isContentEditable;\nexports.isInstanceOfElement = isInstanceOfElement;\nexports.isVisible = isVisible;\nexports.FOCUSABLE_SELECTOR = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _helpers = require(\"@testing-library/dom/dist/helpers\"); // isInstanceOfElement can be removed once the peerDependency for @testing-library/dom is bumped to a version that includes https://github.com/testing-library/dom-testing-library/pull/885\n\n/**\n * Check if an element is of a given type.\n *\n * @param {Element} element The element to test\n * @param {string} elementType Constructor name. E.g. 'HTMLSelectElement'\n */\n\n\nfunction isInstanceOfElement(element, elementType) {\n  try {\n    const window = (0, _helpers.getWindowFromNode)(element); // Window usually has the element constructors as properties but is not required to do so per specs\n\n    if (typeof window[elementType] === 'function') {\n      return element instanceof window[elementType];\n    }\n  } catch (e) {// The document might not be associated with a window\n  } // Fall back to the constructor name as workaround for test environments that\n  // a) not associate the document with a window\n  // b) not provide the constructor as property of window\n\n\n  if (/^HTML(\\w+)Element$/.test(element.constructor.name)) {\n    return element.constructor.name === elementType;\n  } // The user passed some node that is not created in a browser-like environment\n\n\n  throw new Error(`Unable to verify if element is instance of ${elementType}. Please file an issue describing your test environment: https://github.com/testing-library/dom-testing-library/issues/new`);\n}\n\nfunction isMousePressEvent(event) {\n  return event === 'mousedown' || event === 'mouseup' || event === 'click' || event === 'dblclick';\n}\n\nfunction invert(map) {\n  const res = {};\n\n  for (const key of Object.keys(map)) {\n    res[map[key]] = key;\n  }\n\n  return res;\n} // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n\n\nconst BUTTONS_TO_NAMES = {\n  0: 'none',\n  1: 'primary',\n  2: 'secondary',\n  4: 'auxiliary'\n};\nconst NAMES_TO_BUTTONS = invert(BUTTONS_TO_NAMES); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n\nconst BUTTON_TO_NAMES = {\n  0: 'primary',\n  1: 'auxiliary',\n  2: 'secondary'\n};\nconst NAMES_TO_BUTTON = invert(BUTTON_TO_NAMES);\n\nfunction convertMouseButtons(event, init, property, mapping) {\n  if (!isMousePressEvent(event)) {\n    return 0;\n  }\n\n  if (init[property] != null) {\n    return init[property];\n  }\n\n  if (init.buttons != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTONS_TO_NAMES[init.buttons]] || 0;\n  }\n\n  if (init.button != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTON_TO_NAMES[init.button]] || 0;\n  }\n\n  return property != 'button' && isMousePressEvent(event) ? 1 : 0;\n}\n\nfunction getMouseEventOptions(event, init, clickCount = 0) {\n  init = init || {};\n  return { ...init,\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n    detail: event === 'mousedown' || event === 'mouseup' || event === 'click' ? 1 + clickCount : clickCount,\n    buttons: convertMouseButtons(event, init, 'buttons', NAMES_TO_BUTTONS),\n    button: convertMouseButtons(event, init, 'button', NAMES_TO_BUTTON)\n  };\n} // Absolutely NO events fire on label elements that contain their control\n// if that control is disabled. NUTS!\n// no joke. There are NO events for: <label><input disabled /><label>\n\n\nfunction isLabelWithInternallyDisabledControl(element) {\n  var _element$control;\n\n  return element.tagName === 'LABEL' && ((_element$control = element.control) == null ? void 0 : _element$control.disabled) && element.contains(element.control);\n}\n\nfunction getActiveElement(document) {\n  const activeElement = document.activeElement;\n\n  if (activeElement != null && activeElement.shadowRoot) {\n    return getActiveElement(activeElement.shadowRoot);\n  } else {\n    return activeElement;\n  }\n}\n\nfunction supportsMaxLength(element) {\n  if (element.tagName === 'TEXTAREA') return true;\n\n  if (element.tagName === 'INPUT') {\n    const type = element.getAttribute('type'); // Missing value default is \"text\"\n\n    if (!type) return true; // https://html.spec.whatwg.org/multipage/input.html#concept-input-apply\n\n    if (type.match(/email|password|search|telephone|text|url/)) return true;\n  }\n\n  return false;\n}\n\nfunction getSelectionRange(element) {\n  if (isContentEditable(element)) {\n    const range = element.ownerDocument.getSelection().getRangeAt(0);\n    return {\n      selectionStart: range.startOffset,\n      selectionEnd: range.endOffset\n    };\n  }\n\n  return {\n    selectionStart: element.selectionStart,\n    selectionEnd: element.selectionEnd\n  };\n} //jsdom is not supporting isContentEditable\n\n\nfunction isContentEditable(element) {\n  return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');\n}\n\nfunction getValue(element) {\n  if (isContentEditable(element)) {\n    return element.textContent;\n  }\n\n  return element.value;\n}\n\nfunction calculateNewValue(newEntry, element) {\n  var _element$getAttribute;\n\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n  const value = getValue(element); // can't use .maxLength property because of a jsdom bug:\n  // https://github.com/jsdom/jsdom/issues/2927\n\n  const maxLength = Number((_element$getAttribute = element.getAttribute('maxlength')) != null ? _element$getAttribute : -1);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value + newEntry;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = newEntry + value;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value + newEntry;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + newEntry + value.slice(selectionEnd);\n    }\n\n    newSelectionStart = selectionStart + newEntry.length;\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart) + newEntry;\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  if (element.type === 'date' && !isValidDateValue(element, newValue)) {\n    newValue = value;\n  }\n\n  if (element.type === 'time' && !isValidInputTimeValue(element, newValue)) {\n    if (isValidInputTimeValue(element, newEntry)) {\n      newValue = newEntry;\n    } else {\n      newValue = value;\n    }\n  }\n\n  if (!supportsMaxLength(element) || maxLength < 0) {\n    return {\n      newValue,\n      newSelectionStart\n    };\n  } else {\n    return {\n      newValue: newValue.slice(0, maxLength),\n      newSelectionStart: newSelectionStart > maxLength ? maxLength : newSelectionStart\n    };\n  }\n}\n\nfunction setSelectionRangeIfNecessary(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n\n  if (!isContentEditable(element) && (!element.setSelectionRange || selectionStart === null)) {\n    // cannot set selection\n    return;\n  }\n\n  if (selectionStart !== newSelectionStart || selectionEnd !== newSelectionStart) {\n    if (isContentEditable(element)) {\n      const range = element.ownerDocument.createRange();\n      range.selectNodeContents(element);\n      range.setStart(element.firstChild, newSelectionStart);\n      range.setEnd(element.firstChild, newSelectionEnd);\n      element.ownerDocument.getSelection().removeAllRanges();\n      element.ownerDocument.getSelection().addRange(range);\n    } else {\n      element.setSelectionRange(newSelectionStart, newSelectionEnd);\n    }\n  }\n}\n\nconst FOCUSABLE_SELECTOR = ['input:not([type=hidden]):not([disabled])', 'button:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', '[contenteditable=\"\"]', '[contenteditable=\"true\"]', 'a[href]', '[tabindex]:not([disabled])'].join(', ');\nexports.FOCUSABLE_SELECTOR = FOCUSABLE_SELECTOR;\n\nfunction isFocusable(element) {\n  return !isLabelWithInternallyDisabledControl(element) && (element == null ? void 0 : element.matches(FOCUSABLE_SELECTOR));\n}\n\nconst CLICKABLE_INPUT_TYPES = ['button', 'color', 'file', 'image', 'reset', 'submit'];\n\nfunction isClickableInput(element) {\n  return element.tagName === 'BUTTON' || isInstanceOfElement(element, 'HTMLInputElement') && CLICKABLE_INPUT_TYPES.includes(element.type);\n}\n\nfunction isVisible(element) {\n  const getComputedStyle = (0, _helpers.getWindowFromNode)(element).getComputedStyle;\n\n  for (; element && element.ownerDocument; element = element.parentNode) {\n    const display = getComputedStyle(element).display;\n\n    if (display === 'none') {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction eventWrapper(cb) {\n  let result;\n  (0, _dom.getConfig)().eventWrapper(() => {\n    result = cb();\n  });\n  return result;\n}\n\nfunction isValidDateValue(element, value) {\n  if (element.type !== 'date') return false;\n  const clone = element.cloneNode();\n  clone.value = value;\n  return clone.value === value;\n}\n\nfunction buildTimeValue(value) {\n  function build(onlyDigitsValue, index) {\n    const hours = onlyDigitsValue.slice(0, index);\n    const validHours = Math.min(parseInt(hours, 10), 23);\n    const minuteCharacters = onlyDigitsValue.slice(index);\n    const parsedMinutes = parseInt(minuteCharacters, 10);\n    const validMinutes = Math.min(parsedMinutes, 59);\n    return `${validHours.toString().padStart(2, '0')}:${validMinutes.toString().padStart(2, '0')}`;\n  }\n\n  const onlyDigitsValue = value.replace(/\\D/g, '');\n\n  if (onlyDigitsValue.length < 2) {\n    return value;\n  }\n\n  const firstDigit = parseInt(onlyDigitsValue[0], 10);\n  const secondDigit = parseInt(onlyDigitsValue[1], 10);\n\n  if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {\n    let index;\n\n    if (firstDigit >= 3) {\n      index = 1;\n    } else {\n      index = 2;\n    }\n\n    return build(onlyDigitsValue, index);\n  }\n\n  if (value.length === 2) {\n    return value;\n  }\n\n  return build(onlyDigitsValue, 2);\n}\n\nfunction isValidInputTimeValue(element, timeValue) {\n  if (element.type !== 'time') return false;\n  const clone = element.cloneNode();\n  clone.value = timeValue;\n  return clone.value === timeValue;\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@testing-library/user-event/dist/utils.js"],"names":["Object","defineProperty","exports","value","isFocusable","isClickableInput","getMouseEventOptions","isLabelWithInternallyDisabledControl","getActiveElement","calculateNewValue","setSelectionRangeIfNecessary","eventWrapper","isValidDateValue","isValidInputTimeValue","buildTimeValue","getValue","getSelectionRange","isContentEditable","isInstanceOfElement","isVisible","FOCUSABLE_SELECTOR","_dom","require","_helpers","element","elementType","window","getWindowFromNode","e","test","constructor","name","Error","isMousePressEvent","event","invert","map","res","key","keys","BUTTONS_TO_NAMES","NAMES_TO_BUTTONS","BUTTON_TO_NAMES","NAMES_TO_BUTTON","convertMouseButtons","init","property","mapping","buttons","button","clickCount","detail","_element$control","tagName","control","disabled","contains","document","activeElement","shadowRoot","supportsMaxLength","type","getAttribute","match","range","ownerDocument","getSelection","getRangeAt","selectionStart","startOffset","selectionEnd","endOffset","hasAttribute","textContent","newEntry","_element$getAttribute","maxLength","Number","newValue","newSelectionStart","length","slice","firstPart","newSelectionEnd","setSelectionRange","createRange","selectNodeContents","setStart","firstChild","setEnd","removeAllRanges","addRange","join","matches","CLICKABLE_INPUT_TYPES","includes","getComputedStyle","parentNode","display","cb","result","getConfig","clone","cloneNode","build","onlyDigitsValue","index","hours","validHours","Math","min","parseInt","minuteCharacters","parsedMinutes","validMinutes","toString","padStart","replace","firstDigit","secondDigit","timeValue"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFocusable = isFocusable;\nexports.isClickableInput = isClickableInput;\nexports.getMouseEventOptions = getMouseEventOptions;\nexports.isLabelWithInternallyDisabledControl = isLabelWithInternallyDisabledControl;\nexports.getActiveElement = getActiveElement;\nexports.calculateNewValue = calculateNewValue;\nexports.setSelectionRangeIfNecessary = setSelectionRangeIfNecessary;\nexports.eventWrapper = eventWrapper;\nexports.isValidDateValue = isValidDateValue;\nexports.isValidInputTimeValue = isValidInputTimeValue;\nexports.buildTimeValue = buildTimeValue;\nexports.getValue = getValue;\nexports.getSelectionRange = getSelectionRange;\nexports.isContentEditable = isContentEditable;\nexports.isInstanceOfElement = isInstanceOfElement;\nexports.isVisible = isVisible;\nexports.FOCUSABLE_SELECTOR = void 0;\n\nvar _dom = require(\"@testing-library/dom\");\n\nvar _helpers = require(\"@testing-library/dom/dist/helpers\");\n\n// isInstanceOfElement can be removed once the peerDependency for @testing-library/dom is bumped to a version that includes https://github.com/testing-library/dom-testing-library/pull/885\n\n/**\n * Check if an element is of a given type.\n *\n * @param {Element} element The element to test\n * @param {string} elementType Constructor name. E.g. 'HTMLSelectElement'\n */\nfunction isInstanceOfElement(element, elementType) {\n  try {\n    const window = (0, _helpers.getWindowFromNode)(element); // Window usually has the element constructors as properties but is not required to do so per specs\n\n    if (typeof window[elementType] === 'function') {\n      return element instanceof window[elementType];\n    }\n  } catch (e) {// The document might not be associated with a window\n  } // Fall back to the constructor name as workaround for test environments that\n  // a) not associate the document with a window\n  // b) not provide the constructor as property of window\n\n\n  if (/^HTML(\\w+)Element$/.test(element.constructor.name)) {\n    return element.constructor.name === elementType;\n  } // The user passed some node that is not created in a browser-like environment\n\n\n  throw new Error(`Unable to verify if element is instance of ${elementType}. Please file an issue describing your test environment: https://github.com/testing-library/dom-testing-library/issues/new`);\n}\n\nfunction isMousePressEvent(event) {\n  return event === 'mousedown' || event === 'mouseup' || event === 'click' || event === 'dblclick';\n}\n\nfunction invert(map) {\n  const res = {};\n\n  for (const key of Object.keys(map)) {\n    res[map[key]] = key;\n  }\n\n  return res;\n} // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n\n\nconst BUTTONS_TO_NAMES = {\n  0: 'none',\n  1: 'primary',\n  2: 'secondary',\n  4: 'auxiliary'\n};\nconst NAMES_TO_BUTTONS = invert(BUTTONS_TO_NAMES); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n\nconst BUTTON_TO_NAMES = {\n  0: 'primary',\n  1: 'auxiliary',\n  2: 'secondary'\n};\nconst NAMES_TO_BUTTON = invert(BUTTON_TO_NAMES);\n\nfunction convertMouseButtons(event, init, property, mapping) {\n  if (!isMousePressEvent(event)) {\n    return 0;\n  }\n\n  if (init[property] != null) {\n    return init[property];\n  }\n\n  if (init.buttons != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTONS_TO_NAMES[init.buttons]] || 0;\n  }\n\n  if (init.button != null) {\n    // not sure how to test this. Feel free to try and add a test if you want.\n    // istanbul ignore next\n    return mapping[BUTTON_TO_NAMES[init.button]] || 0;\n  }\n\n  return property != 'button' && isMousePressEvent(event) ? 1 : 0;\n}\n\nfunction getMouseEventOptions(event, init, clickCount = 0) {\n  init = init || {};\n  return { ...init,\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n    detail: event === 'mousedown' || event === 'mouseup' || event === 'click' ? 1 + clickCount : clickCount,\n    buttons: convertMouseButtons(event, init, 'buttons', NAMES_TO_BUTTONS),\n    button: convertMouseButtons(event, init, 'button', NAMES_TO_BUTTON)\n  };\n} // Absolutely NO events fire on label elements that contain their control\n// if that control is disabled. NUTS!\n// no joke. There are NO events for: <label><input disabled /><label>\n\n\nfunction isLabelWithInternallyDisabledControl(element) {\n  var _element$control;\n\n  return element.tagName === 'LABEL' && ((_element$control = element.control) == null ? void 0 : _element$control.disabled) && element.contains(element.control);\n}\n\nfunction getActiveElement(document) {\n  const activeElement = document.activeElement;\n\n  if (activeElement != null && activeElement.shadowRoot) {\n    return getActiveElement(activeElement.shadowRoot);\n  } else {\n    return activeElement;\n  }\n}\n\nfunction supportsMaxLength(element) {\n  if (element.tagName === 'TEXTAREA') return true;\n\n  if (element.tagName === 'INPUT') {\n    const type = element.getAttribute('type'); // Missing value default is \"text\"\n\n    if (!type) return true; // https://html.spec.whatwg.org/multipage/input.html#concept-input-apply\n\n    if (type.match(/email|password|search|telephone|text|url/)) return true;\n  }\n\n  return false;\n}\n\nfunction getSelectionRange(element) {\n  if (isContentEditable(element)) {\n    const range = element.ownerDocument.getSelection().getRangeAt(0);\n    return {\n      selectionStart: range.startOffset,\n      selectionEnd: range.endOffset\n    };\n  }\n\n  return {\n    selectionStart: element.selectionStart,\n    selectionEnd: element.selectionEnd\n  };\n} //jsdom is not supporting isContentEditable\n\n\nfunction isContentEditable(element) {\n  return element.hasAttribute('contenteditable') && (element.getAttribute('contenteditable') == 'true' || element.getAttribute('contenteditable') == '');\n}\n\nfunction getValue(element) {\n  if (isContentEditable(element)) {\n    return element.textContent;\n  }\n\n  return element.value;\n}\n\nfunction calculateNewValue(newEntry, element) {\n  var _element$getAttribute;\n\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n  const value = getValue(element); // can't use .maxLength property because of a jsdom bug:\n  // https://github.com/jsdom/jsdom/issues/2927\n\n  const maxLength = Number((_element$getAttribute = element.getAttribute('maxlength')) != null ? _element$getAttribute : -1);\n  let newValue, newSelectionStart;\n\n  if (selectionStart === null) {\n    // at the end of an input type that does not support selection ranges\n    // https://github.com/testing-library/user-event/issues/316#issuecomment-639744793\n    newValue = value + newEntry;\n  } else if (selectionStart === selectionEnd) {\n    if (selectionStart === 0) {\n      // at the beginning of the input\n      newValue = newEntry + value;\n    } else if (selectionStart === value.length) {\n      // at the end of the input\n      newValue = value + newEntry;\n    } else {\n      // in the middle of the input\n      newValue = value.slice(0, selectionStart) + newEntry + value.slice(selectionEnd);\n    }\n\n    newSelectionStart = selectionStart + newEntry.length;\n  } else {\n    // we have something selected\n    const firstPart = value.slice(0, selectionStart) + newEntry;\n    newValue = firstPart + value.slice(selectionEnd);\n    newSelectionStart = firstPart.length;\n  }\n\n  if (element.type === 'date' && !isValidDateValue(element, newValue)) {\n    newValue = value;\n  }\n\n  if (element.type === 'time' && !isValidInputTimeValue(element, newValue)) {\n    if (isValidInputTimeValue(element, newEntry)) {\n      newValue = newEntry;\n    } else {\n      newValue = value;\n    }\n  }\n\n  if (!supportsMaxLength(element) || maxLength < 0) {\n    return {\n      newValue,\n      newSelectionStart\n    };\n  } else {\n    return {\n      newValue: newValue.slice(0, maxLength),\n      newSelectionStart: newSelectionStart > maxLength ? maxLength : newSelectionStart\n    };\n  }\n}\n\nfunction setSelectionRangeIfNecessary(element, newSelectionStart, newSelectionEnd) {\n  const {\n    selectionStart,\n    selectionEnd\n  } = getSelectionRange(element);\n\n  if (!isContentEditable(element) && (!element.setSelectionRange || selectionStart === null)) {\n    // cannot set selection\n    return;\n  }\n\n  if (selectionStart !== newSelectionStart || selectionEnd !== newSelectionStart) {\n    if (isContentEditable(element)) {\n      const range = element.ownerDocument.createRange();\n      range.selectNodeContents(element);\n      range.setStart(element.firstChild, newSelectionStart);\n      range.setEnd(element.firstChild, newSelectionEnd);\n      element.ownerDocument.getSelection().removeAllRanges();\n      element.ownerDocument.getSelection().addRange(range);\n    } else {\n      element.setSelectionRange(newSelectionStart, newSelectionEnd);\n    }\n  }\n}\n\nconst FOCUSABLE_SELECTOR = ['input:not([type=hidden]):not([disabled])', 'button:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', '[contenteditable=\"\"]', '[contenteditable=\"true\"]', 'a[href]', '[tabindex]:not([disabled])'].join(', ');\nexports.FOCUSABLE_SELECTOR = FOCUSABLE_SELECTOR;\n\nfunction isFocusable(element) {\n  return !isLabelWithInternallyDisabledControl(element) && (element == null ? void 0 : element.matches(FOCUSABLE_SELECTOR));\n}\n\nconst CLICKABLE_INPUT_TYPES = ['button', 'color', 'file', 'image', 'reset', 'submit'];\n\nfunction isClickableInput(element) {\n  return element.tagName === 'BUTTON' || isInstanceOfElement(element, 'HTMLInputElement') && CLICKABLE_INPUT_TYPES.includes(element.type);\n}\n\nfunction isVisible(element) {\n  const getComputedStyle = (0, _helpers.getWindowFromNode)(element).getComputedStyle;\n\n  for (; element && element.ownerDocument; element = element.parentNode) {\n    const display = getComputedStyle(element).display;\n\n    if (display === 'none') {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction eventWrapper(cb) {\n  let result;\n  (0, _dom.getConfig)().eventWrapper(() => {\n    result = cb();\n  });\n  return result;\n}\n\nfunction isValidDateValue(element, value) {\n  if (element.type !== 'date') return false;\n  const clone = element.cloneNode();\n  clone.value = value;\n  return clone.value === value;\n}\n\nfunction buildTimeValue(value) {\n  function build(onlyDigitsValue, index) {\n    const hours = onlyDigitsValue.slice(0, index);\n    const validHours = Math.min(parseInt(hours, 10), 23);\n    const minuteCharacters = onlyDigitsValue.slice(index);\n    const parsedMinutes = parseInt(minuteCharacters, 10);\n    const validMinutes = Math.min(parsedMinutes, 59);\n    return `${validHours.toString().padStart(2, '0')}:${validMinutes.toString().padStart(2, '0')}`;\n  }\n\n  const onlyDigitsValue = value.replace(/\\D/g, '');\n\n  if (onlyDigitsValue.length < 2) {\n    return value;\n  }\n\n  const firstDigit = parseInt(onlyDigitsValue[0], 10);\n  const secondDigit = parseInt(onlyDigitsValue[1], 10);\n\n  if (firstDigit >= 3 || firstDigit === 2 && secondDigit >= 4) {\n    let index;\n\n    if (firstDigit >= 3) {\n      index = 1;\n    } else {\n      index = 2;\n    }\n\n    return build(onlyDigitsValue, index);\n  }\n\n  if (value.length === 2) {\n    return value;\n  }\n\n  return build(onlyDigitsValue, 2);\n}\n\nfunction isValidInputTimeValue(element, timeValue) {\n  if (element.type !== 'time') return false;\n  const clone = element.cloneNode();\n  clone.value = timeValue;\n  return clone.value === timeValue;\n}"]},"metadata":{},"sourceType":"script"}