{"ast":null,"code":"import { encodeU32 } from \"@webassemblyjs/wasm-gen\";\nimport { getSectionMetadata, traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nexport function resizeSectionByteSize(ast, uint8Buffer, section, deltaBytes) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.size.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.size.loc.start.column;\n  var end = sectionMetadata.size.loc.end.column;\n  var newSectionSize = sectionMetadata.size.value + deltaBytes;\n  var newBytes = encodeU32(newSectionSize);\n  /**\n   * update AST\n   */\n\n  sectionMetadata.size.value = newSectionSize;\n  var oldu32EncodedLen = end - start;\n  var newu32EncodedLen = newBytes.length; // the new u32 has a different encoded length\n\n  if (newu32EncodedLen !== oldu32EncodedLen) {\n    var deltaInSizeEncoding = newu32EncodedLen - oldu32EncodedLen;\n    sectionMetadata.size.loc.end.column = start + newu32EncodedLen;\n    deltaBytes += deltaInSizeEncoding; // move the vec size pointer size the section size is now smaller\n\n    sectionMetadata.vectorOfSize.loc.start.column += deltaInSizeEncoding;\n    sectionMetadata.vectorOfSize.loc.end.column += deltaInSizeEncoding;\n  } // Once we hit our section every that is after needs to be shifted by the delta\n\n\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}\nexport function resizeSectionVecSize(ast, uint8Buffer, section, deltaElements) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.vectorOfSize.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // Section has no vector\n\n\n  if (sectionMetadata.vectorOfSize.value === -1) {\n    return uint8Buffer;\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.vectorOfSize.loc.start.column;\n  var end = sectionMetadata.vectorOfSize.loc.end.column;\n  var newValue = sectionMetadata.vectorOfSize.value + deltaElements;\n  var newBytes = encodeU32(newValue); // Update AST\n\n  sectionMetadata.vectorOfSize.value = newValue;\n  sectionMetadata.vectorOfSize.loc.end.column = start + newBytes.length;\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/helper-wasm-section/esm/resize.js"],"names":["encodeU32","getSectionMetadata","traverse","shiftSection","overrideBytesInBuffer","resizeSectionByteSize","ast","uint8Buffer","section","deltaBytes","sectionMetadata","Error","size","loc","start","column","end","newSectionSize","value","newBytes","oldu32EncodedLen","newu32EncodedLen","length","deltaInSizeEncoding","vectorOfSize","encounteredSection","SectionMetadata","path","node","resizeSectionVecSize","deltaElements","newValue"],"mappings":"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","sourcesContent":["import { encodeU32 } from \"@webassemblyjs/wasm-gen\";\nimport { getSectionMetadata, traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\nexport function resizeSectionByteSize(ast, uint8Buffer, section, deltaBytes) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.size.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.size.loc.start.column;\n  var end = sectionMetadata.size.loc.end.column;\n  var newSectionSize = sectionMetadata.size.value + deltaBytes;\n  var newBytes = encodeU32(newSectionSize);\n  /**\n   * update AST\n   */\n\n  sectionMetadata.size.value = newSectionSize;\n  var oldu32EncodedLen = end - start;\n  var newu32EncodedLen = newBytes.length; // the new u32 has a different encoded length\n\n  if (newu32EncodedLen !== oldu32EncodedLen) {\n    var deltaInSizeEncoding = newu32EncodedLen - oldu32EncodedLen;\n    sectionMetadata.size.loc.end.column = start + newu32EncodedLen;\n    deltaBytes += deltaInSizeEncoding; // move the vec size pointer size the section size is now smaller\n\n    sectionMetadata.vectorOfSize.loc.start.column += deltaInSizeEncoding;\n    sectionMetadata.vectorOfSize.loc.end.column += deltaInSizeEncoding;\n  } // Once we hit our section every that is after needs to be shifted by the delta\n\n\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaBytes);\n      }\n    }\n  });\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}\nexport function resizeSectionVecSize(ast, uint8Buffer, section, deltaElements) {\n  var sectionMetadata = getSectionMetadata(ast, section);\n\n  if (typeof sectionMetadata === \"undefined\") {\n    throw new Error(\"Section metadata not found\");\n  }\n\n  if (typeof sectionMetadata.vectorOfSize.loc === \"undefined\") {\n    throw new Error(\"SectionMetadata \" + section + \" has no loc\");\n  } // Section has no vector\n\n\n  if (sectionMetadata.vectorOfSize.value === -1) {\n    return uint8Buffer;\n  } // keep old node location to be overriden\n\n\n  var start = sectionMetadata.vectorOfSize.loc.start.column;\n  var end = sectionMetadata.vectorOfSize.loc.end.column;\n  var newValue = sectionMetadata.vectorOfSize.value + deltaElements;\n  var newBytes = encodeU32(newValue); // Update AST\n\n  sectionMetadata.vectorOfSize.value = newValue;\n  sectionMetadata.vectorOfSize.loc.end.column = start + newBytes.length;\n  return overrideBytesInBuffer(uint8Buffer, start, end, newBytes);\n}"]},"metadata":{},"sourceType":"module"}