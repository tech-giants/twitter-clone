{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst path = require(\"path\");\n\nconst {\n  Tapable,\n  AsyncSeriesWaterfallHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\n\nconst ContextModule = require(\"./ContextModule\");\n\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n/** @typedef {import(\"./Module\")} Module */\n\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nmodule.exports = class ContextModuleFactory extends Tapable {\n  constructor(resolverFactory) {\n    super();\n    this.hooks = {\n      /** @type {AsyncSeriesWaterfallHook<TODO>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {AsyncSeriesWaterfallHook<TODO>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\n      /** @type {SyncWaterfallHook<string[]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\n      /** @type {SyncWaterfallHook<TODO[]>} */\n      alternatives: new AsyncSeriesWaterfallHook([\"modules\"])\n    };\n\n    this._pluginCompat.tap(\"ContextModuleFactory\", options => {\n      switch (options.name) {\n        case \"before-resolve\":\n        case \"after-resolve\":\n        case \"alternatives\":\n          options.async = true;\n          break;\n      }\n    });\n\n    this.resolverFactory = resolverFactory;\n  }\n\n  create(data, callback) {\n    const context = data.context;\n    const dependencies = data.dependencies;\n    const resolveOptions = data.resolveOptions;\n    const dependency = dependencies[0];\n    this.hooks.beforeResolve.callAsync(Object.assign({\n      context: context,\n      dependencies: dependencies,\n      resolveOptions\n    }, dependency.options), (err, beforeResolveResult) => {\n      if (err) return callback(err); // Ignored\n\n      if (!beforeResolveResult) return callback();\n      const context = beforeResolveResult.context;\n      const request = beforeResolveResult.request;\n      const resolveOptions = beforeResolveResult.resolveOptions;\n      let loaders,\n          resource,\n          loadersPrefix = \"\";\n      const idx = request.lastIndexOf(\"!\");\n\n      if (idx >= 0) {\n        let loadersRequest = request.substr(0, idx + 1);\n        let i;\n\n        for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n          loadersPrefix += \"!\";\n        }\n\n        loadersRequest = loadersRequest.substr(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n\n        if (loadersRequest === \"\") {\n          loaders = [];\n        } else {\n          loaders = loadersRequest.split(\"!\");\n        }\n\n        resource = request.substr(idx + 1);\n      } else {\n        loaders = [];\n        resource = request;\n      }\n\n      const contextResolver = this.resolverFactory.get(\"context\", resolveOptions || EMPTY_RESOLVE_OPTIONS);\n      const loaderResolver = this.resolverFactory.get(\"loader\", EMPTY_RESOLVE_OPTIONS);\n      asyncLib.parallel([callback => {\n        contextResolver.resolve({}, context, resource, {}, (err, result) => {\n          if (err) return callback(err);\n          callback(null, result);\n        });\n      }, callback => {\n        asyncLib.map(loaders, (loader, callback) => {\n          loaderResolver.resolve({}, context, loader, {}, (err, result) => {\n            if (err) return callback(err);\n            callback(null, result);\n          });\n        }, callback);\n      }], (err, result) => {\n        if (err) return callback(err);\n        this.hooks.afterResolve.callAsync(Object.assign({\n          addon: loadersPrefix + result[1].join(\"!\") + (result[1].length > 0 ? \"!\" : \"\"),\n          resource: result[0],\n          resolveDependencies: this.resolveDependencies.bind(this)\n        }, beforeResolveResult), (err, result) => {\n          if (err) return callback(err); // Ignored\n\n          if (!result) return callback();\n          return callback(null, new ContextModule(result.resolveDependencies, result));\n        });\n      });\n    });\n  }\n\n  resolveDependencies(fs, options, callback) {\n    const cmf = this;\n    let resource = options.resource;\n    let resourceQuery = options.resourceQuery;\n    let recursive = options.recursive;\n    let regExp = options.regExp;\n    let include = options.include;\n    let exclude = options.exclude;\n    if (!regExp || !resource) return callback(null, []);\n\n    const addDirectory = (directory, callback) => {\n      fs.readdir(directory, (err, files) => {\n        if (err) return callback(err);\n        files = cmf.hooks.contextModuleFiles.call(files);\n        if (!files || files.length === 0) return callback(null, []);\n        asyncLib.map(files.filter(p => p.indexOf(\".\") !== 0), (segment, callback) => {\n          const subResource = path.join(directory, segment);\n\n          if (!exclude || !subResource.match(exclude)) {\n            fs.stat(subResource, (err, stat) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  // ENOENT is ok here because the file may have been deleted between\n                  // the readdir and stat calls.\n                  return callback();\n                } else {\n                  return callback(err);\n                }\n              }\n\n              if (stat.isDirectory()) {\n                if (!recursive) return callback();\n                addDirectory.call(this, subResource, callback);\n              } else if (stat.isFile() && (!include || subResource.match(include))) {\n                const obj = {\n                  context: resource,\n                  request: \".\" + subResource.substr(resource.length).replace(/\\\\/g, \"/\")\n                };\n                this.hooks.alternatives.callAsync([obj], (err, alternatives) => {\n                  if (err) return callback(err);\n                  alternatives = alternatives.filter(obj => regExp.test(obj.request)).map(obj => {\n                    const dep = new ContextElementDependency(obj.request + resourceQuery, obj.request);\n                    dep.optional = true;\n                    return dep;\n                  });\n                  callback(null, alternatives);\n                });\n              } else {\n                callback();\n              }\n            });\n          } else {\n            callback();\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n          if (!result) return callback(null, []);\n          callback(null, result.filter(Boolean).reduce((a, i) => a.concat(i), []));\n        });\n      });\n    };\n\n    addDirectory(resource, callback);\n  }\n\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/ContextModuleFactory.js"],"names":["asyncLib","require","path","Tapable","AsyncSeriesWaterfallHook","SyncWaterfallHook","ContextModule","ContextElementDependency","EMPTY_RESOLVE_OPTIONS","module","exports","ContextModuleFactory","constructor","resolverFactory","hooks","beforeResolve","afterResolve","contextModuleFiles","alternatives","_pluginCompat","tap","options","name","async","create","data","callback","context","dependencies","resolveOptions","dependency","callAsync","Object","assign","err","beforeResolveResult","request","loaders","resource","loadersPrefix","idx","lastIndexOf","loadersRequest","substr","i","length","replace","split","contextResolver","get","loaderResolver","parallel","resolve","result","map","loader","addon","join","resolveDependencies","bind","fs","cmf","resourceQuery","recursive","regExp","include","exclude","addDirectory","directory","readdir","files","call","filter","p","indexOf","segment","subResource","match","stat","code","isDirectory","isFile","obj","test","dep","optional","Boolean","reduce","a","concat"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst path = require(\"path\");\n\nconst {\n\tTapable,\n\tAsyncSeriesWaterfallHook,\n\tSyncWaterfallHook\n} = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\n\n/** @typedef {import(\"./Module\")} Module */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ContextModuleFactory extends Tapable {\n\tconstructor(resolverFactory) {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\t/** @type {AsyncSeriesWaterfallHook<TODO>} */\n\t\t\tbeforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {AsyncSeriesWaterfallHook<TODO>} */\n\t\t\tafterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {SyncWaterfallHook<string[]>} */\n\t\t\tcontextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\t\t\t/** @type {SyncWaterfallHook<TODO[]>} */\n\t\t\talternatives: new AsyncSeriesWaterfallHook([\"modules\"])\n\t\t};\n\t\tthis._pluginCompat.tap(\"ContextModuleFactory\", options => {\n\t\t\tswitch (options.name) {\n\t\t\t\tcase \"before-resolve\":\n\t\t\t\tcase \"after-resolve\":\n\t\t\t\tcase \"alternatives\":\n\t\t\t\t\toptions.async = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\tthis.resolverFactory = resolverFactory;\n\t}\n\n\tcreate(data, callback) {\n\t\tconst context = data.context;\n\t\tconst dependencies = data.dependencies;\n\t\tconst resolveOptions = data.resolveOptions;\n\t\tconst dependency = dependencies[0];\n\t\tthis.hooks.beforeResolve.callAsync(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tcontext: context,\n\t\t\t\t\tdependencies: dependencies,\n\t\t\t\t\tresolveOptions\n\t\t\t\t},\n\t\t\t\tdependency.options\n\t\t\t),\n\t\t\t(err, beforeResolveResult) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t// Ignored\n\t\t\t\tif (!beforeResolveResult) return callback();\n\n\t\t\t\tconst context = beforeResolveResult.context;\n\t\t\t\tconst request = beforeResolveResult.request;\n\t\t\t\tconst resolveOptions = beforeResolveResult.resolveOptions;\n\n\t\t\t\tlet loaders,\n\t\t\t\t\tresource,\n\t\t\t\t\tloadersPrefix = \"\";\n\t\t\t\tconst idx = request.lastIndexOf(\"!\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tlet loadersRequest = request.substr(0, idx + 1);\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\ti < loadersRequest.length && loadersRequest[i] === \"!\";\n\t\t\t\t\t\ti++\n\t\t\t\t\t) {\n\t\t\t\t\t\tloadersPrefix += \"!\";\n\t\t\t\t\t}\n\t\t\t\t\tloadersRequest = loadersRequest\n\t\t\t\t\t\t.substr(i)\n\t\t\t\t\t\t.replace(/!+$/, \"\")\n\t\t\t\t\t\t.replace(/!!+/g, \"!\");\n\t\t\t\t\tif (loadersRequest === \"\") {\n\t\t\t\t\t\tloaders = [];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tloaders = loadersRequest.split(\"!\");\n\t\t\t\t\t}\n\t\t\t\t\tresource = request.substr(idx + 1);\n\t\t\t\t} else {\n\t\t\t\t\tloaders = [];\n\t\t\t\t\tresource = request;\n\t\t\t\t}\n\n\t\t\t\tconst contextResolver = this.resolverFactory.get(\n\t\t\t\t\t\"context\",\n\t\t\t\t\tresolveOptions || EMPTY_RESOLVE_OPTIONS\n\t\t\t\t);\n\t\t\t\tconst loaderResolver = this.resolverFactory.get(\n\t\t\t\t\t\"loader\",\n\t\t\t\t\tEMPTY_RESOLVE_OPTIONS\n\t\t\t\t);\n\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tcontextResolver.resolve(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tasyncLib.map(\n\t\t\t\t\t\t\t\tloaders,\n\t\t\t\t\t\t\t\t(loader, callback) => {\n\t\t\t\t\t\t\t\t\tloaderResolver.resolve(\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tthis.hooks.afterResolve.callAsync(\n\t\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\taddon:\n\t\t\t\t\t\t\t\t\t\tloadersPrefix +\n\t\t\t\t\t\t\t\t\t\tresult[1].join(\"!\") +\n\t\t\t\t\t\t\t\t\t\t(result[1].length > 0 ? \"!\" : \"\"),\n\t\t\t\t\t\t\t\t\tresource: result[0],\n\t\t\t\t\t\t\t\t\tresolveDependencies: this.resolveDependencies.bind(this)\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tbeforeResolveResult\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t// Ignored\n\t\t\t\t\t\t\t\tif (!result) return callback();\n\n\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tnew ContextModule(result.resolveDependencies, result)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\tresolveDependencies(fs, options, callback) {\n\t\tconst cmf = this;\n\t\tlet resource = options.resource;\n\t\tlet resourceQuery = options.resourceQuery;\n\t\tlet recursive = options.recursive;\n\t\tlet regExp = options.regExp;\n\t\tlet include = options.include;\n\t\tlet exclude = options.exclude;\n\t\tif (!regExp || !resource) return callback(null, []);\n\n\t\tconst addDirectory = (directory, callback) => {\n\t\t\tfs.readdir(directory, (err, files) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tfiles = cmf.hooks.contextModuleFiles.call(files);\n\t\t\t\tif (!files || files.length === 0) return callback(null, []);\n\t\t\t\tasyncLib.map(\n\t\t\t\t\tfiles.filter(p => p.indexOf(\".\") !== 0),\n\t\t\t\t\t(segment, callback) => {\n\t\t\t\t\t\tconst subResource = path.join(directory, segment);\n\n\t\t\t\t\t\tif (!exclude || !subResource.match(exclude)) {\n\t\t\t\t\t\t\tfs.stat(subResource, (err, stat) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\t\t// ENOENT is ok here because the file may have been deleted between\n\t\t\t\t\t\t\t\t\t\t// the readdir and stat calls.\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tif (!recursive) return callback();\n\t\t\t\t\t\t\t\t\taddDirectory.call(this, subResource, callback);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tstat.isFile() &&\n\t\t\t\t\t\t\t\t\t(!include || subResource.match(include))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\tcontext: resource,\n\t\t\t\t\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\t\t\t\t\t\".\" +\n\t\t\t\t\t\t\t\t\t\t\tsubResource.substr(resource.length).replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.hooks.alternatives.callAsync(\n\t\t\t\t\t\t\t\t\t\t[obj],\n\t\t\t\t\t\t\t\t\t\t(err, alternatives) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\talternatives = alternatives\n\t\t\t\t\t\t\t\t\t\t\t\t.filter(obj => regExp.test(obj.request))\n\t\t\t\t\t\t\t\t\t\t\t\t.map(obj => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new ContextElementDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request + resourceQuery,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn dep;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, alternatives);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (!result) return callback(null, []);\n\n\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tresult.filter(Boolean).reduce((a, i) => a.concat(i), [])\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\taddDirectory(resource, callback);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}