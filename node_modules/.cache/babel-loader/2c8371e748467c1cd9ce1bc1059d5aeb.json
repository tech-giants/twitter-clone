{"ast":null,"code":"import { traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { encodeU32 } from \"@webassemblyjs/wasm-gen/lib/encoder\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\n\nfunction shiftFollowingSections(ast, _ref, deltaInSizeEncoding) {\n  var section = _ref.section; // Once we hit our section every that is after needs to be shifted by the delta\n\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaInSizeEncoding);\n      }\n    }\n  });\n}\n\nexport function shrinkPaddedLEB128(ast, uint8Buffer) {\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(_ref2) {\n      var node = _ref2.node;\n      /**\n       * Section size\n       */\n\n      {\n        var newu32Encoded = encodeU32(node.size.value);\n        var newu32EncodedLen = newu32Encoded.length;\n        var start = node.size.loc.start.column;\n        var end = node.size.loc.end.column;\n        var oldu32EncodedLen = end - start;\n\n        if (newu32EncodedLen !== oldu32EncodedLen) {\n          var deltaInSizeEncoding = oldu32EncodedLen - newu32EncodedLen;\n          uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newu32Encoded);\n          shiftFollowingSections(ast, node, -deltaInSizeEncoding);\n        }\n      }\n    }\n  });\n  return uint8Buffer;\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/wasm-opt/esm/leb128.js"],"names":["traverse","shiftSection","encodeU32","overrideBytesInBuffer","shiftFollowingSections","ast","_ref","deltaInSizeEncoding","section","encounteredSection","SectionMetadata","path","node","shrinkPaddedLEB128","uint8Buffer","_ref2","newu32Encoded","size","value","newu32EncodedLen","length","start","loc","column","end","oldu32EncodedLen"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,YAAnB,QAAuC,oBAAvC;AACA,SAASC,SAAT,QAA0B,qCAA1B;AACA,SAASC,qBAAT,QAAsC,8BAAtC;;AAEA,SAASC,sBAAT,CAAgCC,GAAhC,EAAqCC,IAArC,EAA2CC,mBAA3C,EAAgE;AAC9D,MAAIC,OAAO,GAAGF,IAAI,CAACE,OAAnB,CAD8D,CAE9D;;AACA,MAAIC,kBAAkB,GAAG,KAAzB;AACAT,EAAAA,QAAQ,CAACK,GAAD,EAAM;AACZK,IAAAA,eAAe,EAAE,SAASA,eAAT,CAAyBC,IAAzB,EAA+B;AAC9C,UAAIA,IAAI,CAACC,IAAL,CAAUJ,OAAV,KAAsBA,OAA1B,EAAmC;AACjCC,QAAAA,kBAAkB,GAAG,IAArB;AACA;AACD;;AAED,UAAIA,kBAAkB,KAAK,IAA3B,EAAiC;AAC/BR,QAAAA,YAAY,CAACI,GAAD,EAAMM,IAAI,CAACC,IAAX,EAAiBL,mBAAjB,CAAZ;AACD;AACF;AAVW,GAAN,CAAR;AAYD;;AAED,OAAO,SAASM,kBAAT,CAA4BR,GAA5B,EAAiCS,WAAjC,EAA8C;AACnDd,EAAAA,QAAQ,CAACK,GAAD,EAAM;AACZK,IAAAA,eAAe,EAAE,SAASA,eAAT,CAAyBK,KAAzB,EAAgC;AAC/C,UAAIH,IAAI,GAAGG,KAAK,CAACH,IAAjB;AAEA;AACN;AACA;;AACM;AACE,YAAII,aAAa,GAAGd,SAAS,CAACU,IAAI,CAACK,IAAL,CAAUC,KAAX,CAA7B;AACA,YAAIC,gBAAgB,GAAGH,aAAa,CAACI,MAArC;AACA,YAAIC,KAAK,GAAGT,IAAI,CAACK,IAAL,CAAUK,GAAV,CAAcD,KAAd,CAAoBE,MAAhC;AACA,YAAIC,GAAG,GAAGZ,IAAI,CAACK,IAAL,CAAUK,GAAV,CAAcE,GAAd,CAAkBD,MAA5B;AACA,YAAIE,gBAAgB,GAAGD,GAAG,GAAGH,KAA7B;;AAEA,YAAIF,gBAAgB,KAAKM,gBAAzB,EAA2C;AACzC,cAAIlB,mBAAmB,GAAGkB,gBAAgB,GAAGN,gBAA7C;AACAL,UAAAA,WAAW,GAAGX,qBAAqB,CAACW,WAAD,EAAcO,KAAd,EAAqBG,GAArB,EAA0BR,aAA1B,CAAnC;AACAZ,UAAAA,sBAAsB,CAACC,GAAD,EAAMO,IAAN,EAAY,CAACL,mBAAb,CAAtB;AACD;AACF;AACF;AApBW,GAAN,CAAR;AAsBA,SAAOO,WAAP;AACD","sourcesContent":["import { traverse, shiftSection } from \"@webassemblyjs/ast\";\nimport { encodeU32 } from \"@webassemblyjs/wasm-gen/lib/encoder\";\nimport { overrideBytesInBuffer } from \"@webassemblyjs/helper-buffer\";\n\nfunction shiftFollowingSections(ast, _ref, deltaInSizeEncoding) {\n  var section = _ref.section;\n  // Once we hit our section every that is after needs to be shifted by the delta\n  var encounteredSection = false;\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(path) {\n      if (path.node.section === section) {\n        encounteredSection = true;\n        return;\n      }\n\n      if (encounteredSection === true) {\n        shiftSection(ast, path.node, deltaInSizeEncoding);\n      }\n    }\n  });\n}\n\nexport function shrinkPaddedLEB128(ast, uint8Buffer) {\n  traverse(ast, {\n    SectionMetadata: function SectionMetadata(_ref2) {\n      var node = _ref2.node;\n\n      /**\n       * Section size\n       */\n      {\n        var newu32Encoded = encodeU32(node.size.value);\n        var newu32EncodedLen = newu32Encoded.length;\n        var start = node.size.loc.start.column;\n        var end = node.size.loc.end.column;\n        var oldu32EncodedLen = end - start;\n\n        if (newu32EncodedLen !== oldu32EncodedLen) {\n          var deltaInSizeEncoding = oldu32EncodedLen - newu32EncodedLen;\n          uint8Buffer = overrideBytesInBuffer(uint8Buffer, start, end, newu32Encoded);\n          shiftFollowingSections(ast, node, -deltaInSizeEncoding);\n        }\n      }\n    }\n  });\n  return uint8Buffer;\n}"]},"metadata":{},"sourceType":"module"}