{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass Hook {\n  constructor(args) {\n    if (!Array.isArray(args)) args = [];\n    this._args = args;\n    this.taps = [];\n    this.interceptors = [];\n    this.call = this._call;\n    this.promise = this._promise;\n    this.callAsync = this._callAsync;\n    this._x = undefined;\n  }\n\n  compile(options) {\n    throw new Error(\"Abstract: should be overriden\");\n  }\n\n  _createCall(type) {\n    return this.compile({\n      taps: this.taps,\n      interceptors: this.interceptors,\n      args: this._args,\n      type: type\n    });\n  }\n\n  tap(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tap(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"sync\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tap\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  tapAsync(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapAsync(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"async\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapAsync\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  tapPromise(options, fn) {\n    if (typeof options === \"string\") options = {\n      name: options\n    };\n    if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapPromise(options: Object, fn: function)\");\n    options = Object.assign({\n      type: \"promise\",\n      fn: fn\n    }, options);\n    if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapPromise\");\n    options = this._runRegisterInterceptors(options);\n\n    this._insert(options);\n  }\n\n  _runRegisterInterceptors(options) {\n    for (const interceptor of this.interceptors) {\n      if (interceptor.register) {\n        const newOptions = interceptor.register(options);\n        if (newOptions !== undefined) options = newOptions;\n      }\n    }\n\n    return options;\n  }\n\n  withOptions(options) {\n    const mergeOptions = opt => Object.assign({}, options, typeof opt === \"string\" ? {\n      name: opt\n    } : opt); // Prevent creating endless prototype chains\n\n\n    options = Object.assign({}, options, this._withOptions);\n    const base = this._withOptionsBase || this;\n    const newHook = Object.create(base);\n    newHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn), newHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn);\n\n    newHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn);\n\n    newHook._withOptions = options;\n    newHook._withOptionsBase = base;\n    return newHook;\n  }\n\n  isUsed() {\n    return this.taps.length > 0 || this.interceptors.length > 0;\n  }\n\n  intercept(interceptor) {\n    this._resetCompilation();\n\n    this.interceptors.push(Object.assign({}, interceptor));\n\n    if (interceptor.register) {\n      for (let i = 0; i < this.taps.length; i++) this.taps[i] = interceptor.register(this.taps[i]);\n    }\n  }\n\n  _resetCompilation() {\n    this.call = this._call;\n    this.callAsync = this._callAsync;\n    this.promise = this._promise;\n  }\n\n  _insert(item) {\n    this._resetCompilation();\n\n    let before;\n    if (typeof item.before === \"string\") before = new Set([item.before]);else if (Array.isArray(item.before)) {\n      before = new Set(item.before);\n    }\n    let stage = 0;\n    if (typeof item.stage === \"number\") stage = item.stage;\n    let i = this.taps.length;\n\n    while (i > 0) {\n      i--;\n      const x = this.taps[i];\n      this.taps[i + 1] = x;\n      const xStage = x.stage || 0;\n\n      if (before) {\n        if (before.has(x.name)) {\n          before.delete(x.name);\n          continue;\n        }\n\n        if (before.size > 0) {\n          continue;\n        }\n      }\n\n      if (xStage > stage) {\n        continue;\n      }\n\n      i++;\n      break;\n    }\n\n    this.taps[i] = item;\n  }\n\n}\n\nfunction createCompileDelegate(name, type) {\n  return function lazyCompileHook(...args) {\n    this[name] = this._createCall(type);\n    return this[name](...args);\n  };\n}\n\nObject.defineProperties(Hook.prototype, {\n  _call: {\n    value: createCompileDelegate(\"call\", \"sync\"),\n    configurable: true,\n    writable: true\n  },\n  _promise: {\n    value: createCompileDelegate(\"promise\", \"promise\"),\n    configurable: true,\n    writable: true\n  },\n  _callAsync: {\n    value: createCompileDelegate(\"callAsync\", \"async\"),\n    configurable: true,\n    writable: true\n  }\n});\nmodule.exports = Hook;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/tapable/lib/Hook.js"],"names":["Hook","constructor","args","Array","isArray","_args","taps","interceptors","call","_call","promise","_promise","callAsync","_callAsync","_x","undefined","compile","options","Error","_createCall","type","tap","fn","name","Object","assign","_runRegisterInterceptors","_insert","tapAsync","tapPromise","interceptor","register","newOptions","withOptions","mergeOptions","opt","_withOptions","base","_withOptionsBase","newHook","create","isUsed","length","intercept","_resetCompilation","push","i","item","before","Set","stage","x","xStage","has","delete","size","createCompileDelegate","lazyCompileHook","defineProperties","prototype","value","configurable","writable","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,IAAN,CAAW;AACVC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACjB,QAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAL,EAA0BA,IAAI,GAAG,EAAP;AAC1B,SAAKG,KAAL,GAAaH,IAAb;AACA,SAAKI,IAAL,GAAY,EAAZ;AACA,SAAKC,YAAL,GAAoB,EAApB;AACA,SAAKC,IAAL,GAAY,KAAKC,KAAjB;AACA,SAAKC,OAAL,GAAe,KAAKC,QAApB;AACA,SAAKC,SAAL,GAAiB,KAAKC,UAAtB;AACA,SAAKC,EAAL,GAAUC,SAAV;AACA;;AAEDC,EAAAA,OAAO,CAACC,OAAD,EAAU;AAChB,UAAM,IAAIC,KAAJ,CAAU,+BAAV,CAAN;AACA;;AAEDC,EAAAA,WAAW,CAACC,IAAD,EAAO;AACjB,WAAO,KAAKJ,OAAL,CAAa;AACnBV,MAAAA,IAAI,EAAE,KAAKA,IADQ;AAEnBC,MAAAA,YAAY,EAAE,KAAKA,YAFA;AAGnBL,MAAAA,IAAI,EAAE,KAAKG,KAHQ;AAInBe,MAAAA,IAAI,EAAEA;AAJa,KAAb,CAAP;AAMA;;AAEDC,EAAAA,GAAG,CAACJ,OAAD,EAAUK,EAAV,EAAc;AAChB,QAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiCA,OAAO,GAAG;AAAEM,MAAAA,IAAI,EAAEN;AAAR,KAAV;AACjC,QAAI,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACC,MAAM,IAAIC,KAAJ,CACL,yDADK,CAAN;AAGDD,IAAAA,OAAO,GAAGO,MAAM,CAACC,MAAP,CAAc;AAAEL,MAAAA,IAAI,EAAE,MAAR;AAAgBE,MAAAA,EAAE,EAAEA;AAApB,KAAd,EAAwCL,OAAxC,CAAV;AACA,QAAI,OAAOA,OAAO,CAACM,IAAf,KAAwB,QAAxB,IAAoCN,OAAO,CAACM,IAAR,KAAiB,EAAzD,EACC,MAAM,IAAIL,KAAJ,CAAU,sBAAV,CAAN;AACDD,IAAAA,OAAO,GAAG,KAAKS,wBAAL,CAA8BT,OAA9B,CAAV;;AACA,SAAKU,OAAL,CAAaV,OAAb;AACA;;AAEDW,EAAAA,QAAQ,CAACX,OAAD,EAAUK,EAAV,EAAc;AACrB,QAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiCA,OAAO,GAAG;AAAEM,MAAAA,IAAI,EAAEN;AAAR,KAAV;AACjC,QAAI,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACC,MAAM,IAAIC,KAAJ,CACL,8DADK,CAAN;AAGDD,IAAAA,OAAO,GAAGO,MAAM,CAACC,MAAP,CAAc;AAAEL,MAAAA,IAAI,EAAE,OAAR;AAAiBE,MAAAA,EAAE,EAAEA;AAArB,KAAd,EAAyCL,OAAzC,CAAV;AACA,QAAI,OAAOA,OAAO,CAACM,IAAf,KAAwB,QAAxB,IAAoCN,OAAO,CAACM,IAAR,KAAiB,EAAzD,EACC,MAAM,IAAIL,KAAJ,CAAU,2BAAV,CAAN;AACDD,IAAAA,OAAO,GAAG,KAAKS,wBAAL,CAA8BT,OAA9B,CAAV;;AACA,SAAKU,OAAL,CAAaV,OAAb;AACA;;AAEDY,EAAAA,UAAU,CAACZ,OAAD,EAAUK,EAAV,EAAc;AACvB,QAAI,OAAOL,OAAP,KAAmB,QAAvB,EAAiCA,OAAO,GAAG;AAAEM,MAAAA,IAAI,EAAEN;AAAR,KAAV;AACjC,QAAI,OAAOA,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,KAAK,IAA/C,EACC,MAAM,IAAIC,KAAJ,CACL,gEADK,CAAN;AAGDD,IAAAA,OAAO,GAAGO,MAAM,CAACC,MAAP,CAAc;AAAEL,MAAAA,IAAI,EAAE,SAAR;AAAmBE,MAAAA,EAAE,EAAEA;AAAvB,KAAd,EAA2CL,OAA3C,CAAV;AACA,QAAI,OAAOA,OAAO,CAACM,IAAf,KAAwB,QAAxB,IAAoCN,OAAO,CAACM,IAAR,KAAiB,EAAzD,EACC,MAAM,IAAIL,KAAJ,CAAU,6BAAV,CAAN;AACDD,IAAAA,OAAO,GAAG,KAAKS,wBAAL,CAA8BT,OAA9B,CAAV;;AACA,SAAKU,OAAL,CAAaV,OAAb;AACA;;AAEDS,EAAAA,wBAAwB,CAACT,OAAD,EAAU;AACjC,SAAK,MAAMa,WAAX,IAA0B,KAAKvB,YAA/B,EAA6C;AAC5C,UAAIuB,WAAW,CAACC,QAAhB,EAA0B;AACzB,cAAMC,UAAU,GAAGF,WAAW,CAACC,QAAZ,CAAqBd,OAArB,CAAnB;AACA,YAAIe,UAAU,KAAKjB,SAAnB,EAA8BE,OAAO,GAAGe,UAAV;AAC9B;AACD;;AACD,WAAOf,OAAP;AACA;;AAEDgB,EAAAA,WAAW,CAAChB,OAAD,EAAU;AACpB,UAAMiB,YAAY,GAAGC,GAAG,IACvBX,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBR,OAAlB,EAA2B,OAAOkB,GAAP,KAAe,QAAf,GAA0B;AAAEZ,MAAAA,IAAI,EAAEY;AAAR,KAA1B,GAA0CA,GAArE,CADD,CADoB,CAIpB;;;AACAlB,IAAAA,OAAO,GAAGO,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBR,OAAlB,EAA2B,KAAKmB,YAAhC,CAAV;AACA,UAAMC,IAAI,GAAG,KAAKC,gBAAL,IAAyB,IAAtC;AACA,UAAMC,OAAO,GAAGf,MAAM,CAACgB,MAAP,CAAcH,IAAd,CAAhB;AAECE,IAAAA,OAAO,CAACX,QAAR,GAAmB,CAACO,GAAD,EAAMb,EAAN,KAAae,IAAI,CAACT,QAAL,CAAcM,YAAY,CAACC,GAAD,CAA1B,EAAiCb,EAAjC,CAAjC,EACEiB,OAAO,CAAClB,GAAR,GAAc,CAACc,GAAD,EAAMb,EAAN,KAAae,IAAI,CAAChB,GAAL,CAASa,YAAY,CAACC,GAAD,CAArB,EAA4Bb,EAA5B,CAD7B;;AAEAiB,IAAAA,OAAO,CAACV,UAAR,GAAqB,CAACM,GAAD,EAAMb,EAAN,KAAae,IAAI,CAACR,UAAL,CAAgBK,YAAY,CAACC,GAAD,CAA5B,EAAmCb,EAAnC,CAAlC;;AACAiB,IAAAA,OAAO,CAACH,YAAR,GAAuBnB,OAAvB;AACAsB,IAAAA,OAAO,CAACD,gBAAR,GAA2BD,IAA3B;AACA,WAAOE,OAAP;AACA;;AAEDE,EAAAA,MAAM,GAAG;AACR,WAAO,KAAKnC,IAAL,CAAUoC,MAAV,GAAmB,CAAnB,IAAwB,KAAKnC,YAAL,CAAkBmC,MAAlB,GAA2B,CAA1D;AACA;;AAEDC,EAAAA,SAAS,CAACb,WAAD,EAAc;AACtB,SAAKc,iBAAL;;AACA,SAAKrC,YAAL,CAAkBsC,IAAlB,CAAuBrB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBK,WAAlB,CAAvB;;AACA,QAAIA,WAAW,CAACC,QAAhB,EAA0B;AACzB,WAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKxC,IAAL,CAAUoC,MAA9B,EAAsCI,CAAC,EAAvC,EACC,KAAKxC,IAAL,CAAUwC,CAAV,IAAehB,WAAW,CAACC,QAAZ,CAAqB,KAAKzB,IAAL,CAAUwC,CAAV,CAArB,CAAf;AACD;AACD;;AAEDF,EAAAA,iBAAiB,GAAG;AACnB,SAAKpC,IAAL,GAAY,KAAKC,KAAjB;AACA,SAAKG,SAAL,GAAiB,KAAKC,UAAtB;AACA,SAAKH,OAAL,GAAe,KAAKC,QAApB;AACA;;AAEDgB,EAAAA,OAAO,CAACoB,IAAD,EAAO;AACb,SAAKH,iBAAL;;AACA,QAAII,MAAJ;AACA,QAAI,OAAOD,IAAI,CAACC,MAAZ,KAAuB,QAA3B,EAAqCA,MAAM,GAAG,IAAIC,GAAJ,CAAQ,CAACF,IAAI,CAACC,MAAN,CAAR,CAAT,CAArC,KACK,IAAI7C,KAAK,CAACC,OAAN,CAAc2C,IAAI,CAACC,MAAnB,CAAJ,EAAgC;AACpCA,MAAAA,MAAM,GAAG,IAAIC,GAAJ,CAAQF,IAAI,CAACC,MAAb,CAAT;AACA;AACD,QAAIE,KAAK,GAAG,CAAZ;AACA,QAAI,OAAOH,IAAI,CAACG,KAAZ,KAAsB,QAA1B,EAAoCA,KAAK,GAAGH,IAAI,CAACG,KAAb;AACpC,QAAIJ,CAAC,GAAG,KAAKxC,IAAL,CAAUoC,MAAlB;;AACA,WAAOI,CAAC,GAAG,CAAX,EAAc;AACbA,MAAAA,CAAC;AACD,YAAMK,CAAC,GAAG,KAAK7C,IAAL,CAAUwC,CAAV,CAAV;AACA,WAAKxC,IAAL,CAAUwC,CAAC,GAAG,CAAd,IAAmBK,CAAnB;AACA,YAAMC,MAAM,GAAGD,CAAC,CAACD,KAAF,IAAW,CAA1B;;AACA,UAAIF,MAAJ,EAAY;AACX,YAAIA,MAAM,CAACK,GAAP,CAAWF,CAAC,CAAC5B,IAAb,CAAJ,EAAwB;AACvByB,UAAAA,MAAM,CAACM,MAAP,CAAcH,CAAC,CAAC5B,IAAhB;AACA;AACA;;AACD,YAAIyB,MAAM,CAACO,IAAP,GAAc,CAAlB,EAAqB;AACpB;AACA;AACD;;AACD,UAAIH,MAAM,GAAGF,KAAb,EAAoB;AACnB;AACA;;AACDJ,MAAAA,CAAC;AACD;AACA;;AACD,SAAKxC,IAAL,CAAUwC,CAAV,IAAeC,IAAf;AACA;;AA7IS;;AAgJX,SAASS,qBAAT,CAA+BjC,IAA/B,EAAqCH,IAArC,EAA2C;AAC1C,SAAO,SAASqC,eAAT,CAAyB,GAAGvD,IAA5B,EAAkC;AACxC,SAAKqB,IAAL,IAAa,KAAKJ,WAAL,CAAiBC,IAAjB,CAAb;AACA,WAAO,KAAKG,IAAL,EAAW,GAAGrB,IAAd,CAAP;AACA,GAHD;AAIA;;AAEDsB,MAAM,CAACkC,gBAAP,CAAwB1D,IAAI,CAAC2D,SAA7B,EAAwC;AACvClD,EAAAA,KAAK,EAAE;AACNmD,IAAAA,KAAK,EAAEJ,qBAAqB,CAAC,MAAD,EAAS,MAAT,CADtB;AAENK,IAAAA,YAAY,EAAE,IAFR;AAGNC,IAAAA,QAAQ,EAAE;AAHJ,GADgC;AAMvCnD,EAAAA,QAAQ,EAAE;AACTiD,IAAAA,KAAK,EAAEJ,qBAAqB,CAAC,SAAD,EAAY,SAAZ,CADnB;AAETK,IAAAA,YAAY,EAAE,IAFL;AAGTC,IAAAA,QAAQ,EAAE;AAHD,GAN6B;AAWvCjD,EAAAA,UAAU,EAAE;AACX+C,IAAAA,KAAK,EAAEJ,qBAAqB,CAAC,WAAD,EAAc,OAAd,CADjB;AAEXK,IAAAA,YAAY,EAAE,IAFH;AAGXC,IAAAA,QAAQ,EAAE;AAHC;AAX2B,CAAxC;AAkBAC,MAAM,CAACC,OAAP,GAAiBhE,IAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass Hook {\n\tconstructor(args) {\n\t\tif (!Array.isArray(args)) args = [];\n\t\tthis._args = args;\n\t\tthis.taps = [];\n\t\tthis.interceptors = [];\n\t\tthis.call = this._call;\n\t\tthis.promise = this._promise;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis._x = undefined;\n\t}\n\n\tcompile(options) {\n\t\tthrow new Error(\"Abstract: should be overriden\");\n\t}\n\n\t_createCall(type) {\n\t\treturn this.compile({\n\t\t\ttaps: this.taps,\n\t\t\tinterceptors: this.interceptors,\n\t\t\targs: this._args,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\ttap(options, fn) {\n\t\tif (typeof options === \"string\") options = { name: options };\n\t\tif (typeof options !== \"object\" || options === null)\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid arguments to tap(options: Object, fn: function)\"\n\t\t\t);\n\t\toptions = Object.assign({ type: \"sync\", fn: fn }, options);\n\t\tif (typeof options.name !== \"string\" || options.name === \"\")\n\t\t\tthrow new Error(\"Missing name for tap\");\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttapAsync(options, fn) {\n\t\tif (typeof options === \"string\") options = { name: options };\n\t\tif (typeof options !== \"object\" || options === null)\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid arguments to tapAsync(options: Object, fn: function)\"\n\t\t\t);\n\t\toptions = Object.assign({ type: \"async\", fn: fn }, options);\n\t\tif (typeof options.name !== \"string\" || options.name === \"\")\n\t\t\tthrow new Error(\"Missing name for tapAsync\");\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttapPromise(options, fn) {\n\t\tif (typeof options === \"string\") options = { name: options };\n\t\tif (typeof options !== \"object\" || options === null)\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid arguments to tapPromise(options: Object, fn: function)\"\n\t\t\t);\n\t\toptions = Object.assign({ type: \"promise\", fn: fn }, options);\n\t\tif (typeof options.name !== \"string\" || options.name === \"\")\n\t\t\tthrow new Error(\"Missing name for tapPromise\");\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\t_runRegisterInterceptors(options) {\n\t\tfor (const interceptor of this.interceptors) {\n\t\t\tif (interceptor.register) {\n\t\t\t\tconst newOptions = interceptor.register(options);\n\t\t\t\tif (newOptions !== undefined) options = newOptions;\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\twithOptions(options) {\n\t\tconst mergeOptions = opt =>\n\t\t\tObject.assign({}, options, typeof opt === \"string\" ? { name: opt } : opt);\n\n\t\t// Prevent creating endless prototype chains\n\t\toptions = Object.assign({}, options, this._withOptions);\n\t\tconst base = this._withOptionsBase || this;\n\t\tconst newHook = Object.create(base);\n\n\t\t(newHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn)),\n\t\t\t(newHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn));\n\t\tnewHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn);\n\t\tnewHook._withOptions = options;\n\t\tnewHook._withOptionsBase = base;\n\t\treturn newHook;\n\t}\n\n\tisUsed() {\n\t\treturn this.taps.length > 0 || this.interceptors.length > 0;\n\t}\n\n\tintercept(interceptor) {\n\t\tthis._resetCompilation();\n\t\tthis.interceptors.push(Object.assign({}, interceptor));\n\t\tif (interceptor.register) {\n\t\t\tfor (let i = 0; i < this.taps.length; i++)\n\t\t\t\tthis.taps[i] = interceptor.register(this.taps[i]);\n\t\t}\n\t}\n\n\t_resetCompilation() {\n\t\tthis.call = this._call;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis.promise = this._promise;\n\t}\n\n\t_insert(item) {\n\t\tthis._resetCompilation();\n\t\tlet before;\n\t\tif (typeof item.before === \"string\") before = new Set([item.before]);\n\t\telse if (Array.isArray(item.before)) {\n\t\t\tbefore = new Set(item.before);\n\t\t}\n\t\tlet stage = 0;\n\t\tif (typeof item.stage === \"number\") stage = item.stage;\n\t\tlet i = this.taps.length;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tconst x = this.taps[i];\n\t\t\tthis.taps[i + 1] = x;\n\t\t\tconst xStage = x.stage || 0;\n\t\t\tif (before) {\n\t\t\t\tif (before.has(x.name)) {\n\t\t\t\t\tbefore.delete(x.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (before.size > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xStage > stage) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tthis.taps[i] = item;\n\t}\n}\n\nfunction createCompileDelegate(name, type) {\n\treturn function lazyCompileHook(...args) {\n\t\tthis[name] = this._createCall(type);\n\t\treturn this[name](...args);\n\t};\n}\n\nObject.defineProperties(Hook.prototype, {\n\t_call: {\n\t\tvalue: createCompileDelegate(\"call\", \"sync\"),\n\t\tconfigurable: true,\n\t\twritable: true\n\t},\n\t_promise: {\n\t\tvalue: createCompileDelegate(\"promise\", \"promise\"),\n\t\tconfigurable: true,\n\t\twritable: true\n\t},\n\t_callAsync: {\n\t\tvalue: createCompileDelegate(\"callAsync\", \"async\"),\n\t\tconfigurable: true,\n\t\twritable: true\n\t}\n});\n\nmodule.exports = Hook;\n"]},"metadata":{},"sourceType":"script"}