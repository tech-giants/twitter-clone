{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nvar extend = require('extend-shallow');\n\nvar unique = require('array-unique');\n\nvar toRegex = require('to-regex');\n/**\n * Local dependencies\n */\n\n\nvar compilers = require('./lib/compilers');\n\nvar parsers = require('./lib/parsers');\n\nvar Extglob = require('./lib/extglob');\n\nvar utils = require('./lib/utils');\n\nvar MAX_LENGTH = 1024 * 64;\n/**\n * Convert the given `extglob` pattern into a regex-compatible string. Returns\n * an object with the compiled result and the parsed AST.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob('*.!(*a)'));\n * //=> '(?!\\\\.)[^/]*?\\\\.(?!(?!\\\\.)[^/]*?a\\\\b).*?'\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nfunction extglob(pattern, options) {\n  return extglob.create(pattern, options).output;\n}\n/**\n * Takes an array of strings and an extglob pattern and returns a new\n * array that contains only the strings that match the pattern.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));\n * //=> ['a.b', 'a.c']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Extglob pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of matches\n * @api public\n */\n\n\nextglob.match = function (list, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  list = utils.arrayify(list);\n  var isMatch = extglob.matcher(pattern, options);\n  var len = list.length;\n  var idx = -1;\n  var matches = [];\n\n  while (++idx < len) {\n    var ele = list[idx];\n\n    if (isMatch(ele)) {\n      matches.push(ele);\n    }\n  } // if no options were passed, uniquify results and return\n\n\n  if (typeof options === 'undefined') {\n    return unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return [pattern.split('\\\\').join('')];\n    }\n  }\n\n  return options.nodupes !== false ? unique(matches) : matches;\n};\n/**\n * Returns true if the specified `string` matches the given\n * extglob `pattern`.\n *\n * ```js\n * var extglob = require('extglob');\n *\n * console.log(extglob.isMatch('a.a', '*.!(*a)'));\n * //=> false\n * console.log(extglob.isMatch('a.b', '*.!(*a)'));\n * //=> true\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Extglob pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\n\nextglob.isMatch = function (str, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  if (pattern === str) {\n    return true;\n  }\n\n  if (pattern === '' || pattern === ' ' || pattern === '.') {\n    return pattern === str;\n  }\n\n  var isMatch = utils.memoize('isMatch', pattern, options, extglob.matcher);\n  return isMatch(str);\n};\n/**\n * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but\n * the pattern can match any part of the string.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(extglob.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options`\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\n\nextglob.contains = function (str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  if (pattern === '' || pattern === ' ' || pattern === '.') {\n    return pattern === str;\n  }\n\n  var opts = extend({}, options, {\n    contains: true\n  });\n  opts.strictClose = false;\n  opts.strictOpen = false;\n  return extglob.isMatch(str, pattern, opts);\n};\n/**\n * Takes an extglob pattern and returns a matcher function. The returned\n * function takes the string to match as its only argument.\n *\n * ```js\n * var extglob = require('extglob');\n * var isMatch = extglob.matcher('*.!(*a)');\n *\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Extglob pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\n\nextglob.matcher = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  function matcher() {\n    var re = extglob.makeRe(pattern, options);\n    return function (str) {\n      return re.test(str);\n    };\n  }\n\n  return utils.memoize('matcher', pattern, options, matcher);\n};\n/**\n * Convert the given `extglob` pattern into a regex-compatible string. Returns\n * an object with the compiled result and the parsed AST.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob.create('*.!(*a)').output);\n * //=> '(?!\\\\.)[^/]*?\\\\.(?!(?!\\\\.)[^/]*?a\\\\b).*?'\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\n\nextglob.create = function (pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  function create() {\n    var ext = new Extglob(options);\n    var ast = ext.parse(pattern, options);\n    return ext.compile(ast, options);\n  }\n\n  return utils.memoize('create', pattern, options, create);\n};\n/**\n * Returns an array of matches captured by `pattern` in `string`, or `null`\n * if the pattern did not match.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob.capture(pattern, string[, options]);\n *\n * console.log(extglob.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(extglob.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\n\nextglob.capture = function (pattern, str, options) {\n  var re = extglob.makeRe(pattern, extend({\n    capture: true\n  }, options));\n\n  function match() {\n    return function (string) {\n      var match = re.exec(string);\n\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = utils.memoize('capture', pattern, options, match);\n  return capture(str);\n};\n/**\n * Create a regular expression from the given `pattern` and `options`.\n *\n * ```js\n * var extglob = require('extglob');\n * var re = extglob.makeRe('*.!(*a)');\n * console.log(re);\n * //=> /^[^\\/]*?\\.(?![^\\/]*?a)[^\\/]*?$/\n * ```\n * @param {String} `pattern` The pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\n\nextglob.makeRe = function (pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var opts = extend({\n      strictErrors: false\n    }, options);\n    if (opts.strictErrors === true) opts.strict = true;\n    var res = extglob.create(pattern, opts);\n    return toRegex(res.output, opts);\n  }\n\n  var regex = utils.memoize('makeRe', pattern, options, makeRe);\n\n  if (regex.source.length > MAX_LENGTH) {\n    throw new SyntaxError('potentially malicious regex detected');\n  }\n\n  return regex;\n};\n/**\n * Cache\n */\n\n\nextglob.cache = utils.cache;\n\nextglob.clearCache = function () {\n  extglob.cache.__data__ = {};\n};\n/**\n * Expose `Extglob` constructor, parsers and compilers\n */\n\n\nextglob.Extglob = Extglob;\nextglob.compilers = compilers;\nextglob.parsers = parsers;\n/**\n * Expose `extglob`\n * @type {Function}\n */\n\nmodule.exports = extglob;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/extglob/index.js"],"names":["extend","require","unique","toRegex","compilers","parsers","Extglob","utils","MAX_LENGTH","extglob","pattern","options","create","output","match","list","TypeError","arrayify","isMatch","matcher","len","length","idx","matches","ele","push","failglob","Error","nonull","nullglob","split","join","nodupes","str","memoize","contains","opts","strictClose","strictOpen","re","makeRe","test","ext","ast","parse","compile","capture","string","exec","slice","RegExp","strictErrors","strict","res","regex","source","SyntaxError","cache","clearCache","__data__","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Module dependencies\n */\n\nvar extend = require('extend-shallow');\nvar unique = require('array-unique');\nvar toRegex = require('to-regex');\n\n/**\n * Local dependencies\n */\n\nvar compilers = require('./lib/compilers');\nvar parsers = require('./lib/parsers');\nvar Extglob = require('./lib/extglob');\nvar utils = require('./lib/utils');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * Convert the given `extglob` pattern into a regex-compatible string. Returns\n * an object with the compiled result and the parsed AST.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob('*.!(*a)'));\n * //=> '(?!\\\\.)[^/]*?\\\\.(?!(?!\\\\.)[^/]*?a\\\\b).*?'\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nfunction extglob(pattern, options) {\n  return extglob.create(pattern, options).output;\n}\n\n/**\n * Takes an array of strings and an extglob pattern and returns a new\n * array that contains only the strings that match the pattern.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob.match(['a.a', 'a.b', 'a.c'], '*.!(*a)'));\n * //=> ['a.b', 'a.c']\n * ```\n * @param {Array} `list` Array of strings to match\n * @param {String} `pattern` Extglob pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of matches\n * @api public\n */\n\nextglob.match = function(list, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  list = utils.arrayify(list);\n  var isMatch = extglob.matcher(pattern, options);\n  var len = list.length;\n  var idx = -1;\n  var matches = [];\n\n  while (++idx < len) {\n    var ele = list[idx];\n\n    if (isMatch(ele)) {\n      matches.push(ele);\n    }\n  }\n\n  // if no options were passed, uniquify results and return\n  if (typeof options === 'undefined') {\n    return unique(matches);\n  }\n\n  if (matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error('no matches found for \"' + pattern + '\"');\n    }\n    if (options.nonull === true || options.nullglob === true) {\n      return [pattern.split('\\\\').join('')];\n    }\n  }\n\n  return options.nodupes !== false ? unique(matches) : matches;\n};\n\n/**\n * Returns true if the specified `string` matches the given\n * extglob `pattern`.\n *\n * ```js\n * var extglob = require('extglob');\n *\n * console.log(extglob.isMatch('a.a', '*.!(*a)'));\n * //=> false\n * console.log(extglob.isMatch('a.b', '*.!(*a)'));\n * //=> true\n * ```\n * @param {String} `string` String to match\n * @param {String} `pattern` Extglob pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\nextglob.isMatch = function(str, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  if (pattern === str) {\n    return true;\n  }\n\n  if (pattern === '' || pattern === ' ' || pattern === '.') {\n    return pattern === str;\n  }\n\n  var isMatch = utils.memoize('isMatch', pattern, options, extglob.matcher);\n  return isMatch(str);\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar to `.isMatch` but\n * the pattern can match any part of the string.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(extglob.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {Object} `options`\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nextglob.contains = function(str, pattern, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  if (pattern === '' || pattern === ' ' || pattern === '.') {\n    return pattern === str;\n  }\n\n  var opts = extend({}, options, {contains: true});\n  opts.strictClose = false;\n  opts.strictOpen = false;\n  return extglob.isMatch(str, pattern, opts);\n};\n\n/**\n * Takes an extglob pattern and returns a matcher function. The returned\n * function takes the string to match as its only argument.\n *\n * ```js\n * var extglob = require('extglob');\n * var isMatch = extglob.matcher('*.!(*a)');\n *\n * console.log(isMatch('a.a'));\n * //=> false\n * console.log(isMatch('a.b'));\n * //=> true\n * ```\n * @param {String} `pattern` Extglob pattern\n * @param {String} `options`\n * @return {Boolean}\n * @api public\n */\n\nextglob.matcher = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  function matcher() {\n    var re = extglob.makeRe(pattern, options);\n    return function(str) {\n      return re.test(str);\n    };\n  }\n\n  return utils.memoize('matcher', pattern, options, matcher);\n};\n\n/**\n * Convert the given `extglob` pattern into a regex-compatible string. Returns\n * an object with the compiled result and the parsed AST.\n *\n * ```js\n * var extglob = require('extglob');\n * console.log(extglob.create('*.!(*a)').output);\n * //=> '(?!\\\\.)[^/]*?\\\\.(?!(?!\\\\.)[^/]*?a\\\\b).*?'\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nextglob.create = function(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  function create() {\n    var ext = new Extglob(options);\n    var ast = ext.parse(pattern, options);\n    return ext.compile(ast, options);\n  }\n\n  return utils.memoize('create', pattern, options, create);\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string`, or `null`\n * if the pattern did not match.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob.capture(pattern, string[, options]);\n *\n * console.log(extglob.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(extglob.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `pattern` Glob pattern to use for matching.\n * @param {String} `string` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the string matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nextglob.capture = function(pattern, str, options) {\n  var re = extglob.makeRe(pattern, extend({capture: true}, options));\n\n  function match() {\n    return function(string) {\n      var match = re.exec(string);\n      if (!match) {\n        return null;\n      }\n\n      return match.slice(1);\n    };\n  }\n\n  var capture = utils.memoize('capture', pattern, options, match);\n  return capture(str);\n};\n\n/**\n * Create a regular expression from the given `pattern` and `options`.\n *\n * ```js\n * var extglob = require('extglob');\n * var re = extglob.makeRe('*.!(*a)');\n * console.log(re);\n * //=> /^[^\\/]*?\\.(?![^\\/]*?a)[^\\/]*?$/\n * ```\n * @param {String} `pattern` The pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nextglob.makeRe = function(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected pattern to be a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  function makeRe() {\n    var opts = extend({strictErrors: false}, options);\n    if (opts.strictErrors === true) opts.strict = true;\n    var res = extglob.create(pattern, opts);\n    return toRegex(res.output, opts);\n  }\n\n  var regex = utils.memoize('makeRe', pattern, options, makeRe);\n  if (regex.source.length > MAX_LENGTH) {\n    throw new SyntaxError('potentially malicious regex detected');\n  }\n\n  return regex;\n};\n\n/**\n * Cache\n */\n\nextglob.cache = utils.cache;\nextglob.clearCache = function() {\n  extglob.cache.__data__ = {};\n};\n\n/**\n * Expose `Extglob` constructor, parsers and compilers\n */\n\nextglob.Extglob = Extglob;\nextglob.compilers = compilers;\nextglob.parsers = parsers;\n\n/**\n * Expose `extglob`\n * @type {Function}\n */\n\nmodule.exports = extglob;\n"]},"metadata":{},"sourceType":"script"}