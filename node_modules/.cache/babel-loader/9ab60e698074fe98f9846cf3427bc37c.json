{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\n\nconst ParserHelpers = require(\"./ParserHelpers\");\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst NullFactory = require(\"./NullFactory\");\n\nclass NodeStuffPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"NodeStuffPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n\n      const handler = (parser, parserOptions) => {\n        if (parserOptions.node === false) return;\n        let localOptions = options;\n\n        if (parserOptions.node) {\n          localOptions = Object.assign({}, localOptions, parserOptions.node);\n        }\n\n        const setConstant = (expressionName, value) => {\n          parser.hooks.expression.for(expressionName).tap(\"NodeStuffPlugin\", () => {\n            parser.state.current.addVariable(expressionName, JSON.stringify(value));\n            return true;\n          });\n        };\n\n        const setModuleConstant = (expressionName, fn) => {\n          parser.hooks.expression.for(expressionName).tap(\"NodeStuffPlugin\", () => {\n            parser.state.current.addVariable(expressionName, JSON.stringify(fn(parser.state.module)));\n            return true;\n          });\n        };\n\n        const context = compiler.context;\n\n        if (localOptions.__filename) {\n          if (localOptions.__filename === \"mock\") {\n            setConstant(\"__filename\", \"/index.js\");\n          } else {\n            setModuleConstant(\"__filename\", module => path.relative(context, module.resource));\n          }\n\n          parser.hooks.evaluateIdentifier.for(\"__filename\").tap(\"NodeStuffPlugin\", expr => {\n            if (!parser.state.module) return;\n            const resource = parser.state.module.resource;\n            const i = resource.indexOf(\"?\");\n            return ParserHelpers.evaluateToString(i < 0 ? resource : resource.substr(0, i))(expr);\n          });\n        }\n\n        if (localOptions.__dirname) {\n          if (localOptions.__dirname === \"mock\") {\n            setConstant(\"__dirname\", \"/\");\n          } else {\n            setModuleConstant(\"__dirname\", module => path.relative(context, module.context));\n          }\n\n          parser.hooks.evaluateIdentifier.for(\"__dirname\").tap(\"NodeStuffPlugin\", expr => {\n            if (!parser.state.module) return;\n            return ParserHelpers.evaluateToString(parser.state.module.context)(expr);\n          });\n        }\n\n        parser.hooks.expression.for(\"require.extensions\").tap(\"NodeStuffPlugin\", ParserHelpers.expressionIsUnsupported(parser, \"require.extensions is not supported by webpack. Use a loader instead.\"));\n      };\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"NodeStuffPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"NodeStuffPlugin\", handler);\n    });\n  }\n\n}\n\nmodule.exports = NodeStuffPlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/NodeStuffPlugin.js"],"names":["path","require","ParserHelpers","ConstDependency","NullFactory","NodeStuffPlugin","constructor","options","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","handler","parser","parserOptions","node","localOptions","Object","assign","setConstant","expressionName","value","expression","for","state","current","addVariable","JSON","stringify","setModuleConstant","fn","module","context","__filename","relative","resource","evaluateIdentifier","expr","i","indexOf","evaluateToString","substr","__dirname","expressionIsUnsupported","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst NullFactory = require(\"./NullFactory\");\n\nclass NodeStuffPlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"NodeStuffPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(ConstDependency, new NullFactory());\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\tconst handler = (parser, parserOptions) => {\n\t\t\t\t\tif (parserOptions.node === false) return;\n\n\t\t\t\t\tlet localOptions = options;\n\t\t\t\t\tif (parserOptions.node) {\n\t\t\t\t\t\tlocalOptions = Object.assign({}, localOptions, parserOptions.node);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst setConstant = (expressionName, value) => {\n\t\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t\t.for(expressionName)\n\t\t\t\t\t\t\t.tap(\"NodeStuffPlugin\", () => {\n\t\t\t\t\t\t\t\tparser.state.current.addVariable(\n\t\t\t\t\t\t\t\t\texpressionName,\n\t\t\t\t\t\t\t\t\tJSON.stringify(value)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tconst setModuleConstant = (expressionName, fn) => {\n\t\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t\t.for(expressionName)\n\t\t\t\t\t\t\t.tap(\"NodeStuffPlugin\", () => {\n\t\t\t\t\t\t\t\tparser.state.current.addVariable(\n\t\t\t\t\t\t\t\t\texpressionName,\n\t\t\t\t\t\t\t\t\tJSON.stringify(fn(parser.state.module))\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tconst context = compiler.context;\n\t\t\t\t\tif (localOptions.__filename) {\n\t\t\t\t\t\tif (localOptions.__filename === \"mock\") {\n\t\t\t\t\t\t\tsetConstant(\"__filename\", \"/index.js\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetModuleConstant(\"__filename\", module =>\n\t\t\t\t\t\t\t\tpath.relative(context, module.resource)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(\"__filename\")\n\t\t\t\t\t\t\t.tap(\"NodeStuffPlugin\", expr => {\n\t\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\t\tconst resource = parser.state.module.resource;\n\t\t\t\t\t\t\t\tconst i = resource.indexOf(\"?\");\n\t\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\n\t\t\t\t\t\t\t\t\ti < 0 ? resource : resource.substr(0, i)\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (localOptions.__dirname) {\n\t\t\t\t\t\tif (localOptions.__dirname === \"mock\") {\n\t\t\t\t\t\t\tsetConstant(\"__dirname\", \"/\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsetModuleConstant(\"__dirname\", module =>\n\t\t\t\t\t\t\t\tpath.relative(context, module.context)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(\"__dirname\")\n\t\t\t\t\t\t\t.tap(\"NodeStuffPlugin\", expr => {\n\t\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\n\t\t\t\t\t\t\t\t\tparser.state.module.context\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"require.extensions\")\n\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\"NodeStuffPlugin\",\n\t\t\t\t\t\t\tParserHelpers.expressionIsUnsupported(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\"require.extensions is not supported by webpack. Use a loader instead.\"\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"NodeStuffPlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"NodeStuffPlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = NodeStuffPlugin;\n"]},"metadata":{},"sourceType":"script"}