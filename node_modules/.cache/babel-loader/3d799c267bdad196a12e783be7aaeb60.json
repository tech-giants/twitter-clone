{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\n\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n\nconst validateOptions = require(\"schema-utils\");\n\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n  return module => {\n    oldChunk.moveModule(module, newChunk);\n  };\n};\n\nconst isNotAEntryModule = entryModule => {\n  return module => {\n    return entryModule !== module;\n  };\n};\n\nclass AggressiveSplittingPlugin {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Aggressive Splitting Plugin\");\n    this.options = options;\n\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", compilation => {\n      let needAdditionalSeal = false;\n      let newSplits;\n      let fromAggressiveSplittingSet;\n      let chunkSplitDataMap;\n      compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n        newSplits = [];\n        fromAggressiveSplittingSet = new Set();\n        chunkSplitDataMap = new Map();\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"AggressiveSplittingPlugin\", chunks => {\n        // Precompute stuff\n        const nameToModuleMap = new Map();\n        const moduleToNameMap = new Map();\n\n        for (const m of compilation.modules) {\n          const name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);\n          nameToModuleMap.set(name, m);\n          moduleToNameMap.set(m, name);\n        } // Check used chunk ids\n\n\n        const usedIds = new Set();\n\n        for (const chunk of chunks) {\n          usedIds.add(chunk.id);\n        }\n\n        const recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n        const usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n        const minSize = this.options.minSize;\n        const maxSize = this.options.maxSize;\n\n        const applySplit = splitData => {\n          // Cannot split if id is already taken\n          if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n            return false;\n          } // Get module objects from names\n\n\n          const selectedModules = splitData.modules.map(name => nameToModuleMap.get(name)); // Does the modules exist at all?\n\n          if (!selectedModules.every(Boolean)) return false; // Check if size matches (faster than waiting for hash)\n\n          const size = selectedModules.reduce((sum, m) => sum + m.size(), 0);\n          if (size !== splitData.size) return false; // get chunks with all modules\n\n          const selectedChunks = intersect(selectedModules.map(m => new Set(m.chunksIterable))); // No relevant chunks found\n\n          if (selectedChunks.size === 0) return false; // The found chunk is already the split or similar\n\n          if (selectedChunks.size === 1 && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {\n            const chunk = Array.from(selectedChunks)[0];\n            if (fromAggressiveSplittingSet.has(chunk)) return false;\n            fromAggressiveSplittingSet.add(chunk);\n            chunkSplitDataMap.set(chunk, splitData);\n            return true;\n          } // split the chunk into two parts\n\n\n          const newChunk = compilation.addChunk();\n          newChunk.chunkReason = \"aggressive splitted\";\n\n          for (const chunk of selectedChunks) {\n            selectedModules.forEach(moveModuleBetween(chunk, newChunk));\n            chunk.split(newChunk);\n            chunk.name = null;\n          }\n\n          fromAggressiveSplittingSet.add(newChunk);\n          chunkSplitDataMap.set(newChunk, splitData);\n\n          if (splitData.id !== null && splitData.id !== undefined) {\n            newChunk.id = splitData.id;\n          }\n\n          return true;\n        }; // try to restore to recorded splitting\n\n\n        let changed = false;\n\n        for (let j = 0; j < usedSplits.length; j++) {\n          const splitData = usedSplits[j];\n          if (applySplit(splitData)) changed = true;\n        } // for any chunk which isn't splitted yet, split it and create a new entry\n        // start with the biggest chunk\n\n\n        const sortedChunks = chunks.slice().sort((a, b) => {\n          const diff1 = b.modulesSize() - a.modulesSize();\n          if (diff1) return diff1;\n          const diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n          if (diff2) return diff2;\n          const modulesA = Array.from(a.modulesIterable);\n          const modulesB = Array.from(b.modulesIterable);\n          modulesA.sort();\n          modulesB.sort();\n          const aI = modulesA[Symbol.iterator]();\n          const bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n          while (true) {\n            const aItem = aI.next();\n            const bItem = bI.next();\n            if (aItem.done) return 0;\n            const aModuleIdentifier = aItem.value.identifier();\n            const bModuleIdentifier = bItem.value.identifier();\n            if (aModuleIdentifier > bModuleIdentifier) return -1;\n            if (aModuleIdentifier < bModuleIdentifier) return 1;\n          }\n        });\n\n        for (const chunk of sortedChunks) {\n          if (fromAggressiveSplittingSet.has(chunk)) continue;\n          const size = chunk.modulesSize();\n\n          if (size > maxSize && chunk.getNumberOfModules() > 1) {\n            const modules = chunk.getModules().filter(isNotAEntryModule(chunk.entryModule)).sort((a, b) => {\n              a = a.identifier();\n              b = b.identifier();\n              if (a > b) return 1;\n              if (a < b) return -1;\n              return 0;\n            });\n            const selectedModules = [];\n            let selectedModulesSize = 0;\n\n            for (let k = 0; k < modules.length; k++) {\n              const module = modules[k];\n              const newSize = selectedModulesSize + module.size();\n\n              if (newSize > maxSize && selectedModulesSize >= minSize) {\n                break;\n              }\n\n              selectedModulesSize = newSize;\n              selectedModules.push(module);\n            }\n\n            if (selectedModules.length === 0) continue;\n            const splitData = {\n              modules: selectedModules.map(m => moduleToNameMap.get(m)).sort(),\n              size: selectedModulesSize\n            };\n\n            if (applySplit(splitData)) {\n              newSplits = (newSplits || []).concat(splitData);\n              changed = true;\n            }\n          }\n        }\n\n        if (changed) return true;\n      });\n      compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", records => {\n        // 4. save made splittings to records\n        const allSplits = new Set();\n        const invalidSplits = new Set(); // Check if some splittings are invalid\n        // We remove invalid splittings and try again\n\n        for (const chunk of compilation.chunks) {\n          const splitData = chunkSplitDataMap.get(chunk);\n\n          if (splitData !== undefined) {\n            if (splitData.hash && chunk.hash !== splitData.hash) {\n              // Split was successful, but hash doesn't equal\n              // We can throw away the split since it's useless now\n              invalidSplits.add(splitData);\n            }\n          }\n        }\n\n        if (invalidSplits.size > 0) {\n          records.aggressiveSplits = records.aggressiveSplits.filter(splitData => !invalidSplits.has(splitData));\n          needAdditionalSeal = true;\n        } else {\n          // set hash and id values on all (new) splittings\n          for (const chunk of compilation.chunks) {\n            const splitData = chunkSplitDataMap.get(chunk);\n\n            if (splitData !== undefined) {\n              splitData.hash = chunk.hash;\n              splitData.id = chunk.id;\n              allSplits.add(splitData); // set flag for stats\n\n              chunk.recorded = true;\n            }\n          } // Also add all unused historial splits (after the used ones)\n          // They can still be used in some future compilation\n\n\n          const recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n\n          if (recordedSplits) {\n            for (const splitData of recordedSplits) {\n              if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n            }\n          } // record all splits\n\n\n          records.aggressiveSplits = Array.from(allSplits);\n          needAdditionalSeal = false;\n        }\n      });\n      compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", () => {\n        if (needAdditionalSeal) {\n          needAdditionalSeal = false;\n          return true;\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"names":["identifierUtils","require","intersect","validateOptions","schema","moveModuleBetween","oldChunk","newChunk","module","moveModule","isNotAEntryModule","entryModule","AggressiveSplittingPlugin","constructor","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","apply","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunksAdvanced","chunks","nameToModuleMap","moduleToNameMap","m","modules","name","makePathsRelative","context","identifier","cache","set","usedIds","chunk","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","has","selectedModules","map","get","every","Boolean","size","reduce","sum","selectedChunks","chunksIterable","Array","from","getNumberOfModules","length","addChunk","chunkReason","forEach","split","changed","j","sortedChunks","slice","sort","a","b","diff1","modulesSize","diff2","modulesA","modulesIterable","modulesB","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","getModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","recorded","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n\treturn module => {\n\t\toldChunk.moveModule(module, newChunk);\n\t};\n};\n\nconst isNotAEntryModule = entryModule => {\n\treturn module => {\n\t\treturn entryModule !== module;\n\t};\n};\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Aggressive Splitting Plugin\");\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tm.identifier(),\n\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tconst size = selectedModules.reduce(\n\t\t\t\t\t\t\t\t(sum, m) => sum + m.size(),\n\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(m => new Set(m.chunksIterable))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0].getNumberOfModules() ===\n\t\t\t\t\t\t\t\t\tselectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(moveModuleBetween(chunk, newChunk));\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst sortedChunks = chunks.slice().sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 = b.modulesSize() - a.modulesSize();\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\tconst modulesA = Array.from(a.modulesIterable);\n\t\t\t\t\t\t\tconst modulesB = Array.from(b.modulesIterable);\n\t\t\t\t\t\t\tmodulesA.sort();\n\t\t\t\t\t\t\tmodulesB.sort();\n\t\t\t\t\t\t\tconst aI = modulesA[Symbol.iterator]();\n\t\t\t\t\t\t\tconst bI = modulesB[Symbol.iterator]();\n\t\t\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst aItem = aI.next();\n\t\t\t\t\t\t\t\tconst bItem = bI.next();\n\t\t\t\t\t\t\t\tif (aItem.done) return 0;\n\t\t\t\t\t\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\t\t\t\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\t\t\t\t\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\t\t\t\t\t\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunk.modulesSize();\n\t\t\t\t\t\t\tif (size > maxSize && chunk.getNumberOfModules() > 1) {\n\t\t\t\t\t\t\t\tconst modules = chunk\n\t\t\t\t\t\t\t\t\t.getModules()\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunk.entryModule))\n\t\t\t\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t\t\t\ta = a.identifier();\n\t\t\t\t\t\t\t\t\t\tb = b.identifier();\n\t\t\t\t\t\t\t\t\t\tif (a > b) return 1;\n\t\t\t\t\t\t\t\t\t\tif (a < b) return -1;\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\tchunk.recorded = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historial splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"]},"metadata":{},"sourceType":"script"}