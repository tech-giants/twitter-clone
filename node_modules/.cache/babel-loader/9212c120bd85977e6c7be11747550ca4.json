{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n      REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n      REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n      REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n      REGEXP_NAME = /\\[name\\]/gi,\n      REGEXP_ID = /\\[id\\]/gi,\n      REGEXP_MODULEID = /\\[moduleid\\]/gi,\n      REGEXP_FILE = /\\[file\\]/gi,\n      REGEXP_QUERY = /\\[query\\]/gi,\n      REGEXP_FILEBASE = /\\[filebase\\]/gi,\n      REGEXP_URL = /\\[url\\]/gi; // Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\n\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n      REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n      REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n      REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nconst withHashLength = (replacer, handlerFn, assetInfo) => {\n  const fn = (match, hashLength, ...args) => {\n    if (assetInfo) assetInfo.immutable = true;\n    const length = hashLength && parseInt(hashLength, 10);\n\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n\n    const hash = replacer(match, hashLength, ...args);\n    return length ? hash.slice(0, length) : hash;\n  };\n\n  return fn;\n};\n\nconst getReplacer = (value, allowEmpty) => {\n  const fn = (match, ...args) => {\n    // last argument in replacer is the entire input string\n    const input = args[args.length - 1];\n\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(`Path variable ${match} not implemented in this context: ${input}`);\n      }\n\n      return \"\";\n    } else {\n      return `${escapePathVariables(value)}`;\n    }\n  };\n\n  return fn;\n};\n\nconst escapePathVariables = value => {\n  return typeof value === \"string\" ? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\") : value;\n};\n\nconst replacePathVariables = (path, data, assetInfo) => {\n  const chunk = data.chunk;\n  const chunkId = chunk && chunk.id;\n  const chunkName = chunk && (chunk.name || chunk.id);\n  const chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  const chunkHashWithLength = chunk && chunk.hashWithLength;\n  const contentHashType = data.contentHashType;\n  const contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  const contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  const module = data.module;\n  const moduleId = module && module.id;\n  const moduleHash = module && (module.renderedHash || module.hash);\n  const moduleHashWithLength = module && module.hashWithLength;\n\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`);\n  }\n\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename)) // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true)) // only available in sourceMappingURLComment\n  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\");\n};\n\nclass TemplatedPathPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n      const mainTemplate = compilation.mainTemplate;\n      mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n      mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", (chunk, paths) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const publicPath = outputOptions.publicPath || \"\";\n        const filename = outputOptions.filename || \"\";\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n        if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n        if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n      });\n      mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", (hash, chunk) => {\n        const outputOptions = mainTemplate.outputOptions;\n        const chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n\n        if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n        }\n\n        if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n        }\n\n        if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n          hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = TemplatedPathPlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/TemplatedPathPlugin.js"],"names":["REGEXP_HASH","REGEXP_CHUNKHASH","REGEXP_MODULEHASH","REGEXP_CONTENTHASH","REGEXP_NAME","REGEXP_ID","REGEXP_MODULEID","REGEXP_FILE","REGEXP_QUERY","REGEXP_FILEBASE","REGEXP_URL","REGEXP_HASH_FOR_TEST","RegExp","source","REGEXP_CHUNKHASH_FOR_TEST","REGEXP_CONTENTHASH_FOR_TEST","REGEXP_NAME_FOR_TEST","withHashLength","replacer","handlerFn","assetInfo","fn","match","hashLength","args","immutable","length","parseInt","hash","slice","getReplacer","value","allowEmpty","input","undefined","Error","escapePathVariables","replace","replacePathVariables","path","data","chunk","chunkId","id","chunkName","name","chunkHash","renderedHash","chunkHashWithLength","hashWithLength","contentHashType","contentHash","contentHashWithLength","module","moduleId","moduleHash","moduleHashWithLength","noChunkHash","test","filename","basename","query","url","TemplatedPathPlugin","apply","compiler","hooks","compilation","tap","mainTemplate","assetPath","globalHash","paths","outputOptions","publicPath","chunkFilename","join","hashForChunk","update","JSON","stringify","getChunkMaps","javascript","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,WAAW,GAAG,uBAApB;AAAA,MACCC,gBAAgB,GAAG,4BADpB;AAAA,MAECC,iBAAiB,GAAG,6BAFrB;AAAA,MAGCC,kBAAkB,GAAG,8BAHtB;AAAA,MAICC,WAAW,GAAG,YAJf;AAAA,MAKCC,SAAS,GAAG,UALb;AAAA,MAMCC,eAAe,GAAG,gBANnB;AAAA,MAOCC,WAAW,GAAG,YAPf;AAAA,MAQCC,YAAY,GAAG,aARhB;AAAA,MASCC,eAAe,GAAG,gBATnB;AAAA,MAUCC,UAAU,GAAG,WAVd,C,CAYA;AACA;;AACA,MAAMC,oBAAoB,GAAG,IAAIC,MAAJ,CAAWZ,WAAW,CAACa,MAAvB,EAA+B,GAA/B,CAA7B;AAAA,MACCC,yBAAyB,GAAG,IAAIF,MAAJ,CAAWX,gBAAgB,CAACY,MAA5B,EAAoC,GAApC,CAD7B;AAAA,MAECE,2BAA2B,GAAG,IAAIH,MAAJ,CAAWT,kBAAkB,CAACU,MAA9B,EAAsC,GAAtC,CAF/B;AAAA,MAGCG,oBAAoB,GAAG,IAAIJ,MAAJ,CAAWR,WAAW,CAACS,MAAvB,EAA+B,GAA/B,CAHxB;;AAKA,MAAMI,cAAc,GAAG,CAACC,QAAD,EAAWC,SAAX,EAAsBC,SAAtB,KAAoC;AAC1D,QAAMC,EAAE,GAAG,CAACC,KAAD,EAAQC,UAAR,EAAoB,GAAGC,IAAvB,KAAgC;AAC1C,QAAIJ,SAAJ,EAAeA,SAAS,CAACK,SAAV,GAAsB,IAAtB;AACf,UAAMC,MAAM,GAAGH,UAAU,IAAII,QAAQ,CAACJ,UAAD,EAAa,EAAb,CAArC;;AACA,QAAIG,MAAM,IAAIP,SAAd,EAAyB;AACxB,aAAOA,SAAS,CAACO,MAAD,CAAhB;AACA;;AACD,UAAME,IAAI,GAAGV,QAAQ,CAACI,KAAD,EAAQC,UAAR,EAAoB,GAAGC,IAAvB,CAArB;AACA,WAAOE,MAAM,GAAGE,IAAI,CAACC,KAAL,CAAW,CAAX,EAAcH,MAAd,CAAH,GAA2BE,IAAxC;AACA,GARD;;AASA,SAAOP,EAAP;AACA,CAXD;;AAaA,MAAMS,WAAW,GAAG,CAACC,KAAD,EAAQC,UAAR,KAAuB;AAC1C,QAAMX,EAAE,GAAG,CAACC,KAAD,EAAQ,GAAGE,IAAX,KAAoB;AAC9B;AACA,UAAMS,KAAK,GAAGT,IAAI,CAACA,IAAI,CAACE,MAAL,GAAc,CAAf,CAAlB;;AACA,QAAIK,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKG,SAAhC,EAA2C;AAC1C,UAAI,CAACF,UAAL,EAAiB;AAChB,cAAM,IAAIG,KAAJ,CACJ,iBAAgBb,KAAM,qCAAoCW,KAAM,EAD5D,CAAN;AAGA;;AACD,aAAO,EAAP;AACA,KAPD,MAOO;AACN,aAAQ,GAAEG,mBAAmB,CAACL,KAAD,CAAQ,EAArC;AACA;AACD,GAbD;;AAcA,SAAOV,EAAP;AACA,CAhBD;;AAkBA,MAAMe,mBAAmB,GAAGL,KAAK,IAAI;AACpC,SAAO,OAAOA,KAAP,KAAiB,QAAjB,GACJA,KAAK,CAACM,OAAN,CAAc,sBAAd,EAAsC,UAAtC,CADI,GAEJN,KAFH;AAGA,CAJD;;AAMA,MAAMO,oBAAoB,GAAG,CAACC,IAAD,EAAOC,IAAP,EAAapB,SAAb,KAA2B;AACvD,QAAMqB,KAAK,GAAGD,IAAI,CAACC,KAAnB;AACA,QAAMC,OAAO,GAAGD,KAAK,IAAIA,KAAK,CAACE,EAA/B;AACA,QAAMC,SAAS,GAAGH,KAAK,KAAKA,KAAK,CAACI,IAAN,IAAcJ,KAAK,CAACE,EAAzB,CAAvB;AACA,QAAMG,SAAS,GAAGL,KAAK,KAAKA,KAAK,CAACM,YAAN,IAAsBN,KAAK,CAACb,IAAjC,CAAvB;AACA,QAAMoB,mBAAmB,GAAGP,KAAK,IAAIA,KAAK,CAACQ,cAA3C;AACA,QAAMC,eAAe,GAAGV,IAAI,CAACU,eAA7B;AACA,QAAMC,WAAW,GACfV,KAAK,IAAIA,KAAK,CAACU,WAAf,IAA8BV,KAAK,CAACU,WAAN,CAAkBD,eAAlB,CAA/B,IACAV,IAAI,CAACW,WAFN;AAGA,QAAMC,qBAAqB,GACzBX,KAAK,IACLA,KAAK,CAACW,qBADN,IAEAX,KAAK,CAACW,qBAAN,CAA4BF,eAA5B,CAFD,IAGAV,IAAI,CAACY,qBAJN;AAKA,QAAMC,MAAM,GAAGb,IAAI,CAACa,MAApB;AACA,QAAMC,QAAQ,GAAGD,MAAM,IAAIA,MAAM,CAACV,EAAlC;AACA,QAAMY,UAAU,GAAGF,MAAM,KAAKA,MAAM,CAACN,YAAP,IAAuBM,MAAM,CAACzB,IAAnC,CAAzB;AACA,QAAM4B,oBAAoB,GAAGH,MAAM,IAAIA,MAAM,CAACJ,cAA9C;;AAEA,MAAI,OAAOV,IAAP,KAAgB,UAApB,EAAgC;AAC/BA,IAAAA,IAAI,GAAGA,IAAI,CAACC,IAAD,CAAX;AACA;;AAED,MACCA,IAAI,CAACiB,WAAL,KACC3C,yBAAyB,CAAC4C,IAA1B,CAA+BnB,IAA/B,KACAxB,2BAA2B,CAAC2C,IAA5B,CAAiCnB,IAAjC,CAFD,CADD,EAIE;AACD,UAAM,IAAIJ,KAAJ,CACJ,yDAAwDI,IAAK,wBADzD,CAAN;AAGA;;AAED,SACCA,IAAI,CACFF,OADF,CAEErC,WAFF,EAGEiB,cAAc,CAACa,WAAW,CAACU,IAAI,CAACZ,IAAN,CAAZ,EAAyBY,IAAI,CAACS,cAA9B,EAA8C7B,SAA9C,CAHhB,EAKEiB,OALF,CAMEpC,gBANF,EAOEgB,cAAc,CAACa,WAAW,CAACgB,SAAD,CAAZ,EAAyBE,mBAAzB,EAA8C5B,SAA9C,CAPhB,EASEiB,OATF,CAUElC,kBAVF,EAWEc,cAAc,CACba,WAAW,CAACqB,WAAD,CADE,EAEbC,qBAFa,EAGbhC,SAHa,CAXhB,EAiBEiB,OAjBF,CAkBEnC,iBAlBF,EAmBEe,cAAc,CAACa,WAAW,CAACyB,UAAD,CAAZ,EAA0BC,oBAA1B,EAAgDpC,SAAhD,CAnBhB,EAqBEiB,OArBF,CAqBUhC,SArBV,EAqBqByB,WAAW,CAACY,OAAD,CArBhC,EAsBEL,OAtBF,CAsBU/B,eAtBV,EAsB2BwB,WAAW,CAACwB,QAAD,CAtBtC,EAuBEjB,OAvBF,CAuBUjC,WAvBV,EAuBuB0B,WAAW,CAACc,SAAD,CAvBlC,EAwBEP,OAxBF,CAwBU9B,WAxBV,EAwBuBuB,WAAW,CAACU,IAAI,CAACmB,QAAN,CAxBlC,EAyBEtB,OAzBF,CAyBU5B,eAzBV,EAyB2BqB,WAAW,CAACU,IAAI,CAACoB,QAAN,CAzBtC,EA0BC;AA1BD,GA2BEvB,OA3BF,CA2BU7B,YA3BV,EA2BwBsB,WAAW,CAACU,IAAI,CAACqB,KAAN,EAAa,IAAb,CA3BnC,EA4BC;AA5BD,GA6BExB,OA7BF,CA6BU3B,UA7BV,EA6BsBoB,WAAW,CAACU,IAAI,CAACsB,GAAN,CA7BjC,EA8BEzB,OA9BF,CA8BU,0BA9BV,EA8BsC,MA9BtC,CADD;AAiCA,CAnED;;AAqEA,MAAM0B,mBAAN,CAA0B;AACzBC,EAAAA,KAAK,CAACC,QAAD,EAAW;AACfA,IAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,qBAA/B,EAAsDD,WAAW,IAAI;AACpE,YAAME,YAAY,GAAGF,WAAW,CAACE,YAAjC;AAEAA,MAAAA,YAAY,CAACH,KAAb,CAAmBI,SAAnB,CAA6BF,GAA7B,CACC,qBADD,EAEC9B,oBAFD;AAKA+B,MAAAA,YAAY,CAACH,KAAb,CAAmBK,UAAnB,CAA8BH,GAA9B,CACC,qBADD,EAEC,CAAC3B,KAAD,EAAQ+B,KAAR,KAAkB;AACjB,cAAMC,aAAa,GAAGJ,YAAY,CAACI,aAAnC;AACA,cAAMC,UAAU,GAAGD,aAAa,CAACC,UAAd,IAA4B,EAA/C;AACA,cAAMf,QAAQ,GAAGc,aAAa,CAACd,QAAd,IAA0B,EAA3C;AACA,cAAMgB,aAAa,GAClBF,aAAa,CAACE,aAAd,IAA+BF,aAAa,CAACd,QAD9C;AAEA,YACChD,oBAAoB,CAAC+C,IAArB,CAA0BgB,UAA1B,KACA5D,yBAAyB,CAAC4C,IAA1B,CAA+BgB,UAA/B,CADA,IAEA3D,2BAA2B,CAAC2C,IAA5B,CAAiCgB,UAAjC,CAFA,IAGA1D,oBAAoB,CAAC0C,IAArB,CAA0BgB,UAA1B,CAJD,EAMC,OAAO,IAAP;AACD,YAAI/D,oBAAoB,CAAC+C,IAArB,CAA0BC,QAA1B,CAAJ,EAAyC,OAAO,IAAP;AACzC,YAAIhD,oBAAoB,CAAC+C,IAArB,CAA0BiB,aAA1B,CAAJ,EAA8C,OAAO,IAAP;AAC9C,YAAIhE,oBAAoB,CAAC+C,IAArB,CAA0Bc,KAAK,CAACI,IAAN,CAAW,GAAX,CAA1B,CAAJ,EAAgD,OAAO,IAAP;AAChD,OAlBF;AAqBAP,MAAAA,YAAY,CAACH,KAAb,CAAmBW,YAAnB,CAAgCT,GAAhC,CACC,qBADD,EAEC,CAACxC,IAAD,EAAOa,KAAP,KAAiB;AAChB,cAAMgC,aAAa,GAAGJ,YAAY,CAACI,aAAnC;AACA,cAAME,aAAa,GAClBF,aAAa,CAACE,aAAd,IAA+BF,aAAa,CAACd,QAD9C;;AAEA,YAAI7C,yBAAyB,CAAC4C,IAA1B,CAA+BiB,aAA/B,CAAJ,EAAmD;AAClD/C,UAAAA,IAAI,CAACkD,MAAL,CAAYC,IAAI,CAACC,SAAL,CAAevC,KAAK,CAACwC,YAAN,CAAmB,IAAnB,EAAyBrD,IAAxC,CAAZ;AACA;;AACD,YAAIb,2BAA2B,CAAC2C,IAA5B,CAAiCiB,aAAjC,CAAJ,EAAqD;AACpD/C,UAAAA,IAAI,CAACkD,MAAL,CACCC,IAAI,CAACC,SAAL,CACCvC,KAAK,CAACwC,YAAN,CAAmB,IAAnB,EAAyB9B,WAAzB,CAAqC+B,UAArC,IAAmD,EADpD,CADD;AAKA;;AACD,YAAIlE,oBAAoB,CAAC0C,IAArB,CAA0BiB,aAA1B,CAAJ,EAA8C;AAC7C/C,UAAAA,IAAI,CAACkD,MAAL,CAAYC,IAAI,CAACC,SAAL,CAAevC,KAAK,CAACwC,YAAN,CAAmB,IAAnB,EAAyBpC,IAAxC,CAAZ;AACA;AACD,OAnBF;AAqBA,KAlDD;AAmDA;;AArDwB;;AAwD1BQ,MAAM,CAAC8B,OAAP,GAAiBpB,mBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n\tREGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n\tREGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n\tREGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n\tREGEXP_NAME = /\\[name\\]/gi,\n\tREGEXP_ID = /\\[id\\]/gi,\n\tREGEXP_MODULEID = /\\[moduleid\\]/gi,\n\tREGEXP_FILE = /\\[file\\]/gi,\n\tREGEXP_QUERY = /\\[query\\]/gi,\n\tREGEXP_FILEBASE = /\\[filebase\\]/gi,\n\tREGEXP_URL = /\\[url\\]/gi;\n\n// Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n\tREGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n\tREGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n\tREGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nconst withHashLength = (replacer, handlerFn, assetInfo) => {\n\tconst fn = (match, hashLength, ...args) => {\n\t\tif (assetInfo) assetInfo.immutable = true;\n\t\tconst length = hashLength && parseInt(hashLength, 10);\n\t\tif (length && handlerFn) {\n\t\t\treturn handlerFn(length);\n\t\t}\n\t\tconst hash = replacer(match, hashLength, ...args);\n\t\treturn length ? hash.slice(0, length) : hash;\n\t};\n\treturn fn;\n};\n\nconst getReplacer = (value, allowEmpty) => {\n\tconst fn = (match, ...args) => {\n\t\t// last argument in replacer is the entire input string\n\t\tconst input = args[args.length - 1];\n\t\tif (value === null || value === undefined) {\n\t\t\tif (!allowEmpty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Path variable ${match} not implemented in this context: ${input}`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn `${escapePathVariables(value)}`;\n\t\t}\n\t};\n\treturn fn;\n};\n\nconst escapePathVariables = value => {\n\treturn typeof value === \"string\"\n\t\t? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\")\n\t\t: value;\n};\n\nconst replacePathVariables = (path, data, assetInfo) => {\n\tconst chunk = data.chunk;\n\tconst chunkId = chunk && chunk.id;\n\tconst chunkName = chunk && (chunk.name || chunk.id);\n\tconst chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n\tconst chunkHashWithLength = chunk && chunk.hashWithLength;\n\tconst contentHashType = data.contentHashType;\n\tconst contentHash =\n\t\t(chunk && chunk.contentHash && chunk.contentHash[contentHashType]) ||\n\t\tdata.contentHash;\n\tconst contentHashWithLength =\n\t\t(chunk &&\n\t\t\tchunk.contentHashWithLength &&\n\t\t\tchunk.contentHashWithLength[contentHashType]) ||\n\t\tdata.contentHashWithLength;\n\tconst module = data.module;\n\tconst moduleId = module && module.id;\n\tconst moduleHash = module && (module.renderedHash || module.hash);\n\tconst moduleHashWithLength = module && module.hashWithLength;\n\n\tif (typeof path === \"function\") {\n\t\tpath = path(data);\n\t}\n\n\tif (\n\t\tdata.noChunkHash &&\n\t\t(REGEXP_CHUNKHASH_FOR_TEST.test(path) ||\n\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(path))\n\t) {\n\t\tthrow new Error(\n\t\t\t`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`\n\t\t);\n\t}\n\n\treturn (\n\t\tpath\n\t\t\t.replace(\n\t\t\t\tREGEXP_HASH,\n\t\t\t\twithHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CHUNKHASH,\n\t\t\t\twithHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CONTENTHASH,\n\t\t\t\twithHashLength(\n\t\t\t\t\tgetReplacer(contentHash),\n\t\t\t\t\tcontentHashWithLength,\n\t\t\t\t\tassetInfo\n\t\t\t\t)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_MODULEHASH,\n\t\t\t\twithHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(REGEXP_ID, getReplacer(chunkId))\n\t\t\t.replace(REGEXP_MODULEID, getReplacer(moduleId))\n\t\t\t.replace(REGEXP_NAME, getReplacer(chunkName))\n\t\t\t.replace(REGEXP_FILE, getReplacer(data.filename))\n\t\t\t.replace(REGEXP_FILEBASE, getReplacer(data.basename))\n\t\t\t// query is optional, it's OK if it's in a path but there's nothing to replace it with\n\t\t\t.replace(REGEXP_QUERY, getReplacer(data.query, true))\n\t\t\t// only available in sourceMappingURLComment\n\t\t\t.replace(REGEXP_URL, getReplacer(data.url))\n\t\t\t.replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\")\n\t);\n};\n\nclass TemplatedPathPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n\t\t\tconst mainTemplate = compilation.mainTemplate;\n\n\t\t\tmainTemplate.hooks.assetPath.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\treplacePathVariables\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.globalHash.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(chunk, paths) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst publicPath = outputOptions.publicPath || \"\";\n\t\t\t\t\tconst filename = outputOptions.filename || \"\";\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (\n\t\t\t\t\t\tREGEXP_HASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CHUNKHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_NAME_FOR_TEST.test(publicPath)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.hashForChunk.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(hash, chunk) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(\n\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\tchunk.getChunkMaps(true).contentHash.javascript || {}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = TemplatedPathPlugin;\n"]},"metadata":{},"sourceType":"script"}