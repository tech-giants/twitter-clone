{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\n\nfunction parseType(type) {\n  const items = type.split(\"+\");\n  const t = items.shift();\n  return {\n    type: t === \"*\" ? null : t,\n    features: items\n  };\n}\n\nfunction isTypeMatched(baseType, testedType) {\n  if (typeof baseType === \"string\") baseType = parseType(baseType);\n  if (typeof testedType === \"string\") testedType = parseType(testedType);\n  if (testedType.type && testedType.type !== baseType.type) return false;\n  return testedType.features.every(requiredFeature => {\n    return baseType.features.indexOf(requiredFeature) >= 0;\n  });\n}\n\nfunction isResourceTypeMatched(baseType, testedType) {\n  baseType = baseType.split(\"/\");\n  testedType = testedType.split(\"/\");\n  if (baseType.length !== testedType.length) return false;\n\n  for (let i = 0; i < baseType.length; i++) {\n    if (!isTypeMatched(baseType[i], testedType[i])) return false;\n  }\n\n  return true;\n}\n\nfunction isResourceTypeSupported(context, type) {\n  return context.supportedResourceTypes && context.supportedResourceTypes.some(supportedType => {\n    return isResourceTypeMatched(supportedType, type);\n  });\n}\n\nfunction isEnvironment(context, env) {\n  return context.environments && context.environments.every(environment => {\n    return isTypeMatched(environment, env);\n  });\n}\n\nconst globCache = {};\n\nfunction getGlobRegExp(glob) {\n  const regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n  return regExp;\n}\n\nfunction matchGlob(glob, relativePath) {\n  const regExp = getGlobRegExp(glob);\n  return regExp.exec(relativePath);\n}\n\nfunction isGlobMatched(glob, relativePath) {\n  return !!matchGlob(glob, relativePath);\n}\n\nfunction isConditionMatched(context, condition) {\n  const items = condition.split(\"|\");\n  return items.some(function testFn(item) {\n    item = item.trim();\n    const inverted = /^!/.test(item);\n    if (inverted) return !testFn(item.substr(1));\n\n    if (/^[a-z]+:/.test(item)) {\n      // match named condition\n      const match = /^([a-z]+):\\s*/.exec(item);\n      const value = item.substr(match[0].length);\n      const name = match[1];\n\n      switch (name) {\n        case \"referrer\":\n          return isGlobMatched(value, context.referrer);\n\n        default:\n          return false;\n      }\n    } else if (item.indexOf(\"/\") >= 0) {\n      // match supported type\n      return isResourceTypeSupported(context, item);\n    } else {\n      // match environment\n      return isEnvironment(context, item);\n    }\n  });\n}\n\nfunction isKeyMatched(context, key) {\n  for (;;) {\n    const match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n    if (!match) return key;\n    key = key.substr(match[0].length);\n    const condition = match[1];\n\n    if (!isConditionMatched(context, condition)) {\n      return false;\n    }\n  }\n}\n\nfunction getField(context, configuration, field) {\n  let value;\n  Object.keys(configuration).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n\n    if (pureKey === field) {\n      value = configuration[key];\n    }\n  });\n  return value;\n}\n\nfunction getMain(context, configuration) {\n  return getField(context, configuration, \"main\");\n}\n\nfunction getExtensions(context, configuration) {\n  return getField(context, configuration, \"extensions\");\n}\n\nfunction matchModule(context, configuration, request) {\n  const modulesField = getField(context, configuration, \"modules\");\n  if (!modulesField) return request;\n  let newRequest = request;\n  const keys = Object.keys(modulesField);\n  let iteration = 0;\n  let match;\n  let index;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const pureKey = isKeyMatched(context, key);\n    match = matchGlob(pureKey, newRequest);\n\n    if (match) {\n      const value = modulesField[key];\n\n      if (typeof value !== \"string\") {\n        return value;\n      } else if (/^\\(.+\\)$/.test(pureKey)) {\n        newRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n      } else {\n        index = 1;\n        newRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n      }\n\n      i = -1;\n\n      if (iteration++ > keys.length) {\n        throw new Error(\"Request '\" + request + \"' matches recursively\");\n      }\n    }\n  }\n\n  return newRequest;\n\n  function replaceMatcher(find) {\n    switch (find) {\n      case \"/**\":\n        {\n          const m = match[index++];\n          return m ? \"/\" + m : \"\";\n        }\n\n      case \"**\":\n      case \"*\":\n        return match[index++];\n    }\n  }\n}\n\nfunction matchType(context, configuration, relativePath) {\n  const typesField = getField(context, configuration, \"types\");\n  if (!typesField) return undefined;\n  let type;\n  Object.keys(typesField).forEach(key => {\n    const pureKey = isKeyMatched(context, key);\n\n    if (isGlobMatched(pureKey, relativePath)) {\n      const value = typesField[key];\n      if (!type && /\\/\\*$/.test(value)) throw new Error(\"value ('\" + value + \"') of key '\" + key + \"' contains '*', but there is no previous value defined\");\n      type = value.replace(/\\/\\*$/, \"/\" + type);\n    }\n  });\n  return type;\n}\n\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/enhanced-resolve/lib/concord.js"],"names":["globToRegExp","require","parseType","type","items","split","t","shift","features","isTypeMatched","baseType","testedType","every","requiredFeature","indexOf","isResourceTypeMatched","length","i","isResourceTypeSupported","context","supportedResourceTypes","some","supportedType","isEnvironment","env","environments","environment","globCache","getGlobRegExp","glob","regExp","matchGlob","relativePath","exec","isGlobMatched","isConditionMatched","condition","testFn","item","trim","inverted","test","substr","match","value","name","referrer","isKeyMatched","key","getField","configuration","field","Object","keys","forEach","pureKey","getMain","getExtensions","matchModule","request","modulesField","newRequest","iteration","index","replace","replaceMatcher","Error","find","m","matchType","typesField","undefined","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst globToRegExp = require(\"./globToRegExp\").globToRegExp;\n\nfunction parseType(type) {\n\tconst items = type.split(\"+\");\n\tconst t = items.shift();\n\treturn {\n\t\ttype: t === \"*\" ? null : t,\n\t\tfeatures: items\n\t};\n}\n\nfunction isTypeMatched(baseType, testedType) {\n\tif (typeof baseType === \"string\") baseType = parseType(baseType);\n\tif (typeof testedType === \"string\") testedType = parseType(testedType);\n\tif (testedType.type && testedType.type !== baseType.type) return false;\n\treturn testedType.features.every(requiredFeature => {\n\t\treturn baseType.features.indexOf(requiredFeature) >= 0;\n\t});\n}\n\nfunction isResourceTypeMatched(baseType, testedType) {\n\tbaseType = baseType.split(\"/\");\n\ttestedType = testedType.split(\"/\");\n\tif (baseType.length !== testedType.length) return false;\n\tfor (let i = 0; i < baseType.length; i++) {\n\t\tif (!isTypeMatched(baseType[i], testedType[i])) return false;\n\t}\n\treturn true;\n}\n\nfunction isResourceTypeSupported(context, type) {\n\treturn (\n\t\tcontext.supportedResourceTypes &&\n\t\tcontext.supportedResourceTypes.some(supportedType => {\n\t\t\treturn isResourceTypeMatched(supportedType, type);\n\t\t})\n\t);\n}\n\nfunction isEnvironment(context, env) {\n\treturn (\n\t\tcontext.environments &&\n\t\tcontext.environments.every(environment => {\n\t\t\treturn isTypeMatched(environment, env);\n\t\t})\n\t);\n}\n\nconst globCache = {};\n\nfunction getGlobRegExp(glob) {\n\tconst regExp = globCache[glob] || (globCache[glob] = globToRegExp(glob));\n\treturn regExp;\n}\n\nfunction matchGlob(glob, relativePath) {\n\tconst regExp = getGlobRegExp(glob);\n\treturn regExp.exec(relativePath);\n}\n\nfunction isGlobMatched(glob, relativePath) {\n\treturn !!matchGlob(glob, relativePath);\n}\n\nfunction isConditionMatched(context, condition) {\n\tconst items = condition.split(\"|\");\n\treturn items.some(function testFn(item) {\n\t\titem = item.trim();\n\t\tconst inverted = /^!/.test(item);\n\t\tif (inverted) return !testFn(item.substr(1));\n\t\tif (/^[a-z]+:/.test(item)) {\n\t\t\t// match named condition\n\t\t\tconst match = /^([a-z]+):\\s*/.exec(item);\n\t\t\tconst value = item.substr(match[0].length);\n\t\t\tconst name = match[1];\n\t\t\tswitch (name) {\n\t\t\t\tcase \"referrer\":\n\t\t\t\t\treturn isGlobMatched(value, context.referrer);\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (item.indexOf(\"/\") >= 0) {\n\t\t\t// match supported type\n\t\t\treturn isResourceTypeSupported(context, item);\n\t\t} else {\n\t\t\t// match environment\n\t\t\treturn isEnvironment(context, item);\n\t\t}\n\t});\n}\n\nfunction isKeyMatched(context, key) {\n\tfor (;;) {\n\t\tconst match = /^\\[([^\\]]+)\\]\\s*/.exec(key);\n\t\tif (!match) return key;\n\t\tkey = key.substr(match[0].length);\n\t\tconst condition = match[1];\n\t\tif (!isConditionMatched(context, condition)) {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\nfunction getField(context, configuration, field) {\n\tlet value;\n\tObject.keys(configuration).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (pureKey === field) {\n\t\t\tvalue = configuration[key];\n\t\t}\n\t});\n\treturn value;\n}\n\nfunction getMain(context, configuration) {\n\treturn getField(context, configuration, \"main\");\n}\n\nfunction getExtensions(context, configuration) {\n\treturn getField(context, configuration, \"extensions\");\n}\n\nfunction matchModule(context, configuration, request) {\n\tconst modulesField = getField(context, configuration, \"modules\");\n\tif (!modulesField) return request;\n\tlet newRequest = request;\n\tconst keys = Object.keys(modulesField);\n\tlet iteration = 0;\n\tlet match;\n\tlet index;\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tmatch = matchGlob(pureKey, newRequest);\n\t\tif (match) {\n\t\t\tconst value = modulesField[key];\n\t\t\tif (typeof value !== \"string\") {\n\t\t\t\treturn value;\n\t\t\t} else if (/^\\(.+\\)$/.test(pureKey)) {\n\t\t\t\tnewRequest = newRequest.replace(getGlobRegExp(pureKey), value);\n\t\t\t} else {\n\t\t\t\tindex = 1;\n\t\t\t\tnewRequest = value.replace(/(\\/?\\*)?\\*/g, replaceMatcher);\n\t\t\t}\n\t\t\ti = -1;\n\t\t\tif (iteration++ > keys.length) {\n\t\t\t\tthrow new Error(\"Request '\" + request + \"' matches recursively\");\n\t\t\t}\n\t\t}\n\t}\n\treturn newRequest;\n\n\tfunction replaceMatcher(find) {\n\t\tswitch (find) {\n\t\t\tcase \"/**\": {\n\t\t\t\tconst m = match[index++];\n\t\t\t\treturn m ? \"/\" + m : \"\";\n\t\t\t}\n\t\t\tcase \"**\":\n\t\t\tcase \"*\":\n\t\t\t\treturn match[index++];\n\t\t}\n\t}\n}\n\nfunction matchType(context, configuration, relativePath) {\n\tconst typesField = getField(context, configuration, \"types\");\n\tif (!typesField) return undefined;\n\tlet type;\n\tObject.keys(typesField).forEach(key => {\n\t\tconst pureKey = isKeyMatched(context, key);\n\t\tif (isGlobMatched(pureKey, relativePath)) {\n\t\t\tconst value = typesField[key];\n\t\t\tif (!type && /\\/\\*$/.test(value))\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"value ('\" +\n\t\t\t\t\t\tvalue +\n\t\t\t\t\t\t\"') of key '\" +\n\t\t\t\t\t\tkey +\n\t\t\t\t\t\t\"' contains '*', but there is no previous value defined\"\n\t\t\t\t);\n\t\t\ttype = value.replace(/\\/\\*$/, \"/\" + type);\n\t\t}\n\t});\n\treturn type;\n}\n\nexports.parseType = parseType;\nexports.isTypeMatched = isTypeMatched;\nexports.isResourceTypeSupported = isResourceTypeSupported;\nexports.isEnvironment = isEnvironment;\nexports.isGlobMatched = isGlobMatched;\nexports.isConditionMatched = isConditionMatched;\nexports.isKeyMatched = isKeyMatched;\nexports.getField = getField;\nexports.getMain = getMain;\nexports.getExtensions = getExtensions;\nexports.matchModule = matchModule;\nexports.matchType = matchType;\n"]},"metadata":{},"sourceType":"script"}