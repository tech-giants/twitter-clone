{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n/**\n * @template T\n * @template K\n * Multi layer bucket sorted set\n * Supports adding non-existing items (DO NOT ADD ITEM TWICE)\n * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET)\n * Supports popping the first items according to defined order\n * Supports iterating all items without order\n * Supports updating an item in an efficient way\n * Supports size property, which is the number of items\n * Items are lazy partially sorted when needed\n */\n\n\nclass LazyBucketSortedSet {\n  /**\n   * @param {function(T): K} getKey function to get key from item\n   * @param {function(K, K): number} comparator comparator to sort keys\n   * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer\n   */\n  constructor(getKey, comparator, ...args) {\n    this._getKey = getKey;\n    this._innerArgs = args;\n    this._leaf = args.length <= 1;\n    this._keys = new SortableSet(undefined, comparator);\n    /** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */\n\n    this._map = new Map();\n    this._unsortedItems = new Set();\n    this.size = 0;\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  add(item) {\n    this.size++;\n\n    this._unsortedItems.add(item);\n  }\n  /**\n   * @param {K} key key of item\n   * @param {T} item the item\n   * @returns {void}\n   */\n\n\n  _addInternal(key, item) {\n    let entry = this._map.get(key);\n\n    if (entry === undefined) {\n      entry = this._leaf ? new SortableSet(undefined, this._innerArgs[0]) : new LazyBucketSortedSet(...this._innerArgs);\n\n      this._keys.add(key);\n\n      this._map.set(key, entry);\n    }\n\n    entry.add(item);\n  }\n  /**\n   * @param {T} item an item\n   * @returns {void}\n   */\n\n\n  delete(item) {\n    this.size--;\n\n    if (this._unsortedItems.has(item)) {\n      this._unsortedItems.delete(item);\n\n      return;\n    }\n\n    const key = this._getKey(item);\n\n    const entry = this._map.get(key);\n\n    entry.delete(item);\n\n    if (entry.size === 0) {\n      this._deleteKey(key);\n    }\n  }\n  /**\n   * @param {K} key key to be removed\n   * @returns {void}\n   */\n\n\n  _deleteKey(key) {\n    this._keys.delete(key);\n\n    this._map.delete(key);\n  }\n  /**\n   * @returns {T | undefined} an item\n   */\n\n\n  popFirst() {\n    if (this.size === 0) return undefined;\n    this.size--;\n\n    if (this._unsortedItems.size > 0) {\n      for (const item of this._unsortedItems) {\n        const key = this._getKey(item);\n\n        this._addInternal(key, item);\n      }\n\n      this._unsortedItems.clear();\n    }\n\n    this._keys.sort();\n\n    const key = this._keys.values().next().value;\n\n    const entry = this._map.get(key);\n\n    if (this._leaf) {\n      const leafEntry = entry;\n      leafEntry.sort();\n      const item = leafEntry.values().next().value;\n      leafEntry.delete(item);\n\n      if (leafEntry.size === 0) {\n        this._deleteKey(key);\n      }\n\n      return item;\n    } else {\n      const nodeEntry = entry;\n      const item = nodeEntry.popFirst();\n\n      if (nodeEntry.size === 0) {\n        this._deleteKey(key);\n      }\n\n      return item;\n    }\n  }\n  /**\n   * @param {T} item to be updated item\n   * @returns {function(true=): void} finish update\n   */\n\n\n  startUpdate(item) {\n    if (this._unsortedItems.has(item)) {\n      return remove => {\n        if (remove) {\n          this._unsortedItems.delete(item);\n\n          this.size--;\n          return;\n        }\n      };\n    }\n\n    const key = this._getKey(item);\n\n    if (this._leaf) {\n      const oldEntry = this._map.get(key);\n\n      return remove => {\n        if (remove) {\n          this.size--;\n          oldEntry.delete(item);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          return;\n        }\n\n        const newKey = this._getKey(item);\n\n        if (key === newKey) {\n          // This flags the sortable set as unordered\n          oldEntry.add(item);\n        } else {\n          oldEntry.delete(item);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          this._addInternal(newKey, item);\n        }\n      };\n    } else {\n      const oldEntry = this._map.get(key);\n\n      const finishUpdate = oldEntry.startUpdate(item);\n      return remove => {\n        if (remove) {\n          this.size--;\n          finishUpdate(true);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          return;\n        }\n\n        const newKey = this._getKey(item);\n\n        if (key === newKey) {\n          finishUpdate();\n        } else {\n          finishUpdate(true);\n\n          if (oldEntry.size === 0) {\n            this._deleteKey(key);\n          }\n\n          this._addInternal(newKey, item);\n        }\n      };\n    }\n  }\n  /**\n   * @param {Iterator<T>[]} iterators list of iterators to append to\n   * @returns {void}\n   */\n\n\n  _appendIterators(iterators) {\n    if (this._unsortedItems.size > 0) iterators.push(this._unsortedItems[Symbol.iterator]());\n\n    for (const key of this._keys) {\n      const entry = this._map.get(key);\n\n      if (this._leaf) {\n        const leafEntry = entry;\n        const iterator = leafEntry[Symbol.iterator]();\n        iterators.push(iterator);\n      } else {\n        const nodeEntry = entry;\n\n        nodeEntry._appendIterators(iterators);\n      }\n    }\n  }\n  /**\n   * @returns {Iterator<T>} the iterator\n   */\n\n\n  [Symbol.iterator]() {\n    const iterators = [];\n\n    this._appendIterators(iterators);\n\n    iterators.reverse();\n    let currentIterator = iterators.pop();\n    return {\n      next: () => {\n        const res = currentIterator.next();\n\n        if (res.done) {\n          if (iterators.length === 0) return res;\n          currentIterator = iterators.pop();\n          return currentIterator.next();\n        }\n\n        return res;\n      }\n    };\n  }\n\n}\n\nmodule.exports = LazyBucketSortedSet;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/util/LazyBucketSortedSet.js"],"names":["SortableSet","require","LazyBucketSortedSet","constructor","getKey","comparator","args","_getKey","_innerArgs","_leaf","length","_keys","undefined","_map","Map","_unsortedItems","Set","size","add","item","_addInternal","key","entry","get","set","delete","has","_deleteKey","popFirst","clear","sort","values","next","value","leafEntry","nodeEntry","startUpdate","remove","oldEntry","newKey","finishUpdate","_appendIterators","iterators","push","Symbol","iterator","reverse","currentIterator","pop","res","done","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SortableSet = require(\"./SortableSet\");\n\n/**\n * @template T\n * @template K\n * Multi layer bucket sorted set\n * Supports adding non-existing items (DO NOT ADD ITEM TWICE)\n * Supports removing exiting items (DO NOT REMOVE ITEM NOT IN SET)\n * Supports popping the first items according to defined order\n * Supports iterating all items without order\n * Supports updating an item in an efficient way\n * Supports size property, which is the number of items\n * Items are lazy partially sorted when needed\n */\nclass LazyBucketSortedSet {\n\t/**\n\t * @param {function(T): K} getKey function to get key from item\n\t * @param {function(K, K): number} comparator comparator to sort keys\n\t * @param  {...((function(T): any) | (function(any, any): number))} args more pairs of getKey and comparator plus optional final comparator for the last layer\n\t */\n\tconstructor(getKey, comparator, ...args) {\n\t\tthis._getKey = getKey;\n\t\tthis._innerArgs = args;\n\t\tthis._leaf = args.length <= 1;\n\t\tthis._keys = new SortableSet(undefined, comparator);\n\t\t/** @type {Map<K, LazyBucketSortedSet<T, any> | SortableSet<T>>} */\n\t\tthis._map = new Map();\n\t\tthis._unsortedItems = new Set();\n\t\tthis.size = 0;\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tadd(item) {\n\t\tthis.size++;\n\t\tthis._unsortedItems.add(item);\n\t}\n\n\t/**\n\t * @param {K} key key of item\n\t * @param {T} item the item\n\t * @returns {void}\n\t */\n\t_addInternal(key, item) {\n\t\tlet entry = this._map.get(key);\n\t\tif (entry === undefined) {\n\t\t\tentry = this._leaf\n\t\t\t\t? new SortableSet(undefined, this._innerArgs[0])\n\t\t\t\t: new /** @type {any} */ (LazyBucketSortedSet)(...this._innerArgs);\n\t\t\tthis._keys.add(key);\n\t\t\tthis._map.set(key, entry);\n\t\t}\n\t\tentry.add(item);\n\t}\n\n\t/**\n\t * @param {T} item an item\n\t * @returns {void}\n\t */\n\tdelete(item) {\n\t\tthis.size--;\n\t\tif (this._unsortedItems.has(item)) {\n\t\t\tthis._unsortedItems.delete(item);\n\t\t\treturn;\n\t\t}\n\t\tconst key = this._getKey(item);\n\t\tconst entry = this._map.get(key);\n\t\tentry.delete(item);\n\t\tif (entry.size === 0) {\n\t\t\tthis._deleteKey(key);\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} key key to be removed\n\t * @returns {void}\n\t */\n\t_deleteKey(key) {\n\t\tthis._keys.delete(key);\n\t\tthis._map.delete(key);\n\t}\n\n\t/**\n\t * @returns {T | undefined} an item\n\t */\n\tpopFirst() {\n\t\tif (this.size === 0) return undefined;\n\t\tthis.size--;\n\t\tif (this._unsortedItems.size > 0) {\n\t\t\tfor (const item of this._unsortedItems) {\n\t\t\t\tconst key = this._getKey(item);\n\t\t\t\tthis._addInternal(key, item);\n\t\t\t}\n\t\t\tthis._unsortedItems.clear();\n\t\t}\n\t\tthis._keys.sort();\n\t\tconst key = this._keys.values().next().value;\n\t\tconst entry = this._map.get(key);\n\t\tif (this._leaf) {\n\t\t\tconst leafEntry = /** @type {SortableSet<T>} */ (entry);\n\t\t\tleafEntry.sort();\n\t\t\tconst item = leafEntry.values().next().value;\n\t\t\tleafEntry.delete(item);\n\t\t\tif (leafEntry.size === 0) {\n\t\t\t\tthis._deleteKey(key);\n\t\t\t}\n\t\t\treturn item;\n\t\t} else {\n\t\t\tconst nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */ (entry);\n\t\t\tconst item = nodeEntry.popFirst();\n\t\t\tif (nodeEntry.size === 0) {\n\t\t\t\tthis._deleteKey(key);\n\t\t\t}\n\t\t\treturn item;\n\t\t}\n\t}\n\n\t/**\n\t * @param {T} item to be updated item\n\t * @returns {function(true=): void} finish update\n\t */\n\tstartUpdate(item) {\n\t\tif (this._unsortedItems.has(item)) {\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis._unsortedItems.delete(item);\n\t\t\t\t\tthis.size--;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tconst key = this._getKey(item);\n\t\tif (this._leaf) {\n\t\t\tconst oldEntry = /** @type {SortableSet<T>} */ (this._map.get(key));\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis.size--;\n\t\t\t\t\toldEntry.delete(item);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst newKey = this._getKey(item);\n\t\t\t\tif (key === newKey) {\n\t\t\t\t\t// This flags the sortable set as unordered\n\t\t\t\t\toldEntry.add(item);\n\t\t\t\t} else {\n\t\t\t\t\toldEntry.delete(item);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\tthis._addInternal(newKey, item);\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\tconst oldEntry = /** @type {LazyBucketSortedSet<T, any>} */ (this._map.get(\n\t\t\t\tkey\n\t\t\t));\n\t\t\tconst finishUpdate = oldEntry.startUpdate(item);\n\t\t\treturn remove => {\n\t\t\t\tif (remove) {\n\t\t\t\t\tthis.size--;\n\t\t\t\t\tfinishUpdate(true);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst newKey = this._getKey(item);\n\t\t\t\tif (key === newKey) {\n\t\t\t\t\tfinishUpdate();\n\t\t\t\t} else {\n\t\t\t\t\tfinishUpdate(true);\n\t\t\t\t\tif (oldEntry.size === 0) {\n\t\t\t\t\t\tthis._deleteKey(key);\n\t\t\t\t\t}\n\t\t\t\t\tthis._addInternal(newKey, item);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {Iterator<T>[]} iterators list of iterators to append to\n\t * @returns {void}\n\t */\n\t_appendIterators(iterators) {\n\t\tif (this._unsortedItems.size > 0)\n\t\t\titerators.push(this._unsortedItems[Symbol.iterator]());\n\t\tfor (const key of this._keys) {\n\t\t\tconst entry = this._map.get(key);\n\t\t\tif (this._leaf) {\n\t\t\t\tconst leafEntry = /** @type {SortableSet<T>} */ (entry);\n\t\t\t\tconst iterator = leafEntry[Symbol.iterator]();\n\t\t\t\titerators.push(iterator);\n\t\t\t} else {\n\t\t\t\tconst nodeEntry = /** @type {LazyBucketSortedSet<T, any>} */ (entry);\n\t\t\t\tnodeEntry._appendIterators(iterators);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @returns {Iterator<T>} the iterator\n\t */\n\t[Symbol.iterator]() {\n\t\tconst iterators = [];\n\t\tthis._appendIterators(iterators);\n\t\titerators.reverse();\n\t\tlet currentIterator = iterators.pop();\n\t\treturn {\n\t\t\tnext: () => {\n\t\t\t\tconst res = currentIterator.next();\n\t\t\t\tif (res.done) {\n\t\t\t\t\tif (iterators.length === 0) return res;\n\t\t\t\t\tcurrentIterator = iterators.pop();\n\t\t\t\t\treturn currentIterator.next();\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = LazyBucketSortedSet;\n"]},"metadata":{},"sourceType":"script"}