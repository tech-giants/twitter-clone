{"ast":null,"code":"import Long from \"@xtuc/long\";\nimport parseHexFloat from \"@webassemblyjs/floating-point-hex-parser\";\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nexport function parse32F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x400000);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse64F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x8000000000000);\n  }\n\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse32I(sourceString) {\n  var value = 0;\n\n  if (isHexLiteral(sourceString)) {\n    value = ~~parseInt(sourceString, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    value = parseInt(sourceString, 10);\n  }\n\n  return value;\n}\nexport function parseU32(sourceString) {\n  var value = parse32I(sourceString);\n\n  if (value < 0) {\n    throw new CompileError(\"Illegal value for u32: \" + sourceString);\n  }\n\n  return value;\n}\nexport function parse64I(sourceString) {\n  var long;\n\n  if (isHexLiteral(sourceString)) {\n    long = Long.fromString(sourceString, false, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    long = Long.fromString(sourceString);\n  }\n\n  return {\n    high: long.high,\n    low: long.low\n  };\n}\nvar NAN_WORD = /^\\+?-?nan/;\nvar INF_WORD = /^\\+?-?inf/;\nexport function isInfLiteral(sourceString) {\n  return INF_WORD.test(sourceString.toLowerCase());\n}\nexport function isNanLiteral(sourceString) {\n  return NAN_WORD.test(sourceString.toLowerCase());\n}\n\nfunction isDecimalExponentLiteral(sourceString) {\n  return !isHexLiteral(sourceString) && sourceString.toUpperCase().includes(\"E\");\n}\n\nfunction isHexLiteral(sourceString) {\n  return sourceString.substring(0, 2).toUpperCase() === \"0X\" || sourceString.substring(0, 3).toUpperCase() === \"-0X\";\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/wast-parser/esm/number-literals.js"],"names":["Long","parseHexFloat","CompileError","parse32F","sourceString","isHexLiteral","isInfLiteral","isNanLiteral","includes","parseInt","substring","indexOf","parseFloat","parse64F","parse32I","value","isDecimalExponentLiteral","Error","parseU32","parse64I","long","fromString","high","low","NAN_WORD","INF_WORD","test","toLowerCase","toUpperCase"],"mappings":"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","sourcesContent":["import Long from \"@xtuc/long\";\nimport parseHexFloat from \"@webassemblyjs/floating-point-hex-parser\";\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nexport function parse32F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x400000);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse64F(sourceString) {\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  if (isInfLiteral(sourceString)) {\n    return sourceString[0] === \"-\" ? -1 : 1;\n  }\n\n  if (isNanLiteral(sourceString)) {\n    return (sourceString[0] === \"-\" ? -1 : 1) * (sourceString.includes(\":\") ? parseInt(sourceString.substring(sourceString.indexOf(\":\") + 1), 16) : 0x8000000000000);\n  }\n\n  if (isHexLiteral(sourceString)) {\n    return parseHexFloat(sourceString);\n  }\n\n  return parseFloat(sourceString);\n}\nexport function parse32I(sourceString) {\n  var value = 0;\n\n  if (isHexLiteral(sourceString)) {\n    value = ~~parseInt(sourceString, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    value = parseInt(sourceString, 10);\n  }\n\n  return value;\n}\nexport function parseU32(sourceString) {\n  var value = parse32I(sourceString);\n\n  if (value < 0) {\n    throw new CompileError(\"Illegal value for u32: \" + sourceString);\n  }\n\n  return value;\n}\nexport function parse64I(sourceString) {\n  var long;\n\n  if (isHexLiteral(sourceString)) {\n    long = Long.fromString(sourceString, false, 16);\n  } else if (isDecimalExponentLiteral(sourceString)) {\n    throw new Error(\"This number literal format is yet to be implemented.\");\n  } else {\n    long = Long.fromString(sourceString);\n  }\n\n  return {\n    high: long.high,\n    low: long.low\n  };\n}\nvar NAN_WORD = /^\\+?-?nan/;\nvar INF_WORD = /^\\+?-?inf/;\nexport function isInfLiteral(sourceString) {\n  return INF_WORD.test(sourceString.toLowerCase());\n}\nexport function isNanLiteral(sourceString) {\n  return NAN_WORD.test(sourceString.toLowerCase());\n}\n\nfunction isDecimalExponentLiteral(sourceString) {\n  return !isHexLiteral(sourceString) && sourceString.toUpperCase().includes(\"E\");\n}\n\nfunction isHexLiteral(sourceString) {\n  return sourceString.substring(0, 2).toUpperCase() === \"0X\" || sourceString.substring(0, 3).toUpperCase() === \"-0X\";\n}"]},"metadata":{},"sourceType":"module"}