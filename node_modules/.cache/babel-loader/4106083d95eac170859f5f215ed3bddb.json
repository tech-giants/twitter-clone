{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mergeCache = new WeakMap();\n/**\n * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.\n * @example\n * // performs cleverMerge(first, second), stores the result in WeakMap and returns result\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n *  // when same arguments passed, gets the result from WeakMap and returns it.\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n * @param {object} first first object\n * @param {object} second second object\n * @returns {object} merged object of first and second object\n */\n\nconst cachedCleverMerge = (first, second) => {\n  let innerCache = mergeCache.get(first);\n\n  if (innerCache === undefined) {\n    innerCache = new WeakMap();\n    mergeCache.set(first, innerCache);\n  }\n\n  const prevMerge = innerCache.get(second);\n  if (prevMerge !== undefined) return prevMerge;\n  const newMerge = cleverMerge(first, second);\n  innerCache.set(second, newMerge);\n  return newMerge;\n};\n/**\n * Merges two objects. Objects are not deeply merged.\n * TODO webpack 5: merge objects deeply clever.\n * Arrays might reference the old value with \"...\"\n * @param {object} first first object\n * @param {object} second second object\n * @returns {object} merged object of first and second object\n */\n\n\nconst cleverMerge = (first, second) => {\n  const newObject = Object.assign({}, first);\n\n  for (const key of Object.keys(second)) {\n    if (!(key in newObject)) {\n      newObject[key] = second[key];\n      continue;\n    }\n\n    const secondValue = second[key];\n\n    if (!Array.isArray(secondValue)) {\n      newObject[key] = secondValue;\n      continue;\n    }\n\n    const firstValue = newObject[key];\n\n    if (Array.isArray(firstValue)) {\n      const newArray = [];\n\n      for (const item of secondValue) {\n        if (item === \"...\") {\n          for (const item of firstValue) {\n            newArray.push(item);\n          }\n        } else {\n          newArray.push(item);\n        }\n      }\n\n      newObject[key] = newArray;\n    } else {\n      newObject[key] = secondValue;\n    }\n  }\n\n  return newObject;\n};\n\nexports.cachedCleverMerge = cachedCleverMerge;\nexports.cleverMerge = cleverMerge;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/util/cleverMerge.js"],"names":["mergeCache","WeakMap","cachedCleverMerge","first","second","innerCache","get","undefined","set","prevMerge","newMerge","cleverMerge","newObject","Object","assign","key","keys","secondValue","Array","isArray","firstValue","newArray","item","push","exports"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,UAAU,GAAG,IAAIC,OAAJ,EAAnB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAiB,GAAG,CAACC,KAAD,EAAQC,MAAR,KAAmB;AAC5C,MAAIC,UAAU,GAAGL,UAAU,CAACM,GAAX,CAAeH,KAAf,CAAjB;;AACA,MAAIE,UAAU,KAAKE,SAAnB,EAA8B;AAC7BF,IAAAA,UAAU,GAAG,IAAIJ,OAAJ,EAAb;AACAD,IAAAA,UAAU,CAACQ,GAAX,CAAeL,KAAf,EAAsBE,UAAtB;AACA;;AACD,QAAMI,SAAS,GAAGJ,UAAU,CAACC,GAAX,CAAeF,MAAf,CAAlB;AACA,MAAIK,SAAS,KAAKF,SAAlB,EAA6B,OAAOE,SAAP;AAC7B,QAAMC,QAAQ,GAAGC,WAAW,CAACR,KAAD,EAAQC,MAAR,CAA5B;AACAC,EAAAA,UAAU,CAACG,GAAX,CAAeJ,MAAf,EAAuBM,QAAvB;AACA,SAAOA,QAAP;AACA,CAXD;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,WAAW,GAAG,CAACR,KAAD,EAAQC,MAAR,KAAmB;AACtC,QAAMQ,SAAS,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBX,KAAlB,CAAlB;;AACA,OAAK,MAAMY,GAAX,IAAkBF,MAAM,CAACG,IAAP,CAAYZ,MAAZ,CAAlB,EAAuC;AACtC,QAAI,EAAEW,GAAG,IAAIH,SAAT,CAAJ,EAAyB;AACxBA,MAAAA,SAAS,CAACG,GAAD,CAAT,GAAiBX,MAAM,CAACW,GAAD,CAAvB;AACA;AACA;;AACD,UAAME,WAAW,GAAGb,MAAM,CAACW,GAAD,CAA1B;;AACA,QAAI,CAACG,KAAK,CAACC,OAAN,CAAcF,WAAd,CAAL,EAAiC;AAChCL,MAAAA,SAAS,CAACG,GAAD,CAAT,GAAiBE,WAAjB;AACA;AACA;;AACD,UAAMG,UAAU,GAAGR,SAAS,CAACG,GAAD,CAA5B;;AACA,QAAIG,KAAK,CAACC,OAAN,CAAcC,UAAd,CAAJ,EAA+B;AAC9B,YAAMC,QAAQ,GAAG,EAAjB;;AACA,WAAK,MAAMC,IAAX,IAAmBL,WAAnB,EAAgC;AAC/B,YAAIK,IAAI,KAAK,KAAb,EAAoB;AACnB,eAAK,MAAMA,IAAX,IAAmBF,UAAnB,EAA+B;AAC9BC,YAAAA,QAAQ,CAACE,IAAT,CAAcD,IAAd;AACA;AACD,SAJD,MAIO;AACND,UAAAA,QAAQ,CAACE,IAAT,CAAcD,IAAd;AACA;AACD;;AACDV,MAAAA,SAAS,CAACG,GAAD,CAAT,GAAiBM,QAAjB;AACA,KAZD,MAYO;AACNT,MAAAA,SAAS,CAACG,GAAD,CAAT,GAAiBE,WAAjB;AACA;AACD;;AACD,SAAOL,SAAP;AACA,CA9BD;;AAgCAY,OAAO,CAACtB,iBAAR,GAA4BA,iBAA5B;AACAsB,OAAO,CAACb,WAAR,GAAsBA,WAAtB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst mergeCache = new WeakMap();\n\n/**\n * Merges two given objects and caches the result to avoid computation if same objects passed as arguments again.\n * @example\n * // performs cleverMerge(first, second), stores the result in WeakMap and returns result\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n *  // when same arguments passed, gets the result from WeakMap and returns it.\n * cachedCleverMerge({a: 1}, {a: 2})\n * {a: 2}\n * @param {object} first first object\n * @param {object} second second object\n * @returns {object} merged object of first and second object\n */\nconst cachedCleverMerge = (first, second) => {\n\tlet innerCache = mergeCache.get(first);\n\tif (innerCache === undefined) {\n\t\tinnerCache = new WeakMap();\n\t\tmergeCache.set(first, innerCache);\n\t}\n\tconst prevMerge = innerCache.get(second);\n\tif (prevMerge !== undefined) return prevMerge;\n\tconst newMerge = cleverMerge(first, second);\n\tinnerCache.set(second, newMerge);\n\treturn newMerge;\n};\n\n/**\n * Merges two objects. Objects are not deeply merged.\n * TODO webpack 5: merge objects deeply clever.\n * Arrays might reference the old value with \"...\"\n * @param {object} first first object\n * @param {object} second second object\n * @returns {object} merged object of first and second object\n */\nconst cleverMerge = (first, second) => {\n\tconst newObject = Object.assign({}, first);\n\tfor (const key of Object.keys(second)) {\n\t\tif (!(key in newObject)) {\n\t\t\tnewObject[key] = second[key];\n\t\t\tcontinue;\n\t\t}\n\t\tconst secondValue = second[key];\n\t\tif (!Array.isArray(secondValue)) {\n\t\t\tnewObject[key] = secondValue;\n\t\t\tcontinue;\n\t\t}\n\t\tconst firstValue = newObject[key];\n\t\tif (Array.isArray(firstValue)) {\n\t\t\tconst newArray = [];\n\t\t\tfor (const item of secondValue) {\n\t\t\t\tif (item === \"...\") {\n\t\t\t\t\tfor (const item of firstValue) {\n\t\t\t\t\t\tnewArray.push(item);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tnewArray.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewObject[key] = newArray;\n\t\t} else {\n\t\t\tnewObject[key] = secondValue;\n\t\t}\n\t}\n\treturn newObject;\n};\n\nexports.cachedCleverMerge = cachedCleverMerge;\nexports.cleverMerge = cleverMerge;\n"]},"metadata":{},"sourceType":"script"}