{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst parseJson = require(\"json-parse-better-errors\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst path = require(\"path\");\n\nconst {\n  Source\n} = require(\"webpack-sources\");\n\nconst util = require(\"util\");\n\nconst {\n  Tapable,\n  SyncHook,\n  SyncBailHook,\n  AsyncParallelHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\n\nconst Compilation = require(\"./Compilation\");\n\nconst Stats = require(\"./Stats\");\n\nconst Watching = require(\"./Watching\");\n\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\n\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\n\nconst ResolverFactory = require(\"./ResolverFactory\");\n\nconst RequestShortener = require(\"./RequestShortener\");\n\nconst {\n  makePathsRelative\n} = require(\"./util/identifier\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nconst {\n  Logger\n} = require(\"./logging/Logger\");\n/** @typedef {import(\"../declarations/WebpackOptions\").Entry} Entry */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptions} WebpackOptions */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n * @property {Set<string>} compilationDependencies\n */\n\n\nclass Compiler extends Tapable {\n  constructor(context) {\n    super();\n    this.hooks = {\n      /** @type {SyncBailHook<Compilation>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Stats>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n\n      /** @type {AsyncSeriesHook<>} */\n      additionalPass: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<string, Buffer>} */\n      assetEmitted: new AsyncSeriesHook([\"file\", \"content\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<NormalModuleFactory>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\n      /** @type {SyncHook<ContextModuleFactory>}  */\n      contextModuleFactory: new SyncHook([\"contextModulefactory\"]),\n\n      /** @type {AsyncSeriesHook<CompilationParams>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n\n      /** @type {SyncHook<CompilationParams>} */\n      compile: new SyncHook([\"params\"]),\n\n      /** @type {AsyncParallelHook<Compilation>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {SyncHook<Error>} */\n      failed: new SyncHook([\"error\"]),\n\n      /** @type {SyncHook<string, string>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n\n      /** @type {SyncHook} */\n      watchClose: new SyncHook([]),\n\n      /** @type {SyncBailHook<string, string, any[]>} */\n      infrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook} */\n      environment: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      afterEnvironment: new SyncHook([]),\n\n      /** @type {SyncHook<Compiler>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncHook<Compiler>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncBailHook<string, Entry>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    }; // TODO webpack 5 remove this\n\n    this.hooks.infrastructurelog = this.hooks.infrastructureLog;\n\n    this._pluginCompat.tap(\"Compiler\", options => {\n      switch (options.name) {\n        case \"additional-pass\":\n        case \"before-run\":\n        case \"run\":\n        case \"emit\":\n        case \"after-emit\":\n        case \"before-compile\":\n        case \"make\":\n        case \"after-compile\":\n        case \"watch-run\":\n          options.async = true;\n          break;\n      }\n    });\n    /** @type {string=} */\n\n\n    this.name = undefined;\n    /** @type {Compilation=} */\n\n    this.parentCompilation = undefined;\n    /** @type {string} */\n\n    this.outputPath = \"\";\n    this.outputFileSystem = null;\n    this.inputFileSystem = null;\n    /** @type {string|null} */\n\n    this.recordsInputPath = null;\n    /** @type {string|null} */\n\n    this.recordsOutputPath = null;\n    this.records = {};\n    this.removedFiles = new Set();\n    /** @type {Map<string, number>} */\n\n    this.fileTimestamps = new Map();\n    /** @type {Map<string, number>} */\n\n    this.contextTimestamps = new Map();\n    /** @type {ResolverFactory} */\n\n    this.resolverFactory = new ResolverFactory();\n    this.infrastructureLogger = undefined; // TODO remove in webpack 5\n\n    this.resolvers = {\n      normal: {\n        plugins: util.deprecate((hook, fn) => {\n          this.resolverFactory.plugin(\"resolver normal\", resolver => {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate((...args) => {\n          this.resolverFactory.plugin(\"resolver normal\", resolver => {\n            resolver.apply(...args);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      loader: {\n        plugins: util.deprecate((hook, fn) => {\n          this.resolverFactory.plugin(\"resolver loader\", resolver => {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate((...args) => {\n          this.resolverFactory.plugin(\"resolver loader\", resolver => {\n            resolver.apply(...args);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      context: {\n        plugins: util.deprecate((hook, fn) => {\n          this.resolverFactory.plugin(\"resolver context\", resolver => {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate((...args) => {\n          this.resolverFactory.plugin(\"resolver context\", resolver => {\n            resolver.apply(...args);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      }\n    };\n    /** @type {WebpackOptions} */\n\n    this.options = {};\n    this.context = context;\n    this.requestShortener = new RequestShortener(context);\n    /** @type {boolean} */\n\n    this.running = false;\n    /** @type {boolean} */\n\n    this.watchMode = false;\n    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\n    this._assetEmittingSourceCache = new WeakMap();\n    /** @private @type {Map<string, number>} */\n\n    this._assetEmittingWrittenFiles = new Map();\n  }\n  /**\n   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n   * @returns {Logger} a logger with that name\n   */\n\n\n  getInfrastructureLogger(name) {\n    if (!name) {\n      throw new TypeError(\"Compiler.getInfrastructureLogger(name) called without a name\");\n    }\n\n    return new Logger((type, args) => {\n      if (typeof name === \"function\") {\n        name = name();\n\n        if (!name) {\n          throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n        }\n      }\n\n      if (this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n        if (this.infrastructureLogger !== undefined) {\n          this.infrastructureLogger(name, type, args);\n        }\n      }\n    });\n  }\n\n  watch(watchOptions, handler) {\n    if (this.running) return handler(new ConcurrentCompilationError());\n    this.running = true;\n    this.watchMode = true;\n    this.fileTimestamps = new Map();\n    this.contextTimestamps = new Map();\n    this.removedFiles = new Set();\n    return new Watching(this, watchOptions, handler);\n  }\n\n  run(callback) {\n    if (this.running) return callback(new ConcurrentCompilationError());\n\n    const finalCallback = (err, stats) => {\n      this.running = false;\n\n      if (err) {\n        this.hooks.failed.call(err);\n      }\n\n      if (callback !== undefined) return callback(err, stats);\n    };\n\n    const startTime = Date.now();\n    this.running = true;\n\n    const onCompiled = (err, compilation) => {\n      if (err) return finalCallback(err);\n\n      if (this.hooks.shouldEmit.call(compilation) === false) {\n        const stats = new Stats(compilation);\n        stats.startTime = startTime;\n        stats.endTime = Date.now();\n        this.hooks.done.callAsync(stats, err => {\n          if (err) return finalCallback(err);\n          return finalCallback(null, stats);\n        });\n        return;\n      }\n\n      this.emitAssets(compilation, err => {\n        if (err) return finalCallback(err);\n\n        if (compilation.hooks.needAdditionalPass.call()) {\n          compilation.needAdditionalPass = true;\n          const stats = new Stats(compilation);\n          stats.startTime = startTime;\n          stats.endTime = Date.now();\n          this.hooks.done.callAsync(stats, err => {\n            if (err) return finalCallback(err);\n            this.hooks.additionalPass.callAsync(err => {\n              if (err) return finalCallback(err);\n              this.compile(onCompiled);\n            });\n          });\n          return;\n        }\n\n        this.emitRecords(err => {\n          if (err) return finalCallback(err);\n          const stats = new Stats(compilation);\n          stats.startTime = startTime;\n          stats.endTime = Date.now();\n          this.hooks.done.callAsync(stats, err => {\n            if (err) return finalCallback(err);\n            return finalCallback(null, stats);\n          });\n        });\n      });\n    };\n\n    this.hooks.beforeRun.callAsync(this, err => {\n      if (err) return finalCallback(err);\n      this.hooks.run.callAsync(this, err => {\n        if (err) return finalCallback(err);\n        this.readRecords(err => {\n          if (err) return finalCallback(err);\n          this.compile(onCompiled);\n        });\n      });\n    });\n  }\n\n  runAsChild(callback) {\n    this.compile((err, compilation) => {\n      if (err) return callback(err);\n      this.parentCompilation.children.push(compilation);\n\n      for (const {\n        name,\n        source,\n        info\n      } of compilation.getAssets()) {\n        this.parentCompilation.emitAsset(name, source, info);\n      }\n\n      const entries = Array.from(compilation.entrypoints.values(), ep => ep.chunks).reduce((array, chunks) => {\n        return array.concat(chunks);\n      }, []);\n      return callback(null, entries, compilation);\n    });\n  }\n\n  purgeInputFileSystem() {\n    if (this.inputFileSystem && this.inputFileSystem.purge) {\n      this.inputFileSystem.purge();\n    }\n  }\n\n  emitAssets(compilation, callback) {\n    let outputPath;\n\n    const emitFiles = err => {\n      if (err) return callback(err);\n      asyncLib.forEachLimit(compilation.getAssets(), 15, ({\n        name: file,\n        source\n      }, callback) => {\n        let targetFile = file;\n        const queryStringIdx = targetFile.indexOf(\"?\");\n\n        if (queryStringIdx >= 0) {\n          targetFile = targetFile.substr(0, queryStringIdx);\n        }\n\n        const writeOut = err => {\n          if (err) return callback(err);\n          const targetPath = this.outputFileSystem.join(outputPath, targetFile); // TODO webpack 5 remove futureEmitAssets option and make it on by default\n\n          if (this.options.output.futureEmitAssets) {\n            // check if the target file has already been written by this Compiler\n            const targetFileGeneration = this._assetEmittingWrittenFiles.get(targetPath); // create an cache entry for this Source if not already existing\n\n\n            let cacheEntry = this._assetEmittingSourceCache.get(source);\n\n            if (cacheEntry === undefined) {\n              cacheEntry = {\n                sizeOnlySource: undefined,\n                writtenTo: new Map()\n              };\n\n              this._assetEmittingSourceCache.set(source, cacheEntry);\n            } // if the target file has already been written\n\n\n            if (targetFileGeneration !== undefined) {\n              // check if the Source has been written to this target file\n              const writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\n              if (writtenGeneration === targetFileGeneration) {\n                // if yes, we skip writing the file\n                // as it's already there\n                // (we assume one doesn't remove files while the Compiler is running)\n                compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n                  size: cacheEntry.sizeOnlySource.size()\n                });\n                return callback();\n              }\n            } // TODO webpack 5: if info.immutable check if file already exists in output\n            // skip emitting if it's already there\n            // get the binary (Buffer) content from the Source\n\n            /** @type {Buffer} */\n\n\n            let content;\n\n            if (typeof source.buffer === \"function\") {\n              content = source.buffer();\n            } else {\n              const bufferOrString = source.source();\n\n              if (Buffer.isBuffer(bufferOrString)) {\n                content = bufferOrString;\n              } else {\n                content = Buffer.from(bufferOrString, \"utf8\");\n              }\n            } // Create a replacement resource which only allows to ask for size\n            // This allows to GC all memory allocated by the Source\n            // (expect when the Source is stored in any other cache)\n\n\n            cacheEntry.sizeOnlySource = new SizeOnlySource(content.length);\n            compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n              size: content.length\n            }); // Write the file to output file system\n\n            this.outputFileSystem.writeFile(targetPath, content, err => {\n              if (err) return callback(err); // information marker that the asset has been emitted\n\n              compilation.emittedAssets.add(file); // cache the information that the Source has been written to that location\n\n              const newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;\n              cacheEntry.writtenTo.set(targetPath, newGeneration);\n\n              this._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\n              this.hooks.assetEmitted.callAsync(file, content, callback);\n            });\n          } else {\n            if (source.existsAt === targetPath) {\n              source.emitted = false;\n              return callback();\n            }\n\n            let content = source.source();\n\n            if (!Buffer.isBuffer(content)) {\n              content = Buffer.from(content, \"utf8\");\n            }\n\n            source.existsAt = targetPath;\n            source.emitted = true;\n            this.outputFileSystem.writeFile(targetPath, content, err => {\n              if (err) return callback(err);\n              this.hooks.assetEmitted.callAsync(file, content, callback);\n            });\n          }\n        };\n\n        if (targetFile.match(/\\/|\\\\/)) {\n          const dir = path.dirname(targetFile);\n          this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut);\n        } else {\n          writeOut();\n        }\n      }, err => {\n        if (err) return callback(err);\n        this.hooks.afterEmit.callAsync(compilation, err => {\n          if (err) return callback(err);\n          return callback();\n        });\n      });\n    };\n\n    this.hooks.emit.callAsync(compilation, err => {\n      if (err) return callback(err);\n      outputPath = compilation.getPath(this.outputPath);\n      this.outputFileSystem.mkdirp(outputPath, emitFiles);\n    });\n  }\n\n  emitRecords(callback) {\n    if (!this.recordsOutputPath) return callback();\n    const idx1 = this.recordsOutputPath.lastIndexOf(\"/\");\n    const idx2 = this.recordsOutputPath.lastIndexOf(\"\\\\\");\n    let recordsOutputPathDirectory = null;\n\n    if (idx1 > idx2) {\n      recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);\n    } else if (idx1 < idx2) {\n      recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);\n    }\n\n    const writeFile = () => {\n      this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, undefined, 2), callback);\n    };\n\n    if (!recordsOutputPathDirectory) {\n      return writeFile();\n    }\n\n    this.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => {\n      if (err) return callback(err);\n      writeFile();\n    });\n  }\n\n  readRecords(callback) {\n    if (!this.recordsInputPath) {\n      this.records = {};\n      return callback();\n    }\n\n    this.inputFileSystem.stat(this.recordsInputPath, err => {\n      // It doesn't exist\n      // We can ignore this.\n      if (err) return callback();\n      this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {\n        if (err) return callback(err);\n\n        try {\n          this.records = parseJson(content.toString(\"utf-8\"));\n        } catch (e) {\n          e.message = \"Cannot parse records: \" + e.message;\n          return callback(e);\n        }\n\n        return callback();\n      });\n    });\n  }\n\n  createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n    const childCompiler = new Compiler(this.context);\n\n    if (Array.isArray(plugins)) {\n      for (const plugin of plugins) {\n        plugin.apply(childCompiler);\n      }\n    }\n\n    for (const name in this.hooks) {\n      if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n        if (childCompiler.hooks[name]) {\n          childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n        }\n      }\n    }\n\n    childCompiler.name = compilerName;\n    childCompiler.outputPath = this.outputPath;\n    childCompiler.inputFileSystem = this.inputFileSystem;\n    childCompiler.outputFileSystem = null;\n    childCompiler.resolverFactory = this.resolverFactory;\n    childCompiler.fileTimestamps = this.fileTimestamps;\n    childCompiler.contextTimestamps = this.contextTimestamps;\n    const relativeCompilerName = makePathsRelative(this.context, compilerName);\n\n    if (!this.records[relativeCompilerName]) {\n      this.records[relativeCompilerName] = [];\n    }\n\n    if (this.records[relativeCompilerName][compilerIndex]) {\n      childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n    } else {\n      this.records[relativeCompilerName].push(childCompiler.records = {});\n    }\n\n    childCompiler.options = Object.create(this.options);\n    childCompiler.options.output = Object.create(childCompiler.options.output);\n\n    for (const name in outputOptions) {\n      childCompiler.options.output[name] = outputOptions[name];\n    }\n\n    childCompiler.parentCompilation = compilation;\n    compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n    return childCompiler;\n  }\n\n  isChild() {\n    return !!this.parentCompilation;\n  }\n\n  createCompilation() {\n    return new Compilation(this);\n  }\n\n  newCompilation(params) {\n    const compilation = this.createCompilation();\n    compilation.fileTimestamps = this.fileTimestamps;\n    compilation.contextTimestamps = this.contextTimestamps;\n    compilation.name = this.name;\n    compilation.records = this.records;\n    compilation.compilationDependencies = params.compilationDependencies;\n    this.hooks.thisCompilation.call(compilation, params);\n    this.hooks.compilation.call(compilation, params);\n    return compilation;\n  }\n\n  createNormalModuleFactory() {\n    const normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolverFactory, this.options.module || {});\n    this.hooks.normalModuleFactory.call(normalModuleFactory);\n    return normalModuleFactory;\n  }\n\n  createContextModuleFactory() {\n    const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n    this.hooks.contextModuleFactory.call(contextModuleFactory);\n    return contextModuleFactory;\n  }\n\n  newCompilationParams() {\n    const params = {\n      normalModuleFactory: this.createNormalModuleFactory(),\n      contextModuleFactory: this.createContextModuleFactory(),\n      compilationDependencies: new Set()\n    };\n    return params;\n  }\n\n  compile(callback) {\n    const params = this.newCompilationParams();\n    this.hooks.beforeCompile.callAsync(params, err => {\n      if (err) return callback(err);\n      this.hooks.compile.call(params);\n      const compilation = this.newCompilation(params);\n      this.hooks.make.callAsync(compilation, err => {\n        if (err) return callback(err);\n        compilation.finish(err => {\n          if (err) return callback(err);\n          compilation.seal(err => {\n            if (err) return callback(err);\n            this.hooks.afterCompile.callAsync(compilation, err => {\n              if (err) return callback(err);\n              return callback(null, compilation);\n            });\n          });\n        });\n      });\n    });\n  }\n\n}\n\nmodule.exports = Compiler;\n\nclass SizeOnlySource extends Source {\n  constructor(size) {\n    super();\n    this._size = size;\n  }\n\n  _error() {\n    return new Error(\"Content and Map of this Source is no longer available (only size() is supported)\");\n  }\n\n  size() {\n    return this._size;\n  }\n  /**\n   * @param {any} options options\n   * @returns {string} the source\n   */\n\n\n  source(options) {\n    throw this._error();\n  }\n\n  node() {\n    throw this._error();\n  }\n\n  listMap() {\n    throw this._error();\n  }\n\n  map() {\n    throw this._error();\n  }\n\n  listNode() {\n    throw this._error();\n  }\n\n  updateHash() {\n    throw this._error();\n  }\n\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/Compiler.js"],"names":["parseJson","require","asyncLib","path","Source","util","Tapable","SyncHook","SyncBailHook","AsyncParallelHook","AsyncSeriesHook","Compilation","Stats","Watching","NormalModuleFactory","ContextModuleFactory","ResolverFactory","RequestShortener","makePathsRelative","ConcurrentCompilationError","Logger","Compiler","constructor","context","hooks","shouldEmit","done","additionalPass","beforeRun","run","emit","assetEmitted","afterEmit","thisCompilation","compilation","normalModuleFactory","contextModuleFactory","beforeCompile","compile","make","afterCompile","watchRun","failed","invalid","watchClose","infrastructureLog","environment","afterEnvironment","afterPlugins","afterResolvers","entryOption","infrastructurelog","_pluginCompat","tap","options","name","async","undefined","parentCompilation","outputPath","outputFileSystem","inputFileSystem","recordsInputPath","recordsOutputPath","records","removedFiles","Set","fileTimestamps","Map","contextTimestamps","resolverFactory","infrastructureLogger","resolvers","normal","plugins","deprecate","hook","fn","plugin","resolver","apply","args","loader","requestShortener","running","watchMode","_assetEmittingSourceCache","WeakMap","_assetEmittingWrittenFiles","getInfrastructureLogger","TypeError","type","call","watch","watchOptions","handler","callback","finalCallback","err","stats","startTime","Date","now","onCompiled","endTime","callAsync","emitAssets","needAdditionalPass","emitRecords","readRecords","runAsChild","children","push","source","info","getAssets","emitAsset","entries","Array","from","entrypoints","values","ep","chunks","reduce","array","concat","purgeInputFileSystem","purge","emitFiles","forEachLimit","file","targetFile","queryStringIdx","indexOf","substr","writeOut","targetPath","join","output","futureEmitAssets","targetFileGeneration","get","cacheEntry","sizeOnlySource","writtenTo","set","writtenGeneration","updateAsset","size","content","buffer","bufferOrString","Buffer","isBuffer","SizeOnlySource","length","writeFile","emittedAssets","add","newGeneration","existsAt","emitted","match","dir","dirname","mkdirp","getPath","idx1","lastIndexOf","idx2","recordsOutputPathDirectory","JSON","stringify","stat","readFile","toString","e","message","createChildCompiler","compilerName","compilerIndex","outputOptions","childCompiler","isArray","includes","taps","slice","relativeCompilerName","Object","create","isChild","createCompilation","newCompilation","params","compilationDependencies","createNormalModuleFactory","module","createContextModuleFactory","newCompilationParams","finish","seal","exports","_size","_error","Error","node","listMap","map","listNode","updateHash"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst parseJson = require(\"json-parse-better-errors\");\nconst asyncLib = require(\"neo-async\");\nconst path = require(\"path\");\nconst { Source } = require(\"webpack-sources\");\nconst util = require(\"util\");\nconst {\n\tTapable,\n\tSyncHook,\n\tSyncBailHook,\n\tAsyncParallelHook,\n\tAsyncSeriesHook\n} = require(\"tapable\");\n\nconst Compilation = require(\"./Compilation\");\nconst Stats = require(\"./Stats\");\nconst Watching = require(\"./Watching\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\nconst ResolverFactory = require(\"./ResolverFactory\");\n\nconst RequestShortener = require(\"./RequestShortener\");\nconst { makePathsRelative } = require(\"./util/identifier\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst { Logger } = require(\"./logging/Logger\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").Entry} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptions} WebpackOptions */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n * @property {Set<string>} compilationDependencies\n */\n\nclass Compiler extends Tapable {\n\tconstructor(context) {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\t/** @type {SyncBailHook<Compilation>} */\n\t\t\tshouldEmit: new SyncBailHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<Stats>} */\n\t\t\tdone: new AsyncSeriesHook([\"stats\"]),\n\t\t\t/** @type {AsyncSeriesHook<>} */\n\t\t\tadditionalPass: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<Compiler>} */\n\t\t\tbeforeRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<Compiler>} */\n\t\t\trun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<Compilation>} */\n\t\t\temit: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<string, Buffer>} */\n\t\t\tassetEmitted: new AsyncSeriesHook([\"file\", \"content\"]),\n\t\t\t/** @type {AsyncSeriesHook<Compilation>} */\n\t\t\tafterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {SyncHook<Compilation, CompilationParams>} */\n\t\t\tthisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<Compilation, CompilationParams>} */\n\t\t\tcompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<NormalModuleFactory>} */\n\t\t\tnormalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\t\t\t/** @type {SyncHook<ContextModuleFactory>}  */\n\t\t\tcontextModuleFactory: new SyncHook([\"contextModulefactory\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<CompilationParams>} */\n\t\t\tbeforeCompile: new AsyncSeriesHook([\"params\"]),\n\t\t\t/** @type {SyncHook<CompilationParams>} */\n\t\t\tcompile: new SyncHook([\"params\"]),\n\t\t\t/** @type {AsyncParallelHook<Compilation>} */\n\t\t\tmake: new AsyncParallelHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<Compilation>} */\n\t\t\tafterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<Compiler>} */\n\t\t\twatchRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<Error>} */\n\t\t\tfailed: new SyncHook([\"error\"]),\n\t\t\t/** @type {SyncHook<string, string>} */\n\t\t\tinvalid: new SyncHook([\"filename\", \"changeTime\"]),\n\t\t\t/** @type {SyncHook} */\n\t\t\twatchClose: new SyncHook([]),\n\n\t\t\t/** @type {SyncBailHook<string, string, any[]>} */\n\t\t\tinfrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n\n\t\t\t// TODO the following hooks are weirdly located here\n\t\t\t// TODO move them for webpack 5\n\t\t\t/** @type {SyncHook} */\n\t\t\tenvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tafterEnvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<Compiler>} */\n\t\t\tafterPlugins: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<Compiler>} */\n\t\t\tafterResolvers: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncBailHook<string, Entry>} */\n\t\t\tentryOption: new SyncBailHook([\"context\", \"entry\"])\n\t\t};\n\t\t// TODO webpack 5 remove this\n\t\tthis.hooks.infrastructurelog = this.hooks.infrastructureLog;\n\n\t\tthis._pluginCompat.tap(\"Compiler\", options => {\n\t\t\tswitch (options.name) {\n\t\t\t\tcase \"additional-pass\":\n\t\t\t\tcase \"before-run\":\n\t\t\t\tcase \"run\":\n\t\t\t\tcase \"emit\":\n\t\t\t\tcase \"after-emit\":\n\t\t\t\tcase \"before-compile\":\n\t\t\t\tcase \"make\":\n\t\t\t\tcase \"after-compile\":\n\t\t\t\tcase \"watch-run\":\n\t\t\t\t\toptions.async = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t/** @type {string=} */\n\t\tthis.name = undefined;\n\t\t/** @type {Compilation=} */\n\t\tthis.parentCompilation = undefined;\n\t\t/** @type {string} */\n\t\tthis.outputPath = \"\";\n\n\t\tthis.outputFileSystem = null;\n\t\tthis.inputFileSystem = null;\n\n\t\t/** @type {string|null} */\n\t\tthis.recordsInputPath = null;\n\t\t/** @type {string|null} */\n\t\tthis.recordsOutputPath = null;\n\t\tthis.records = {};\n\t\tthis.removedFiles = new Set();\n\t\t/** @type {Map<string, number>} */\n\t\tthis.fileTimestamps = new Map();\n\t\t/** @type {Map<string, number>} */\n\t\tthis.contextTimestamps = new Map();\n\t\t/** @type {ResolverFactory} */\n\t\tthis.resolverFactory = new ResolverFactory();\n\n\t\tthis.infrastructureLogger = undefined;\n\n\t\t// TODO remove in webpack 5\n\t\tthis.resolvers = {\n\t\t\tnormal: {\n\t\t\t\tplugins: util.deprecate((hook, fn) => {\n\t\t\t\t\tthis.resolverFactory.plugin(\"resolver normal\", resolver => {\n\t\t\t\t\t\tresolver.plugin(hook, fn);\n\t\t\t\t\t});\n\t\t\t\t}, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n\t\t\t\tapply: util.deprecate((...args) => {\n\t\t\t\t\tthis.resolverFactory.plugin(\"resolver normal\", resolver => {\n\t\t\t\t\t\tresolver.apply(...args);\n\t\t\t\t\t});\n\t\t\t\t}, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n\t\t\t},\n\t\t\tloader: {\n\t\t\t\tplugins: util.deprecate((hook, fn) => {\n\t\t\t\t\tthis.resolverFactory.plugin(\"resolver loader\", resolver => {\n\t\t\t\t\t\tresolver.plugin(hook, fn);\n\t\t\t\t\t});\n\t\t\t\t}, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n\t\t\t\tapply: util.deprecate((...args) => {\n\t\t\t\t\tthis.resolverFactory.plugin(\"resolver loader\", resolver => {\n\t\t\t\t\t\tresolver.apply(...args);\n\t\t\t\t\t});\n\t\t\t\t}, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n\t\t\t},\n\t\t\tcontext: {\n\t\t\t\tplugins: util.deprecate((hook, fn) => {\n\t\t\t\t\tthis.resolverFactory.plugin(\"resolver context\", resolver => {\n\t\t\t\t\t\tresolver.plugin(hook, fn);\n\t\t\t\t\t});\n\t\t\t\t}, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n\t\t\t\tapply: util.deprecate((...args) => {\n\t\t\t\t\tthis.resolverFactory.plugin(\"resolver context\", resolver => {\n\t\t\t\t\t\tresolver.apply(...args);\n\t\t\t\t\t});\n\t\t\t\t}, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n\t\t\t}\n\t\t};\n\n\t\t/** @type {WebpackOptions} */\n\t\tthis.options = /** @type {WebpackOptions} */ ({});\n\n\t\tthis.context = context;\n\n\t\tthis.requestShortener = new RequestShortener(context);\n\n\t\t/** @type {boolean} */\n\t\tthis.running = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.watchMode = false;\n\n\t\t/** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n\t\tthis._assetEmittingSourceCache = new WeakMap();\n\t\t/** @private @type {Map<string, number>} */\n\t\tthis._assetEmittingWrittenFiles = new Map();\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetInfrastructureLogger(name) {\n\t\tif (!name) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"Compiler.getInfrastructureLogger(name) called without a name\"\n\t\t\t);\n\t\t}\n\t\treturn new Logger((type, args) => {\n\t\t\tif (typeof name === \"function\") {\n\t\t\t\tname = name();\n\t\t\t\tif (!name) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.hooks.infrastructureLog.call(name, type, args) === undefined) {\n\t\t\t\tif (this.infrastructureLogger !== undefined) {\n\t\t\t\t\tthis.infrastructureLogger(name, type, args);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\twatch(watchOptions, handler) {\n\t\tif (this.running) return handler(new ConcurrentCompilationError());\n\n\t\tthis.running = true;\n\t\tthis.watchMode = true;\n\t\tthis.fileTimestamps = new Map();\n\t\tthis.contextTimestamps = new Map();\n\t\tthis.removedFiles = new Set();\n\t\treturn new Watching(this, watchOptions, handler);\n\t}\n\n\trun(callback) {\n\t\tif (this.running) return callback(new ConcurrentCompilationError());\n\n\t\tconst finalCallback = (err, stats) => {\n\t\t\tthis.running = false;\n\n\t\t\tif (err) {\n\t\t\t\tthis.hooks.failed.call(err);\n\t\t\t}\n\n\t\t\tif (callback !== undefined) return callback(err, stats);\n\t\t};\n\n\t\tconst startTime = Date.now();\n\n\t\tthis.running = true;\n\n\t\tconst onCompiled = (err, compilation) => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tif (this.hooks.shouldEmit.call(compilation) === false) {\n\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\tstats.startTime = startTime;\n\t\t\t\tstats.endTime = Date.now();\n\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis.emitAssets(compilation, err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tif (compilation.hooks.needAdditionalPass.call()) {\n\t\t\t\t\tcompilation.needAdditionalPass = true;\n\n\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\tstats.startTime = startTime;\n\t\t\t\t\tstats.endTime = Date.now();\n\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tthis.hooks.additionalPass.callAsync(err => {\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tthis.emitRecords(err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\tstats.startTime = startTime;\n\t\t\t\t\tstats.endTime = Date.now();\n\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tthis.hooks.beforeRun.callAsync(this, err => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tthis.hooks.run.callAsync(this, err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.readRecords(err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\trunAsChild(callback) {\n\t\tthis.compile((err, compilation) => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.parentCompilation.children.push(compilation);\n\t\t\tfor (const { name, source, info } of compilation.getAssets()) {\n\t\t\t\tthis.parentCompilation.emitAsset(name, source, info);\n\t\t\t}\n\n\t\t\tconst entries = Array.from(\n\t\t\t\tcompilation.entrypoints.values(),\n\t\t\t\tep => ep.chunks\n\t\t\t).reduce((array, chunks) => {\n\t\t\t\treturn array.concat(chunks);\n\t\t\t}, []);\n\n\t\t\treturn callback(null, entries, compilation);\n\t\t});\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tif (this.inputFileSystem && this.inputFileSystem.purge) {\n\t\t\tthis.inputFileSystem.purge();\n\t\t}\n\t}\n\n\temitAssets(compilation, callback) {\n\t\tlet outputPath;\n\t\tconst emitFiles = err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tasyncLib.forEachLimit(\n\t\t\t\tcompilation.getAssets(),\n\t\t\t\t15,\n\t\t\t\t({ name: file, source }, callback) => {\n\t\t\t\t\tlet targetFile = file;\n\t\t\t\t\tconst queryStringIdx = targetFile.indexOf(\"?\");\n\t\t\t\t\tif (queryStringIdx >= 0) {\n\t\t\t\t\t\ttargetFile = targetFile.substr(0, queryStringIdx);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst writeOut = err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tconst targetPath = this.outputFileSystem.join(\n\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\ttargetFile\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// TODO webpack 5 remove futureEmitAssets option and make it on by default\n\t\t\t\t\t\tif (this.options.output.futureEmitAssets) {\n\t\t\t\t\t\t\t// check if the target file has already been written by this Compiler\n\t\t\t\t\t\t\tconst targetFileGeneration = this._assetEmittingWrittenFiles.get(\n\t\t\t\t\t\t\t\ttargetPath\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// create an cache entry for this Source if not already existing\n\t\t\t\t\t\t\tlet cacheEntry = this._assetEmittingSourceCache.get(source);\n\t\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\t\tcacheEntry = {\n\t\t\t\t\t\t\t\t\tsizeOnlySource: undefined,\n\t\t\t\t\t\t\t\t\twrittenTo: new Map()\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tthis._assetEmittingSourceCache.set(source, cacheEntry);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if the target file has already been written\n\t\t\t\t\t\t\tif (targetFileGeneration !== undefined) {\n\t\t\t\t\t\t\t\t// check if the Source has been written to this target file\n\t\t\t\t\t\t\t\tconst writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n\t\t\t\t\t\t\t\tif (writtenGeneration === targetFileGeneration) {\n\t\t\t\t\t\t\t\t\t// if yes, we skip writing the file\n\t\t\t\t\t\t\t\t\t// as it's already there\n\t\t\t\t\t\t\t\t\t// (we assume one doesn't remove files while the Compiler is running)\n\n\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\t\t\tsize: cacheEntry.sizeOnlySource.size()\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// TODO webpack 5: if info.immutable check if file already exists in output\n\t\t\t\t\t\t\t// skip emitting if it's already there\n\n\t\t\t\t\t\t\t// get the binary (Buffer) content from the Source\n\t\t\t\t\t\t\t/** @type {Buffer} */\n\t\t\t\t\t\t\tlet content;\n\t\t\t\t\t\t\tif (typeof source.buffer === \"function\") {\n\t\t\t\t\t\t\t\tcontent = source.buffer();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst bufferOrString = source.source();\n\t\t\t\t\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\t\t\t\t\tcontent = bufferOrString;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontent = Buffer.from(bufferOrString, \"utf8\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Create a replacement resource which only allows to ask for size\n\t\t\t\t\t\t\t// This allows to GC all memory allocated by the Source\n\t\t\t\t\t\t\t// (expect when the Source is stored in any other cache)\n\t\t\t\t\t\t\tcacheEntry.sizeOnlySource = new SizeOnlySource(content.length);\n\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\tsize: content.length\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// Write the file to output file system\n\t\t\t\t\t\t\tthis.outputFileSystem.writeFile(targetPath, content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t// information marker that the asset has been emitted\n\t\t\t\t\t\t\t\tcompilation.emittedAssets.add(file);\n\n\t\t\t\t\t\t\t\t// cache the information that the Source has been written to that location\n\t\t\t\t\t\t\t\tconst newGeneration =\n\t\t\t\t\t\t\t\t\ttargetFileGeneration === undefined\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: targetFileGeneration + 1;\n\t\t\t\t\t\t\t\tcacheEntry.writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis.hooks.assetEmitted.callAsync(file, content, callback);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (source.existsAt === targetPath) {\n\t\t\t\t\t\t\t\tsource.emitted = false;\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet content = source.source();\n\n\t\t\t\t\t\t\tif (!Buffer.isBuffer(content)) {\n\t\t\t\t\t\t\t\tcontent = Buffer.from(content, \"utf8\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsource.existsAt = targetPath;\n\t\t\t\t\t\t\tsource.emitted = true;\n\t\t\t\t\t\t\tthis.outputFileSystem.writeFile(targetPath, content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tthis.hooks.assetEmitted.callAsync(file, content, callback);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (targetFile.match(/\\/|\\\\/)) {\n\t\t\t\t\t\tconst dir = path.dirname(targetFile);\n\t\t\t\t\t\tthis.outputFileSystem.mkdirp(\n\t\t\t\t\t\t\tthis.outputFileSystem.join(outputPath, dir),\n\t\t\t\t\t\t\twriteOut\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteOut();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tthis.hooks.afterEmit.callAsync(compilation, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tthis.hooks.emit.callAsync(compilation, err => {\n\t\t\tif (err) return callback(err);\n\t\t\toutputPath = compilation.getPath(this.outputPath);\n\t\t\tthis.outputFileSystem.mkdirp(outputPath, emitFiles);\n\t\t});\n\t}\n\n\temitRecords(callback) {\n\t\tif (!this.recordsOutputPath) return callback();\n\t\tconst idx1 = this.recordsOutputPath.lastIndexOf(\"/\");\n\t\tconst idx2 = this.recordsOutputPath.lastIndexOf(\"\\\\\");\n\t\tlet recordsOutputPathDirectory = null;\n\t\tif (idx1 > idx2) {\n\t\t\trecordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);\n\t\t} else if (idx1 < idx2) {\n\t\t\trecordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);\n\t\t}\n\n\t\tconst writeFile = () => {\n\t\t\tthis.outputFileSystem.writeFile(\n\t\t\t\tthis.recordsOutputPath,\n\t\t\t\tJSON.stringify(this.records, undefined, 2),\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\n\t\tif (!recordsOutputPathDirectory) {\n\t\t\treturn writeFile();\n\t\t}\n\t\tthis.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => {\n\t\t\tif (err) return callback(err);\n\t\t\twriteFile();\n\t\t});\n\t}\n\n\treadRecords(callback) {\n\t\tif (!this.recordsInputPath) {\n\t\t\tthis.records = {};\n\t\t\treturn callback();\n\t\t}\n\t\tthis.inputFileSystem.stat(this.recordsInputPath, err => {\n\t\t\t// It doesn't exist\n\t\t\t// We can ignore this.\n\t\t\tif (err) return callback();\n\n\t\t\tthis.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\ttry {\n\t\t\t\t\tthis.records = parseJson(content.toString(\"utf-8\"));\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.message = \"Cannot parse records: \" + e.message;\n\t\t\t\t\treturn callback(e);\n\t\t\t\t}\n\n\t\t\t\treturn callback();\n\t\t\t});\n\t\t});\n\t}\n\n\tcreateChildCompiler(\n\t\tcompilation,\n\t\tcompilerName,\n\t\tcompilerIndex,\n\t\toutputOptions,\n\t\tplugins\n\t) {\n\t\tconst childCompiler = new Compiler(this.context);\n\t\tif (Array.isArray(plugins)) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tplugin.apply(childCompiler);\n\t\t\t}\n\t\t}\n\t\tfor (const name in this.hooks) {\n\t\t\tif (\n\t\t\t\t![\n\t\t\t\t\t\"make\",\n\t\t\t\t\t\"compile\",\n\t\t\t\t\t\"emit\",\n\t\t\t\t\t\"afterEmit\",\n\t\t\t\t\t\"invalid\",\n\t\t\t\t\t\"done\",\n\t\t\t\t\t\"thisCompilation\"\n\t\t\t\t].includes(name)\n\t\t\t) {\n\t\t\t\tif (childCompiler.hooks[name]) {\n\t\t\t\t\tchildCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchildCompiler.name = compilerName;\n\t\tchildCompiler.outputPath = this.outputPath;\n\t\tchildCompiler.inputFileSystem = this.inputFileSystem;\n\t\tchildCompiler.outputFileSystem = null;\n\t\tchildCompiler.resolverFactory = this.resolverFactory;\n\t\tchildCompiler.fileTimestamps = this.fileTimestamps;\n\t\tchildCompiler.contextTimestamps = this.contextTimestamps;\n\n\t\tconst relativeCompilerName = makePathsRelative(this.context, compilerName);\n\t\tif (!this.records[relativeCompilerName]) {\n\t\t\tthis.records[relativeCompilerName] = [];\n\t\t}\n\t\tif (this.records[relativeCompilerName][compilerIndex]) {\n\t\t\tchildCompiler.records = this.records[relativeCompilerName][compilerIndex];\n\t\t} else {\n\t\t\tthis.records[relativeCompilerName].push((childCompiler.records = {}));\n\t\t}\n\n\t\tchildCompiler.options = Object.create(this.options);\n\t\tchildCompiler.options.output = Object.create(childCompiler.options.output);\n\t\tfor (const name in outputOptions) {\n\t\t\tchildCompiler.options.output[name] = outputOptions[name];\n\t\t}\n\t\tchildCompiler.parentCompilation = compilation;\n\n\t\tcompilation.hooks.childCompiler.call(\n\t\t\tchildCompiler,\n\t\t\tcompilerName,\n\t\t\tcompilerIndex\n\t\t);\n\n\t\treturn childCompiler;\n\t}\n\n\tisChild() {\n\t\treturn !!this.parentCompilation;\n\t}\n\n\tcreateCompilation() {\n\t\treturn new Compilation(this);\n\t}\n\n\tnewCompilation(params) {\n\t\tconst compilation = this.createCompilation();\n\t\tcompilation.fileTimestamps = this.fileTimestamps;\n\t\tcompilation.contextTimestamps = this.contextTimestamps;\n\t\tcompilation.name = this.name;\n\t\tcompilation.records = this.records;\n\t\tcompilation.compilationDependencies = params.compilationDependencies;\n\t\tthis.hooks.thisCompilation.call(compilation, params);\n\t\tthis.hooks.compilation.call(compilation, params);\n\t\treturn compilation;\n\t}\n\n\tcreateNormalModuleFactory() {\n\t\tconst normalModuleFactory = new NormalModuleFactory(\n\t\t\tthis.options.context,\n\t\t\tthis.resolverFactory,\n\t\t\tthis.options.module || {}\n\t\t);\n\t\tthis.hooks.normalModuleFactory.call(normalModuleFactory);\n\t\treturn normalModuleFactory;\n\t}\n\n\tcreateContextModuleFactory() {\n\t\tconst contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n\t\tthis.hooks.contextModuleFactory.call(contextModuleFactory);\n\t\treturn contextModuleFactory;\n\t}\n\n\tnewCompilationParams() {\n\t\tconst params = {\n\t\t\tnormalModuleFactory: this.createNormalModuleFactory(),\n\t\t\tcontextModuleFactory: this.createContextModuleFactory(),\n\t\t\tcompilationDependencies: new Set()\n\t\t};\n\t\treturn params;\n\t}\n\n\tcompile(callback) {\n\t\tconst params = this.newCompilationParams();\n\t\tthis.hooks.beforeCompile.callAsync(params, err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.hooks.compile.call(params);\n\n\t\t\tconst compilation = this.newCompilation(params);\n\n\t\t\tthis.hooks.make.callAsync(compilation, err => {\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\tcompilation.finish(err => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tcompilation.seal(err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tthis.hooks.afterCompile.callAsync(compilation, err => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\treturn callback(null, compilation);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n}\n\nmodule.exports = Compiler;\n\nclass SizeOnlySource extends Source {\n\tconstructor(size) {\n\t\tsuper();\n\t\tthis._size = size;\n\t}\n\n\t_error() {\n\t\treturn new Error(\n\t\t\t\"Content and Map of this Source is no longer available (only size() is supported)\"\n\t\t);\n\t}\n\n\tsize() {\n\t\treturn this._size;\n\t}\n\n\t/**\n\t * @param {any} options options\n\t * @returns {string} the source\n\t */\n\tsource(options) {\n\t\tthrow this._error();\n\t}\n\n\tnode() {\n\t\tthrow this._error();\n\t}\n\n\tlistMap() {\n\t\tthrow this._error();\n\t}\n\n\tmap() {\n\t\tthrow this._error();\n\t}\n\n\tlistNode() {\n\t\tthrow this._error();\n\t}\n\n\tupdateHash() {\n\t\tthrow this._error();\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}