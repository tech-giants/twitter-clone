{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nimport { codeFrameFromSource } from \"@webassemblyjs/helper-code-frame\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { parse32I } from \"./number-literals\";\nimport { parseString } from \"./string-literals\";\nimport { tokens, keywords } from \"./tokenizer\";\n\nfunction hasPlugin(name) {\n  if (name !== \"wast\") throw new Error(\"unknow plugin\");\n  return true;\n}\n\nfunction isKeyword(token, id) {\n  return token.type === tokens.keyword && token.value === id;\n}\n\nfunction tokenToString(token) {\n  if (token.type === \"keyword\") {\n    return \"keyword (\".concat(token.value, \")\");\n  }\n\n  return token.type;\n}\n\nfunction identifierFromToken(token) {\n  var _token$loc = token.loc,\n      end = _token$loc.end,\n      start = _token$loc.start;\n  return t.withLoc(t.identifier(token.value), end, start);\n}\n\nexport function parse(tokensList, source) {\n  var current = 0;\n  var getUniqueName = t.getUniqueNameGenerator();\n  var state = {\n    registredExportedElements: []\n  }; // But this time we're going to use recursion instead of a `while` loop. So we\n  // define a `walk` function.\n\n  function walk() {\n    var token = tokensList[current];\n\n    function eatToken() {\n      token = tokensList[++current];\n    }\n\n    function getEndLoc() {\n      var currentToken = token;\n\n      if (typeof currentToken === \"undefined\") {\n        var lastToken = tokensList[tokensList.length - 1];\n        currentToken = lastToken;\n      }\n\n      return currentToken.loc.end;\n    }\n\n    function getStartLoc() {\n      return token.loc.start;\n    }\n\n    function eatTokenOfType(type) {\n      if (token.type !== type) {\n        throw new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"Assertion error: expected token of type \" + type + \", given \" + tokenToString(token));\n      }\n\n      eatToken();\n    }\n\n    function parseExportIndex(token) {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return index;\n      } else if (token.type === tokens.number) {\n        var _index = t.numberLiteralFromRaw(token.value);\n\n        eatToken();\n        return _index;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"unknown export index\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n\n    function lookaheadAndCheck() {\n      var len = arguments.length;\n\n      for (var i = 0; i < len; i++) {\n        var tokenAhead = tokensList[current + i];\n        var expectedToken = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (tokenAhead.type === \"keyword\") {\n          if (isKeyword(tokenAhead, expectedToken) === false) {\n            return false;\n          }\n        } else if (expectedToken !== tokenAhead.type) {\n          return false;\n        }\n      }\n\n      return true;\n    } // TODO(sven): there is probably a better way to do this\n    // can refactor it if it get out of hands\n\n\n    function maybeIgnoreComment() {\n      if (typeof token === \"undefined\") {\n        // Ignore\n        return;\n      }\n\n      while (token.type === tokens.comment) {\n        eatToken();\n\n        if (typeof token === \"undefined\") {\n          // Hit the end\n          break;\n        }\n      }\n    }\n    /**\n     * Parses a memory instruction\n     *\n     * WAST:\n     *\n     * memory:  ( memory <name>? <memory_sig> )\n     *          ( memory <name>? ( export <string> ) <...> )\n     *          ( memory <name>? ( import <string> <string> ) <memory_sig> )\n     *          ( memory <name>? ( export <string> )* ( data <string>* )\n     * memory_sig: <nat> <nat>?\n     *\n     */\n\n\n    function parseMemory() {\n      var id = t.identifier(getUniqueName(\"memory\"));\n      var limits = t.limit(0);\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        id = t.identifier(token.value);\n        eatToken();\n      } else {\n        id = t.withRaw(id, \"\"); // preserve anonymous\n      }\n      /**\n       * Maybe data\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.data)) {\n        eatToken(); // (\n\n        eatToken(); // data\n        // TODO(sven): do something with the data collected here\n\n        var stringInitializer = token.value;\n        eatTokenOfType(tokens.string); // Update limits accordingly\n\n        limits = t.limit(stringInitializer.length);\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        if (token.type !== tokens.string) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var _name = token.value;\n        eatToken();\n        state.registredExportedElements.push({\n          exportType: \"Memory\",\n          name: _name,\n          id: id\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Memory signature\n       */\n\n\n      if (token.type === tokens.number) {\n        limits = t.limit(parse32I(token.value));\n        eatToken();\n\n        if (token.type === tokens.number) {\n          limits.max = parse32I(token.value);\n          eatToken();\n        }\n      }\n\n      return t.memory(limits, id);\n    }\n    /**\n     * Parses a data section\n     * https://webassembly.github.io/spec/core/text/modules.html#data-segments\n     *\n     * WAST:\n     *\n     * data:  ( data <index>? <offset> <string> )\n     */\n\n\n    function parseData() {\n      // optional memory index\n      var memidx = 0;\n\n      if (token.type === tokens.number) {\n        memidx = token.value;\n        eatTokenOfType(tokens.number); // .\n      }\n\n      eatTokenOfType(tokens.openParen);\n      var offset;\n\n      if (token.type === tokens.valtype) {\n        eatTokenOfType(tokens.valtype); // i32\n\n        eatTokenOfType(tokens.dot); // .\n\n        if (token.value !== \"const\") {\n          throw new Error(\"constant expression required\");\n        }\n\n        eatTokenOfType(tokens.name); // const\n\n        var numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n        offset = t.objectInstruction(\"const\", \"i32\", [numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      } else {\n        eatTokenOfType(tokens.name); // get_global\n\n        var _numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n\n        offset = t.instruction(\"get_global\", [_numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      var byteArray = parseString(token.value);\n      eatToken(); // \"string\"\n\n      return t.data(t.memIndexLiteral(memidx), offset, t.byteArray(byteArray));\n    }\n    /**\n     * Parses a table instruction\n     *\n     * WAST:\n     *\n     * table:   ( table <name>? <table_type> )\n     *          ( table <name>? ( export <string> ) <...> )\n     *          ( table <name>? ( import <string> <string> ) <table_type> )\n     *          ( table <name>? ( export <string> )* <elem_type> ( elem <var>* ) )\n     *\n     * table_type:  <nat> <nat>? <elem_type>\n     * elem_type: anyfunc\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     */\n\n\n    function parseTable() {\n      var name = t.identifier(getUniqueName(\"table\"));\n      var limit = t.limit(0);\n      var elemIndices = [];\n      var elemType = \"anyfunc\";\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n\n      while (token.type !== tokens.closeParen) {\n        /**\n         * Maybe export\n         */\n        if (lookaheadAndCheck(tokens.openParen, keywords.elem)) {\n          eatToken(); // (\n\n          eatToken(); // elem\n\n          while (token.type === tokens.identifier) {\n            elemIndices.push(t.identifier(token.value));\n            eatToken();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n          eatToken(); // (\n\n          eatToken(); // export\n\n          if (token.type !== tokens.string) {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          var exportName = token.value;\n          eatToken();\n          state.registredExportedElements.push({\n            exportType: \"Table\",\n            name: exportName,\n            id: name\n          });\n          eatTokenOfType(tokens.closeParen);\n        } else if (isKeyword(token, keywords.anyfunc)) {\n          // It's the default value, we can ignore it\n          eatToken(); // anyfunc\n        } else if (token.type === tokens.number) {\n          /**\n           * Table type\n           */\n          var min = parseInt(token.value);\n          eatToken();\n\n          if (token.type === tokens.number) {\n            var max = parseInt(token.value);\n            eatToken();\n            limit = t.limit(min, max);\n          } else {\n            limit = t.limit(min);\n          }\n\n          eatToken();\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      if (elemIndices.length > 0) {\n        return t.table(elemType, limit, name, elemIndices);\n      } else {\n        return t.table(elemType, limit, name);\n      }\n    }\n    /**\n     * Parses an import statement\n     *\n     * WAST:\n     *\n     * import:  ( import <string> <string> <imkind> )\n     * imkind:  ( func <name>? <func_sig> )\n     *          ( global <name>? <global_sig> )\n     *          ( table <name>? <table_sig> )\n     *          ( memory <name>? <memory_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     */\n\n\n    function parseImport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var moduleName = token.value;\n      eatToken();\n\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var name = token.value;\n      eatToken();\n      eatTokenOfType(tokens.openParen);\n      var descr;\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken(); // keyword\n\n        var fnParams = [];\n        var fnResult = [];\n        var typeRef;\n        var fnName = t.identifier(getUniqueName(\"func\"));\n\n        if (token.type === tokens.identifier) {\n          fnName = identifierFromToken(token);\n          eatToken();\n        }\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n\n          if (lookaheadAndCheck(keywords.type) === true) {\n            eatToken();\n            typeRef = parseTypeReference();\n          } else if (lookaheadAndCheck(keywords.param) === true) {\n            eatToken();\n            fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n          } else if (lookaheadAndCheck(keywords.result) === true) {\n            eatToken();\n            fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in import of type\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof fnName === \"undefined\") {\n          throw new Error(\"Imported function must have a name\");\n        }\n\n        descr = t.funcImportDescr(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult));\n      } else if (isKeyword(token, keywords.global)) {\n        eatToken(); // keyword\n\n        if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          eatTokenOfType(tokens.keyword); // mut keyword\n\n          var valtype = token.value;\n          eatToken();\n          descr = t.globalType(valtype, \"var\");\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          var _valtype = token.value;\n          eatTokenOfType(tokens.valtype);\n          descr = t.globalType(_valtype, \"const\");\n        }\n      } else if (isKeyword(token, keywords.memory) === true) {\n        eatToken(); // Keyword\n\n        descr = parseMemory();\n      } else if (isKeyword(token, keywords.table) === true) {\n        eatToken(); // Keyword\n\n        descr = parseTable();\n      } else {\n        throw new Error(\"Unsupported import type: \" + tokenToString(token));\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.moduleImport(moduleName, name, descr);\n    }\n    /**\n     * Parses a block instruction\n     *\n     * WAST:\n     *\n     * expr: ( block <name>? <block_sig> <instr>* )\n     * instr: block <name>? <block_sig> <instr>* end <name>?\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseBlock() {\n      var label = t.identifier(getUniqueName(\"block\"));\n      var blockResult = null;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          instr.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in block body of type\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.blockInstruction(label, instr, blockResult);\n    }\n    /**\n     * Parses a if instruction\n     *\n     * WAST:\n     *\n     * expr:\n     * ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     * ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * instr:\n     * if <name>? <block_sig> <instr>* end <name>?\n     * if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseIf() {\n      var blockResult = null;\n      var label = t.identifier(getUniqueName(\"if\"));\n      var testInstrs = [];\n      var consequent = [];\n      var alternate = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        /**\n         * Block signature\n         */\n\n        if (isKeyword(token, keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatTokenOfType(tokens.valtype);\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Then\n         */\n\n\n        if (isKeyword(token, keywords.then) === true) {\n          eatToken(); // then\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n              consequent.push(parseFuncInstr());\n            } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in consequent body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Alternate\n         */\n\n\n        if (isKeyword(token, keywords.else)) {\n          eatToken(); // else\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n              alternate.push(parseFuncInstr());\n            } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in alternate body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Test instruction\n         */\n\n\n        if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          testInstrs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in if body\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      return t.ifInstruction(label, testInstrs, blockResult, consequent, alternate);\n    }\n    /**\n     * Parses a loop instruction\n     *\n     * WAT:\n     *\n     * blockinstr :: 'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *\n     * WAST:\n     *\n     * instr     :: loop <name>? <block_sig> <instr>* end <name>?\n     * expr      :: ( loop <name>? <block_sig> <instr>* )\n     * block_sig :: ( result <type>* )*\n     *\n     */\n\n\n    function parseLoop() {\n      var label = t.identifier(getUniqueName(\"loop\"));\n      var blockResult;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          instr.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in loop body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.loopInstruction(label, blockResult, instr);\n    }\n\n    function parseCallIndirect() {\n      var typeRef;\n      var params = [];\n      var results = [];\n      var instrs = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.type)) {\n          eatToken(); // (\n\n          eatToken(); // type\n\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          /**\n           * Params can be empty:\n           * (params)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            params.push.apply(params, _toConsumableArray(parseFuncParam()));\n          }\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          /**\n           * Results can be empty:\n           * (result)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            results.push.apply(results, _toConsumableArray(parseFuncResult()));\n          }\n        } else {\n          eatTokenOfType(tokens.openParen);\n          instrs.push(parseFuncInstr());\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.callIndirectInstruction(typeRef !== undefined ? typeRef : t.signature(params, results), instrs);\n    }\n    /**\n     * Parses an export instruction\n     *\n     * WAT:\n     *\n     * export:  ( export <string> <exkind> )\n     * exkind:  ( func <var> )\n     *          ( global <var> )\n     *          ( table <var> )\n     *          ( memory <var> )\n     * var:    <nat> | <name>\n     *\n     */\n\n\n    function parseExport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected string after export, got: \" + token.type);\n      }\n\n      var name = token.value;\n      eatToken();\n      var moduleExportDescr = parseModuleExportDescr();\n      return t.moduleExport(name, moduleExportDescr);\n    }\n\n    function parseModuleExportDescr() {\n      var startLoc = getStartLoc();\n      var type = \"\";\n      var index;\n      eatTokenOfType(tokens.openParen);\n\n      while (token.type !== tokens.closeParen) {\n        if (isKeyword(token, keywords.func)) {\n          type = \"Func\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.table)) {\n          type = \"Table\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.global)) {\n          type = \"Global\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.memory)) {\n          type = \"Memory\";\n          eatToken();\n          index = parseExportIndex(token);\n        }\n\n        eatToken();\n      }\n\n      if (type === \"\") {\n        throw new Error(\"Unknown export type\");\n      }\n\n      if (index === undefined) {\n        throw new Error(\"Exported function must have a name\");\n      }\n\n      var node = t.moduleExportDescr(type, index);\n      var endLoc = getEndLoc();\n      eatTokenOfType(tokens.closeParen);\n      return t.withLoc(node, endLoc, startLoc);\n    }\n\n    function parseModule() {\n      var name = null;\n      var isBinary = false;\n      var isQuote = false;\n      var moduleFields = [];\n\n      if (token.type === tokens.identifier) {\n        name = token.value;\n        eatToken();\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"binary\") {\n        eatToken();\n        isBinary = true;\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"quote\") {\n        eatToken();\n        isQuote = true;\n      }\n\n      if (isBinary === true) {\n        var blob = [];\n\n        while (token.type === tokens.string) {\n          blob.push(token.value);\n          eatToken();\n          maybeIgnoreComment();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.binaryModule(name, blob);\n      }\n\n      if (isQuote === true) {\n        var string = [];\n\n        while (token.type === tokens.string) {\n          string.push(token.value);\n          eatToken();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.quoteModule(name, string);\n      }\n\n      while (token.type !== tokens.closeParen) {\n        moduleFields.push(walk());\n\n        if (state.registredExportedElements.length > 0) {\n          state.registredExportedElements.forEach(function (decl) {\n            moduleFields.push(t.moduleExport(decl.name, t.moduleExportDescr(decl.exportType, decl.id)));\n          });\n          state.registredExportedElements = [];\n        }\n\n        token = tokensList[current];\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.module(name, moduleFields);\n    }\n    /**\n     * Parses the arguments of an instruction\n     */\n\n\n    function parseFuncInstrArguments(signature) {\n      var args = [];\n      var namedArgs = {};\n      var signaturePtr = 0;\n\n      while (token.type === tokens.name || isKeyword(token, keywords.offset)) {\n        var key = token.value;\n        eatToken();\n        eatTokenOfType(tokens.equal);\n        var value = void 0;\n\n        if (token.type === tokens.number) {\n          value = t.numberLiteralFromRaw(token.value);\n        } else {\n          throw new Error(\"Unexpected type for argument: \" + token.type);\n        }\n\n        namedArgs[key] = value;\n        eatToken();\n      } // $FlowIgnore\n\n\n      var signatureLength = signature.vector ? Infinity : signature.length;\n\n      while (token.type !== tokens.closeParen && ( // $FlowIgnore\n      token.type === tokens.openParen || signaturePtr < signatureLength)) {\n        if (token.type === tokens.identifier) {\n          args.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.valtype) {\n          // Handle locals\n          args.push(t.valtypeLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.string) {\n          args.push(t.stringLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          args.push( // TODO(sven): refactor the type signature handling\n          // https://github.com/xtuc/webassemblyjs/pull/129 is a good start\n          t.numberLiteralFromRaw(token.value, // $FlowIgnore\n          signature[signaturePtr] || \"f64\")); // $FlowIgnore\n\n          if (!signature.vector) {\n            ++signaturePtr;\n          }\n\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          /**\n           * Maybe some nested instructions\n           */\n          eatToken(); // Instruction\n\n          if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n          ) {\n            // $FlowIgnore\n            args.push(parseFuncInstr());\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in nested instruction\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          if (token.type === tokens.closeParen) {\n            eatToken();\n          }\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in instruction argument\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return {\n        args: args,\n        namedArgs: namedArgs\n      };\n    }\n    /**\n     * Parses an instruction\n     *\n     * WAT:\n     *\n     * instr      :: plaininst\n     *               blockinstr\n     *\n     * blockinstr :: 'block' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'if' I:label rt:resulttype (in:instr*) 'else' id? (in2:intr*) 'end' id?\n     *\n     * plaininst  :: 'unreachable'\n     *               'nop'\n     *               'br' l:labelidx\n     *               'br_if' l:labelidx\n     *               'br_table' l*:vec(labelidx) ln:labelidx\n     *               'return'\n     *               'call' x:funcidx\n     *               'call_indirect' x, I:typeuse\n     *\n     * WAST:\n     *\n     * instr:\n     *   <expr>\n     *   <op>\n     *   block <name>? <block_sig> <instr>* end <name>?\n     *   loop <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * expr:\n     *   ( <op> )\n     *   ( <op> <expr>+ )\n     *   ( block <name>? <block_sig> <instr>* )\n     *   ( loop <name>? <block_sig> <instr>* )\n     *   ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     *   ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * op:\n     *   unreachable\n     *   nop\n     *   br <var>\n     *   br_if <var>\n     *   br_table <var>+\n     *   return\n     *   call <var>\n     *   call_indirect <func_sig>\n     *   drop\n     *   select\n     *   get_local <var>\n     *   set_local <var>\n     *   tee_local <var>\n     *   get_global <var>\n     *   set_global <var>\n     *   <type>.load((8|16|32)_<sign>)? <offset>? <align>?\n     *   <type>.store(8|16|32)? <offset>? <align>?\n     *   current_memory\n     *   grow_memory\n     *   <type>.const <value>\n     *   <type>.<unop>\n     *   <type>.<binop>\n     *   <type>.<testop>\n     *   <type>.<relop>\n     *   <type>.<cvtop>/<type>\n     *\n     * func_type:   ( type <var> )? <param>* <result>*\n     */\n\n\n    function parseFuncInstr() {\n      var startLoc = getStartLoc();\n      maybeIgnoreComment();\n      /**\n       * A simple instruction\n       */\n\n      if (token.type === tokens.name || token.type === tokens.valtype) {\n        var _name2 = token.value;\n        var object;\n        eatToken();\n\n        if (token.type === tokens.dot) {\n          object = _name2;\n          eatToken();\n\n          if (token.type !== tokens.name) {\n            throw new TypeError(\"Unknown token: \" + token.type + \", name expected\");\n          }\n\n          _name2 = token.value;\n          eatToken();\n        }\n\n        if (token.type === tokens.closeParen) {\n          var _endLoc = token.loc.end;\n\n          if (typeof object === \"undefined\") {\n            return t.withLoc(t.instruction(_name2), _endLoc, startLoc);\n          } else {\n            return t.withLoc(t.objectInstruction(_name2, object, []), _endLoc, startLoc);\n          }\n        }\n\n        var signature = t.signatureForOpcode(object || \"\", _name2);\n\n        var _parseFuncInstrArgume = parseFuncInstrArguments(signature),\n            _args = _parseFuncInstrArgume.args,\n            _namedArgs = _parseFuncInstrArgume.namedArgs;\n\n        var endLoc = token.loc.end;\n\n        if (typeof object === \"undefined\") {\n          return t.withLoc(t.instruction(_name2, _args, _namedArgs), endLoc, startLoc);\n        } else {\n          return t.withLoc(t.objectInstruction(_name2, object, _args, _namedArgs), endLoc, startLoc);\n        }\n      } else if (isKeyword(token, keywords.loop)) {\n        /**\n         * Else a instruction with a keyword (loop or block)\n         */\n        eatToken(); // keyword\n\n        return parseLoop();\n      } else if (isKeyword(token, keywords.block)) {\n        eatToken(); // keyword\n\n        return parseBlock();\n      } else if (isKeyword(token, keywords.call_indirect)) {\n        eatToken(); // keyword\n\n        return parseCallIndirect();\n      } else if (isKeyword(token, keywords.call)) {\n        eatToken(); // keyword\n\n        var index;\n\n        if (token.type === tokens.identifier) {\n          index = identifierFromToken(token);\n          eatToken();\n        } else if (token.type === tokens.number) {\n          index = t.indexLiteral(token.value);\n          eatToken();\n        }\n\n        var instrArgs = []; // Nested instruction\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n          instrArgs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof index === \"undefined\") {\n          throw new Error(\"Missing argument in call instruciton\");\n        }\n\n        if (instrArgs.length > 0) {\n          return t.callInstruction(index, instrArgs);\n        } else {\n          return t.callInstruction(index);\n        }\n      } else if (isKeyword(token, keywords.if)) {\n        eatToken(); // Keyword\n\n        return parseIf();\n      } else if (isKeyword(token, keywords.module) && hasPlugin(\"wast\")) {\n        eatToken(); // In WAST you can have a module as an instruction's argument\n        // we will cast it into a instruction to not break the flow\n        // $FlowIgnore\n\n        var module = parseModule();\n        return module;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected instruction in function body\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n    /*\n     * Parses a function\n     *\n     * WAT:\n     *\n     * functype :: ( 'func' t1:vec(param) t2:vec(result) )\n     * param    :: ( 'param' id? t:valtype )\n     * result   :: ( 'result' t:valtype )\n     *\n     * WAST:\n     *\n     * func     :: ( func <name>? <func_sig> <local>* <instr>* )\n     *             ( func <name>? ( export <string> ) <...> )\n     *             ( func <name>? ( import <string> <string> ) <func_sig> )\n     * func_sig :: ( type <var> )? <param>* <result>*\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     * result   :: ( result <type>* )\n     * local    :: ( local <type>* ) | ( local <name> <type> )\n     *\n     */\n\n\n    function parseFunc() {\n      var fnName = t.identifier(getUniqueName(\"func\"));\n      var typeRef;\n      var fnBody = [];\n      var fnParams = [];\n      var fnResult = []; // name\n\n      if (token.type === tokens.identifier) {\n        fnName = identifierFromToken(token);\n        eatToken();\n      } else {\n        fnName = t.withRaw(fnName, \"\"); // preserve anonymous\n      }\n\n      maybeIgnoreComment();\n\n      while (token.type === tokens.openParen || token.type === tokens.name || token.type === tokens.valtype) {\n        // Instructions without parens\n        if (token.type === tokens.name || token.type === tokens.valtype) {\n          fnBody.push(parseFuncInstr());\n          continue;\n        }\n\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.param) === true) {\n          eatToken();\n          fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n        } else if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n        } else if (lookaheadAndCheck(keywords.export) === true) {\n          eatToken();\n          parseFuncExport(fnName);\n        } else if (lookaheadAndCheck(keywords.type) === true) {\n          eatToken();\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n          // Instruction\n          fnBody.push(parseFuncInstr());\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.func(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult), fnBody);\n    }\n    /**\n     * Parses shorthand export in func\n     *\n     * export :: ( export <string> )\n     */\n\n\n    function parseFuncExport(funcId) {\n      if (token.type !== tokens.string) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Function export expected a string\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      var name = token.value;\n      eatToken();\n      /**\n       * Func export shorthand, we trait it as a syntaxic sugar.\n       * A export ModuleField will be added later.\n       *\n       * We give the anonymous function a generated name and export it.\n       */\n\n      var id = t.identifier(funcId.value);\n      state.registredExportedElements.push({\n        exportType: \"Func\",\n        name: name,\n        id: id\n      });\n    }\n    /**\n     * Parses a type instruction\n     *\n     * WAST:\n     *\n     * typedef: ( type <name>? ( func <param>* <result>* ) )\n     */\n\n\n    function parseType() {\n      var id;\n      var params = [];\n      var result = [];\n\n      if (token.type === tokens.identifier) {\n        id = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.func)) {\n        eatToken(); // (\n\n        eatToken(); // func\n\n        if (token.type === tokens.closeParen) {\n          eatToken(); // function with an empty signature, we can abort here\n\n          return t.typeInstruction(id, t.signature([], []));\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          params = parseFuncParam();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          result = parseFuncResult();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.typeInstruction(id, t.signature(params, result));\n    }\n    /**\n     * Parses a function result\n     *\n     * WAST:\n     *\n     * result :: ( result <type>* )\n     */\n\n\n    function parseFuncResult() {\n      var results = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (token.type !== tokens.valtype) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func result\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var valtype = token.value;\n        eatToken();\n        results.push(valtype);\n      }\n\n      return results;\n    }\n    /**\n     * Parses a type reference\n     *\n     */\n\n\n    function parseTypeReference() {\n      var ref;\n\n      if (token.type === tokens.identifier) {\n        ref = identifierFromToken(token);\n        eatToken();\n      } else if (token.type === tokens.number) {\n        ref = t.numberLiteralFromRaw(token.value);\n        eatToken();\n      }\n\n      return ref;\n    }\n    /**\n     * Parses a global instruction\n     *\n     * WAST:\n     *\n     * global:  ( global <name>? <global_sig> <instr>* )\n     *          ( global <name>? ( export <string> ) <...> )\n     *          ( global <name>? ( import <string> <string> ) <global_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     *\n     */\n\n\n    function parseGlobal() {\n      var name = t.identifier(getUniqueName(\"global\"));\n      var type; // Keep informations in case of a shorthand import\n\n      var importing = null;\n      maybeIgnoreComment();\n\n      if (token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n      /**\n       * maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        var exportName = token.value;\n        eatTokenOfType(tokens.string);\n        state.registredExportedElements.push({\n          exportType: \"Global\",\n          name: exportName,\n          id: name\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * maybe import\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.import)) {\n        eatToken(); // (\n\n        eatToken(); // import\n\n        var moduleName = token.value;\n        eatTokenOfType(tokens.string);\n        var _name3 = token.value;\n        eatTokenOfType(tokens.string);\n        importing = {\n          module: moduleName,\n          name: _name3,\n          descr: undefined\n        };\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * global_sig\n       */\n\n\n      if (token.type === tokens.valtype) {\n        type = t.globalType(token.value, \"const\");\n        eatToken();\n      } else if (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        if (isKeyword(token, keywords.mut) === false) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported global type, expected mut\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatToken(); // mut\n\n        type = t.globalType(token.value, \"var\");\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      if (type === undefined) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Could not determine global type\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      maybeIgnoreComment();\n      var init = [];\n\n      if (importing != null) {\n        importing.descr = type;\n        init.push(t.moduleImport(importing.module, importing.name, importing.descr));\n      }\n      /**\n       * instr*\n       */\n\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n        init.push(parseFuncInstr());\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.global(type, init, name);\n    }\n    /**\n     * Parses a function param\n     *\n     * WAST:\n     *\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     */\n\n\n    function parseFuncParam() {\n      var params = [];\n      var id;\n      var valtype;\n\n      if (token.type === tokens.identifier) {\n        id = token.value;\n        eatToken();\n      }\n\n      if (token.type === tokens.valtype) {\n        valtype = token.value;\n        eatToken();\n        params.push({\n          id: id,\n          valtype: valtype\n        });\n        /**\n         * Shorthand notation for multiple anonymous parameters\n         * @see https://webassembly.github.io/spec/core/text/types.html#function-types\n         * @see https://github.com/xtuc/webassemblyjs/issues/6\n         */\n\n        if (id === undefined) {\n          while (token.type === tokens.valtype) {\n            valtype = token.value;\n            eatToken();\n            params.push({\n              id: undefined,\n              valtype: valtype\n            });\n          }\n        }\n      } else {// ignore\n      }\n\n      return params;\n    }\n    /**\n     * Parses an element segments instruction\n     *\n     * WAST:\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     *\n     * var:    <nat> | <name>\n     */\n\n\n    function parseElem() {\n      var tableIndex = t.indexLiteral(0);\n      var offset = [];\n      var funcs = [];\n\n      if (token.type === tokens.identifier) {\n        tableIndex = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (token.type === tokens.number) {\n        tableIndex = t.indexLiteral(token.value);\n        eatToken();\n      }\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.offset)) {\n          eatToken(); // (\n\n          eatToken(); // offset\n\n          while (token.type !== tokens.closeParen) {\n            eatTokenOfType(tokens.openParen);\n            offset.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (token.type === tokens.identifier) {\n          funcs.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          funcs.push(t.indexLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          offset.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported token in elem\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return t.elem(tableIndex, offset, funcs);\n    }\n    /**\n     * Parses the start instruction in a module\n     *\n     * WAST:\n     *\n     * start:   ( start <var> )\n     * var:    <nat> | <name>\n     *\n     * WAT:\n     * start ::= ‘(’ ‘start’  x:funcidx ‘)’\n     */\n\n\n    function parseStart() {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return t.start(index);\n      }\n\n      if (token.type === tokens.number) {\n        var _index2 = t.indexLiteral(token.value);\n\n        eatToken();\n        return t.start(_index2);\n      }\n\n      throw new Error(\"Unknown start, token: \" + tokenToString(token));\n    }\n\n    if (token.type === tokens.openParen) {\n      eatToken();\n      var startLoc = getStartLoc();\n\n      if (isKeyword(token, keywords.export)) {\n        eatToken();\n        var node = parseExport();\n\n        var _endLoc2 = getEndLoc();\n\n        return t.withLoc(node, _endLoc2, startLoc);\n      }\n\n      if (isKeyword(token, keywords.loop)) {\n        eatToken();\n\n        var _node = parseLoop();\n\n        var _endLoc3 = getEndLoc();\n\n        return t.withLoc(_node, _endLoc3, startLoc);\n      }\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken();\n\n        var _node2 = parseFunc();\n\n        var _endLoc4 = getEndLoc();\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node2, _endLoc4, startLoc);\n      }\n\n      if (isKeyword(token, keywords.module)) {\n        eatToken();\n\n        var _node3 = parseModule();\n\n        var _endLoc5 = getEndLoc();\n\n        return t.withLoc(_node3, _endLoc5, startLoc);\n      }\n\n      if (isKeyword(token, keywords.import)) {\n        eatToken();\n\n        var _node4 = parseImport();\n\n        var _endLoc6 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node4, _endLoc6, startLoc);\n      }\n\n      if (isKeyword(token, keywords.block)) {\n        eatToken();\n\n        var _node5 = parseBlock();\n\n        var _endLoc7 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node5, _endLoc7, startLoc);\n      }\n\n      if (isKeyword(token, keywords.memory)) {\n        eatToken();\n\n        var _node6 = parseMemory();\n\n        var _endLoc8 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node6, _endLoc8, startLoc);\n      }\n\n      if (isKeyword(token, keywords.data)) {\n        eatToken();\n\n        var _node7 = parseData();\n\n        var _endLoc9 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node7, _endLoc9, startLoc);\n      }\n\n      if (isKeyword(token, keywords.table)) {\n        eatToken();\n\n        var _node8 = parseTable();\n\n        var _endLoc10 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node8, _endLoc10, startLoc);\n      }\n\n      if (isKeyword(token, keywords.global)) {\n        eatToken();\n\n        var _node9 = parseGlobal();\n\n        var _endLoc11 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node9, _endLoc11, startLoc);\n      }\n\n      if (isKeyword(token, keywords.type)) {\n        eatToken();\n\n        var _node10 = parseType();\n\n        var _endLoc12 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node10, _endLoc12, startLoc);\n      }\n\n      if (isKeyword(token, keywords.start)) {\n        eatToken();\n\n        var _node11 = parseStart();\n\n        var _endLoc13 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node11, _endLoc13, startLoc);\n      }\n\n      if (isKeyword(token, keywords.elem)) {\n        eatToken();\n\n        var _node12 = parseElem();\n\n        var _endLoc14 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node12, _endLoc14, startLoc);\n      }\n\n      var instruction = parseFuncInstr();\n      var endLoc = getEndLoc();\n      maybeIgnoreComment();\n\n      if (_typeof(instruction) === \"object\") {\n        if (typeof token !== \"undefined\") {\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        return t.withLoc(instruction, endLoc, startLoc);\n      }\n    }\n\n    if (token.type === tokens.comment) {\n      var _startLoc = getStartLoc();\n\n      var builder = token.opts.type === \"leading\" ? t.leadingComment : t.blockComment;\n\n      var _node13 = builder(token.value);\n\n      eatToken(); // comment\n\n      var _endLoc15 = getEndLoc();\n\n      return t.withLoc(_node13, _endLoc15, _startLoc);\n    }\n\n    throw function () {\n      return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unknown token\" + \", given \" + tokenToString(token));\n    }();\n  }\n\n  var body = [];\n\n  while (current < tokensList.length) {\n    body.push(walk());\n  }\n\n  return t.program(body);\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/wast-parser/esm/grammar.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","codeFrameFromSource","t","parse32I","parseString","tokens","keywords","hasPlugin","name","Error","isKeyword","token","id","type","keyword","value","tokenToString","concat","identifierFromToken","_token$loc","loc","end","start","withLoc","identifier","parse","tokensList","source","current","getUniqueName","getUniqueNameGenerator","state","registredExportedElements","walk","eatToken","getEndLoc","currentToken","lastToken","getStartLoc","eatTokenOfType","parseExportIndex","index","number","_index","numberLiteralFromRaw","lookaheadAndCheck","len","arguments","tokenAhead","expectedToken","undefined","maybeIgnoreComment","comment","parseMemory","limits","limit","string","withRaw","openParen","data","stringInitializer","closeParen","export","_name","push","exportType","max","memory","parseData","memidx","offset","valtype","dot","numberLiteral","objectInstruction","_numberLiteral","instruction","byteArray","memIndexLiteral","parseTable","elemIndices","elemType","elem","exportName","anyfunc","min","parseInt","table","parseImport","moduleName","descr","func","fnParams","fnResult","typeRef","fnName","parseTypeReference","param","apply","parseFuncParam","result","parseFuncResult","funcImportDescr","signature","global","globalType","_valtype","moduleImport","parseBlock","label","blockResult","instr","parseFuncInstr","blockInstruction","parseIf","testInstrs","consequent","alternate","then","else","ifInstruction","parseLoop","loopInstruction","parseCallIndirect","params","results","instrs","callIndirectInstruction","parseExport","moduleExportDescr","parseModuleExportDescr","moduleExport","startLoc","node","endLoc","parseModule","isBinary","isQuote","moduleFields","blob","binaryModule","quoteModule","forEach","decl","module","parseFuncInstrArguments","args","namedArgs","signaturePtr","key","equal","signatureLength","vector","Infinity","valtypeLiteral","stringLiteral","_name2","object","TypeError","_endLoc","signatureForOpcode","_parseFuncInstrArgume","_args","_namedArgs","loop","block","call_indirect","call","indexLiteral","instrArgs","callInstruction","if","parseFunc","fnBody","parseFuncExport","funcId","parseType","typeInstruction","ref","parseGlobal","importing","import","_name3","mut","init","parseElem","tableIndex","funcs","parseStart","_index2","_endLoc2","_node","_endLoc3","_node2","_endLoc4","_node3","_endLoc5","_node4","_endLoc6","_node5","_endLoc7","_node6","_endLoc8","_node7","_endLoc9","_node8","_endLoc10","_node9","_endLoc11","_node10","_endLoc12","_node11","_endLoc13","_node12","_endLoc14","_startLoc","builder","opts","leadingComment","blockComment","_node13","_endLoc15","body","program"],"mappings":"AAAA,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AAAEH,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAtD;AAAyD,GAApI,MAA0I;AAAED,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOC,MAAP,KAAkB,UAAzB,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOJ,GAAzH;AAA+H,KAAjK;AAAoK;;AAAC,SAAOD,OAAO,CAACC,GAAD,CAAd;AAAsB;;AAE/V,SAASK,kBAAT,CAA4BC,GAA5B,EAAiC;AAAE,MAAIC,KAAK,CAACC,OAAN,CAAcF,GAAd,CAAJ,EAAwB;AAAE,SAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,IAAIH,KAAJ,CAAUD,GAAG,CAACK,MAAd,CAAvB,EAA8CF,CAAC,GAAGH,GAAG,CAACK,MAAtD,EAA8DF,CAAC,EAA/D,EAAmE;AAAEC,MAAAA,IAAI,CAACD,CAAD,CAAJ,GAAUH,GAAG,CAACG,CAAD,CAAb;AAAmB;;AAAC,WAAOC,IAAP;AAAc,GAAjI,MAAuI;AAAE,WAAOH,KAAK,CAACK,IAAN,CAAWN,GAAX,CAAP;AAAyB;AAAE;;AAEvM,SAASO,mBAAT,QAAoC,kCAApC;AACA,OAAO,KAAKC,CAAZ,MAAmB,oBAAnB;AACA,SAASC,QAAT,QAAyB,mBAAzB;AACA,SAASC,WAAT,QAA4B,mBAA5B;AACA,SAASC,MAAT,EAAiBC,QAAjB,QAAiC,aAAjC;;AAEA,SAASC,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,MAAIA,IAAI,KAAK,MAAb,EAAqB,MAAM,IAAIC,KAAJ,CAAU,eAAV,CAAN;AACrB,SAAO,IAAP;AACD;;AAED,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,EAA1B,EAA8B;AAC5B,SAAOD,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACS,OAAtB,IAAiCH,KAAK,CAACI,KAAN,KAAgBH,EAAxD;AACD;;AAED,SAASI,aAAT,CAAuBL,KAAvB,EAA8B;AAC5B,MAAIA,KAAK,CAACE,IAAN,KAAe,SAAnB,EAA8B;AAC5B,WAAO,YAAYI,MAAZ,CAAmBN,KAAK,CAACI,KAAzB,EAAgC,GAAhC,CAAP;AACD;;AAED,SAAOJ,KAAK,CAACE,IAAb;AACD;;AAED,SAASK,mBAAT,CAA6BP,KAA7B,EAAoC;AAClC,MAAIQ,UAAU,GAAGR,KAAK,CAACS,GAAvB;AAAA,MACIC,GAAG,GAAGF,UAAU,CAACE,GADrB;AAAA,MAEIC,KAAK,GAAGH,UAAU,CAACG,KAFvB;AAGA,SAAOpB,CAAC,CAACqB,OAAF,CAAUrB,CAAC,CAACsB,UAAF,CAAab,KAAK,CAACI,KAAnB,CAAV,EAAqCM,GAArC,EAA0CC,KAA1C,CAAP;AACD;;AAED,OAAO,SAASG,KAAT,CAAeC,UAAf,EAA2BC,MAA3B,EAAmC;AACxC,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,aAAa,GAAG3B,CAAC,CAAC4B,sBAAF,EAApB;AACA,MAAIC,KAAK,GAAG;AACVC,IAAAA,yBAAyB,EAAE;AADjB,GAAZ,CAHwC,CAKrC;AACH;;AAEA,WAASC,IAAT,GAAgB;AACd,QAAItB,KAAK,GAAGe,UAAU,CAACE,OAAD,CAAtB;;AAEA,aAASM,QAAT,GAAoB;AAClBvB,MAAAA,KAAK,GAAGe,UAAU,CAAC,EAAEE,OAAH,CAAlB;AACD;;AAED,aAASO,SAAT,GAAqB;AACnB,UAAIC,YAAY,GAAGzB,KAAnB;;AAEA,UAAI,OAAOyB,YAAP,KAAwB,WAA5B,EAAyC;AACvC,YAAIC,SAAS,GAAGX,UAAU,CAACA,UAAU,CAAC3B,MAAX,GAAoB,CAArB,CAA1B;AACAqC,QAAAA,YAAY,GAAGC,SAAf;AACD;;AAED,aAAOD,YAAY,CAAChB,GAAb,CAAiBC,GAAxB;AACD;;AAED,aAASiB,WAAT,GAAuB;AACrB,aAAO3B,KAAK,CAACS,GAAN,CAAUE,KAAjB;AACD;;AAED,aAASiB,cAAT,CAAwB1B,IAAxB,EAA8B;AAC5B,UAAIF,KAAK,CAACE,IAAN,KAAeA,IAAnB,EAAyB;AACvB,cAAM,IAAIJ,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,0CAAhD,GAA6FP,IAA7F,GAAoG,UAApG,GAAiHG,aAAa,CAACL,KAAD,CAAxI,CAAN;AACD;;AAEDuB,MAAAA,QAAQ;AACT;;AAED,aAASM,gBAAT,CAA0B7B,KAA1B,EAAiC;AAC/B,UAAIA,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpC,YAAIiB,KAAK,GAAGvB,mBAAmB,CAACP,KAAD,CAA/B;AACAuB,QAAAA,QAAQ;AACR,eAAOO,KAAP;AACD,OAJD,MAIO,IAAI9B,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AACvC,YAAIC,MAAM,GAAGzC,CAAC,CAAC0C,oBAAF,CAAuBjC,KAAK,CAACI,KAA7B,CAAb;;AAEAmB,QAAAA,QAAQ;AACR,eAAOS,MAAP;AACD,OALM,MAKA;AACL,cAAM,YAAY;AAChB,iBAAO,IAAIlC,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,sBAAvD,GAAgF,UAAhF,GAA6FJ,aAAa,CAACL,KAAD,CAApH,CAAP;AACD,SAFK,EAAN;AAGD;AACF;;AAED,aAASkC,iBAAT,GAA6B;AAC3B,UAAIC,GAAG,GAAGC,SAAS,CAAChD,MAApB;;AAEA,WAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiD,GAApB,EAAyBjD,CAAC,EAA1B,EAA8B;AAC5B,YAAImD,UAAU,GAAGtB,UAAU,CAACE,OAAO,GAAG/B,CAAX,CAA3B;AACA,YAAIoD,aAAa,GAAGpD,CAAC,GAAG,CAAJ,IAASkD,SAAS,CAAChD,MAAV,IAAoBF,CAA7B,GAAiCqD,SAAjC,GAA6CH,SAAS,CAAClD,CAAD,CAA1E;;AAEA,YAAImD,UAAU,CAACnC,IAAX,KAAoB,SAAxB,EAAmC;AACjC,cAAIH,SAAS,CAACsC,UAAD,EAAaC,aAAb,CAAT,KAAyC,KAA7C,EAAoD;AAClD,mBAAO,KAAP;AACD;AACF,SAJD,MAIO,IAAIA,aAAa,KAAKD,UAAU,CAACnC,IAAjC,EAAuC;AAC5C,iBAAO,KAAP;AACD;AACF;;AAED,aAAO,IAAP;AACD,KAhEa,CAgEZ;AACF;;;AAGA,aAASsC,kBAAT,GAA8B;AAC5B,UAAI,OAAOxC,KAAP,KAAiB,WAArB,EAAkC;AAChC;AACA;AACD;;AAED,aAAOA,KAAK,CAACE,IAAN,KAAeR,MAAM,CAAC+C,OAA7B,EAAsC;AACpClB,QAAAA,QAAQ;;AAER,YAAI,OAAOvB,KAAP,KAAiB,WAArB,EAAkC;AAChC;AACA;AACD;AACF;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAAS0C,WAAT,GAAuB;AACrB,UAAIzC,EAAE,GAAGV,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,QAAD,CAA1B,CAAT;AACA,UAAIyB,MAAM,GAAGpD,CAAC,CAACqD,KAAF,CAAQ,CAAR,CAAb;;AAEA,UAAI5C,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAAtB,IAAgC7C,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1D,EAAsE;AACpEZ,QAAAA,EAAE,GAAGV,CAAC,CAACsB,UAAF,CAAab,KAAK,CAACI,KAAnB,CAAL;AACAmB,QAAAA,QAAQ;AACT,OAHD,MAGO;AACLtB,QAAAA,EAAE,GAAGV,CAAC,CAACuD,OAAF,CAAU7C,EAAV,EAAc,EAAd,CAAL,CADK,CACmB;AACzB;AACD;AACN;AACA;;;AAGM,UAAIiC,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAACqD,IAA5B,CAArB,EAAwD;AACtDzB,QAAAA,QAAQ,GAD8C,CAC1C;;AAEZA,QAAAA,QAAQ,GAH8C,CAG1C;AACZ;;AAEA,YAAI0B,iBAAiB,GAAGjD,KAAK,CAACI,KAA9B;AACAwB,QAAAA,cAAc,CAAClC,MAAM,CAACmD,MAAR,CAAd,CAPsD,CAOvB;;AAE/BF,QAAAA,MAAM,GAAGpD,CAAC,CAACqD,KAAF,CAAQK,iBAAiB,CAAC7D,MAA1B,CAAT;AACAwC,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;AACD;AACN;AACA;;;AAGM,UAAIhB,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAACwD,MAA5B,CAArB,EAA0D;AACxD5B,QAAAA,QAAQ,GADgD,CAC5C;;AAEZA,QAAAA,QAAQ,GAHgD,CAG5C;;AAEZ,YAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA1B,EAAkC;AAChC,gBAAM,YAAY;AAChB,mBAAO,IAAI/C,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,2BAAvD,GAAqF,UAArF,GAAkGJ,aAAa,CAACL,KAAD,CAAzH,CAAP;AACD,WAFK,EAAN;AAGD;;AAED,YAAIoD,KAAK,GAAGpD,KAAK,CAACI,KAAlB;AACAmB,QAAAA,QAAQ;AACRH,QAAAA,KAAK,CAACC,yBAAN,CAAgCgC,IAAhC,CAAqC;AACnCC,UAAAA,UAAU,EAAE,QADuB;AAEnCzD,UAAAA,IAAI,EAAEuD,KAF6B;AAGnCnD,UAAAA,EAAE,EAAEA;AAH+B,SAArC;AAKA2B,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;AACD;AACN;AACA;;;AAGM,UAAIlD,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AAChCY,QAAAA,MAAM,GAAGpD,CAAC,CAACqD,KAAF,CAAQpD,QAAQ,CAACQ,KAAK,CAACI,KAAP,CAAhB,CAAT;AACAmB,QAAAA,QAAQ;;AAER,YAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AAChCY,UAAAA,MAAM,CAACY,GAAP,GAAa/D,QAAQ,CAACQ,KAAK,CAACI,KAAP,CAArB;AACAmB,UAAAA,QAAQ;AACT;AACF;;AAED,aAAOhC,CAAC,CAACiE,MAAF,CAASb,MAAT,EAAiB1C,EAAjB,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASwD,SAAT,GAAqB;AACnB;AACA,UAAIC,MAAM,GAAG,CAAb;;AAEA,UAAI1D,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AAChC2B,QAAAA,MAAM,GAAG1D,KAAK,CAACI,KAAf;AACAwB,QAAAA,cAAc,CAAClC,MAAM,CAACqC,MAAR,CAAd,CAFgC,CAED;AAChC;;AAEDH,MAAAA,cAAc,CAAClC,MAAM,CAACqD,SAAR,CAAd;AACA,UAAIY,MAAJ;;AAEA,UAAI3D,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAA1B,EAAmC;AACjChC,QAAAA,cAAc,CAAClC,MAAM,CAACkE,OAAR,CAAd,CADiC,CACD;;AAEhChC,QAAAA,cAAc,CAAClC,MAAM,CAACmE,GAAR,CAAd,CAHiC,CAGL;;AAE5B,YAAI7D,KAAK,CAACI,KAAN,KAAgB,OAApB,EAA6B;AAC3B,gBAAM,IAAIN,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED8B,QAAAA,cAAc,CAAClC,MAAM,CAACG,IAAR,CAAd,CATiC,CASJ;;AAE7B,YAAIiE,aAAa,GAAGvE,CAAC,CAAC0C,oBAAF,CAAuBjC,KAAK,CAACI,KAA7B,EAAoC,KAApC,CAApB;AACAuD,QAAAA,MAAM,GAAGpE,CAAC,CAACwE,iBAAF,CAAoB,OAApB,EAA6B,KAA7B,EAAoC,CAACD,aAAD,CAApC,CAAT;AACAvC,QAAAA,QAAQ;AACRK,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD,OAfD,MAeO;AACLtB,QAAAA,cAAc,CAAClC,MAAM,CAACG,IAAR,CAAd,CADK,CACwB;;AAE7B,YAAImE,cAAc,GAAGzE,CAAC,CAAC0C,oBAAF,CAAuBjC,KAAK,CAACI,KAA7B,EAAoC,KAApC,CAArB;;AAEAuD,QAAAA,MAAM,GAAGpE,CAAC,CAAC0E,WAAF,CAAc,YAAd,EAA4B,CAACD,cAAD,CAA5B,CAAT;AACAzC,QAAAA,QAAQ;AACRK,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,UAAIgB,SAAS,GAAGzE,WAAW,CAACO,KAAK,CAACI,KAAP,CAA3B;AACAmB,MAAAA,QAAQ,GAtCW,CAsCP;;AAEZ,aAAOhC,CAAC,CAACyD,IAAF,CAAOzD,CAAC,CAAC4E,eAAF,CAAkBT,MAAlB,CAAP,EAAkCC,MAAlC,EAA0CpE,CAAC,CAAC2E,SAAF,CAAYA,SAAZ,CAA1C,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASE,UAAT,GAAsB;AACpB,UAAIvE,IAAI,GAAGN,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,OAAD,CAA1B,CAAX;AACA,UAAI0B,KAAK,GAAGrD,CAAC,CAACqD,KAAF,CAAQ,CAAR,CAAZ;AACA,UAAIyB,WAAW,GAAG,EAAlB;AACA,UAAIC,QAAQ,GAAG,SAAf;;AAEA,UAAItE,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAAtB,IAAgC7C,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1D,EAAsE;AACpEhB,QAAAA,IAAI,GAAGU,mBAAmB,CAACP,KAAD,CAA1B;AACAuB,QAAAA,QAAQ;AACT,OAHD,MAGO;AACL1B,QAAAA,IAAI,GAAGN,CAAC,CAACuD,OAAF,CAAUjD,IAAV,EAAgB,EAAhB,CAAP,CADK,CACuB;AAC7B;;AAED,aAAOG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA7B,EAAyC;AACvC;AACR;AACA;AACQ,YAAIhB,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAAC4E,IAA5B,CAArB,EAAwD;AACtDhD,UAAAA,QAAQ,GAD8C,CAC1C;;AAEZA,UAAAA,QAAQ,GAH8C,CAG1C;;AAEZ,iBAAOvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA7B,EAAyC;AACvCwD,YAAAA,WAAW,CAAChB,IAAZ,CAAiB9D,CAAC,CAACsB,UAAF,CAAab,KAAK,CAACI,KAAnB,CAAjB;AACAmB,YAAAA,QAAQ;AACT;;AAEDK,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD,SAXD,MAWO,IAAIhB,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAACwD,MAA5B,CAArB,EAA0D;AAC/D5B,UAAAA,QAAQ,GADuD,CACnD;;AAEZA,UAAAA,QAAQ,GAHuD,CAGnD;;AAEZ,cAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA1B,EAAkC;AAChC,kBAAM,YAAY;AAChB,qBAAO,IAAI/C,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,2BAAvD,GAAqF,UAArF,GAAkGJ,aAAa,CAACL,KAAD,CAAzH,CAAP;AACD,aAFK,EAAN;AAGD;;AAED,cAAIwE,UAAU,GAAGxE,KAAK,CAACI,KAAvB;AACAmB,UAAAA,QAAQ;AACRH,UAAAA,KAAK,CAACC,yBAAN,CAAgCgC,IAAhC,CAAqC;AACnCC,YAAAA,UAAU,EAAE,OADuB;AAEnCzD,YAAAA,IAAI,EAAE2E,UAF6B;AAGnCvE,YAAAA,EAAE,EAAEJ;AAH+B,WAArC;AAKA+B,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD,SAnBM,MAmBA,IAAInD,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC8E,OAAjB,CAAb,EAAwC;AAC7C;AACAlD,UAAAA,QAAQ,GAFqC,CAEjC;AACb,SAHM,MAGA,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AACvC;AACV;AACA;AACU,cAAI2C,GAAG,GAAGC,QAAQ,CAAC3E,KAAK,CAACI,KAAP,CAAlB;AACAmB,UAAAA,QAAQ;;AAER,cAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AAChC,gBAAIwB,GAAG,GAAGoB,QAAQ,CAAC3E,KAAK,CAACI,KAAP,CAAlB;AACAmB,YAAAA,QAAQ;AACRqB,YAAAA,KAAK,GAAGrD,CAAC,CAACqD,KAAF,CAAQ8B,GAAR,EAAanB,GAAb,CAAR;AACD,WAJD,MAIO;AACLX,YAAAA,KAAK,GAAGrD,CAAC,CAACqD,KAAF,CAAQ8B,GAAR,CAAR;AACD;;AAEDnD,UAAAA,QAAQ;AACT,SAhBM,MAgBA;AACL,gBAAM,YAAY;AAChB,mBAAO,IAAIzB,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,kBAAvD,GAA4E,UAA5E,GAAyFJ,aAAa,CAACL,KAAD,CAAhH,CAAP;AACD,WAFK,EAAN;AAGD;AACF;;AAED,UAAIqE,WAAW,CAACjF,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,eAAOG,CAAC,CAACqF,KAAF,CAAQN,QAAR,EAAkB1B,KAAlB,EAAyB/C,IAAzB,EAA+BwE,WAA/B,CAAP;AACD,OAFD,MAEO;AACL,eAAO9E,CAAC,CAACqF,KAAF,CAAQN,QAAR,EAAkB1B,KAAlB,EAAyB/C,IAAzB,CAAP;AACD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASgF,WAAT,GAAuB;AACrB,UAAI7E,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA1B,EAAkC;AAChC,cAAM,IAAI/C,KAAJ,CAAU,wBAAwBE,KAAK,CAACE,IAA9B,GAAqC,SAA/C,CAAN;AACD;;AAED,UAAI4E,UAAU,GAAG9E,KAAK,CAACI,KAAvB;AACAmB,MAAAA,QAAQ;;AAER,UAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA1B,EAAkC;AAChC,cAAM,IAAI/C,KAAJ,CAAU,wBAAwBE,KAAK,CAACE,IAA9B,GAAqC,SAA/C,CAAN;AACD;;AAED,UAAIL,IAAI,GAAGG,KAAK,CAACI,KAAjB;AACAmB,MAAAA,QAAQ;AACRK,MAAAA,cAAc,CAAClC,MAAM,CAACqD,SAAR,CAAd;AACA,UAAIgC,KAAJ;;AAEA,UAAIhF,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACqF,IAAjB,CAAb,EAAqC;AACnCzD,QAAAA,QAAQ,GAD2B,CACvB;;AAEZ,YAAI0D,QAAQ,GAAG,EAAf;AACA,YAAIC,QAAQ,GAAG,EAAf;AACA,YAAIC,OAAJ;AACA,YAAIC,MAAM,GAAG7F,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,MAAD,CAA1B,CAAb;;AAEA,YAAIlB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCuE,UAAAA,MAAM,GAAG7E,mBAAmB,CAACP,KAAD,CAA5B;AACAuB,UAAAA,QAAQ;AACT;;AAED,eAAOvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,UAAAA,QAAQ;;AAER,cAAIW,iBAAiB,CAACvC,QAAQ,CAACO,IAAV,CAAjB,KAAqC,IAAzC,EAA+C;AAC7CqB,YAAAA,QAAQ;AACR4D,YAAAA,OAAO,GAAGE,kBAAkB,EAA5B;AACD,WAHD,MAGO,IAAInD,iBAAiB,CAACvC,QAAQ,CAAC2F,KAAV,CAAjB,KAAsC,IAA1C,EAAgD;AACrD/D,YAAAA,QAAQ;AACR0D,YAAAA,QAAQ,CAAC5B,IAAT,CAAckC,KAAd,CAAoBN,QAApB,EAA8BnG,kBAAkB,CAAC0G,cAAc,EAAf,CAAhD;AACD,WAHM,MAGA,IAAItD,iBAAiB,CAACvC,QAAQ,CAAC8F,MAAV,CAAjB,KAAuC,IAA3C,EAAiD;AACtDlE,YAAAA,QAAQ;AACR2D,YAAAA,QAAQ,CAAC7B,IAAT,CAAckC,KAAd,CAAoBL,QAApB,EAA8BpG,kBAAkB,CAAC4G,eAAe,EAAhB,CAAhD;AACD,WAHM,MAGA;AACL,kBAAM,YAAY;AAChB,qBAAO,IAAI5F,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,oCAAvD,GAA8F,UAA9F,GAA2GJ,aAAa,CAACL,KAAD,CAAlI,CAAP;AACD,aAFK,EAAN;AAGD;;AAED4B,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,YAAI,OAAOkC,MAAP,KAAkB,WAAtB,EAAmC;AACjC,gBAAM,IAAItF,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAEDiF,QAAAA,KAAK,GAAGxF,CAAC,CAACoG,eAAF,CAAkBP,MAAlB,EAA0BD,OAAO,KAAK5C,SAAZ,GAAwB4C,OAAxB,GAAkC5F,CAAC,CAACqG,SAAF,CAAYX,QAAZ,EAAsBC,QAAtB,CAA5D,CAAR;AACD,OAvCD,MAuCO,IAAInF,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACkG,MAAjB,CAAb,EAAuC;AAC5CtE,QAAAA,QAAQ,GADoC,CAChC;;AAEZ,YAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA1B,EAAqC;AACnCxB,UAAAA,QAAQ,GAD2B,CACvB;;AAEZK,UAAAA,cAAc,CAAClC,MAAM,CAACS,OAAR,CAAd,CAHmC,CAGH;;AAEhC,cAAIyD,OAAO,GAAG5D,KAAK,CAACI,KAApB;AACAmB,UAAAA,QAAQ;AACRwD,UAAAA,KAAK,GAAGxF,CAAC,CAACuG,UAAF,CAAalC,OAAb,EAAsB,KAAtB,CAAR;AACAhC,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD,SATD,MASO;AACL,cAAI6C,QAAQ,GAAG/F,KAAK,CAACI,KAArB;AACAwB,UAAAA,cAAc,CAAClC,MAAM,CAACkE,OAAR,CAAd;AACAmB,UAAAA,KAAK,GAAGxF,CAAC,CAACuG,UAAF,CAAaC,QAAb,EAAuB,OAAvB,CAAR;AACD;AACF,OAjBM,MAiBA,IAAIhG,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC6D,MAAjB,CAAT,KAAsC,IAA1C,EAAgD;AACrDjC,QAAAA,QAAQ,GAD6C,CACzC;;AAEZwD,QAAAA,KAAK,GAAGrC,WAAW,EAAnB;AACD,OAJM,MAIA,IAAI3C,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACiF,KAAjB,CAAT,KAAqC,IAAzC,EAA+C;AACpDrD,QAAAA,QAAQ,GAD4C,CACxC;;AAEZwD,QAAAA,KAAK,GAAGX,UAAU,EAAlB;AACD,OAJM,MAIA;AACL,cAAM,IAAItE,KAAJ,CAAU,8BAA8BO,aAAa,CAACL,KAAD,CAArD,CAAN;AACD;;AAED4B,MAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,aAAO3D,CAAC,CAACyG,YAAF,CAAelB,UAAf,EAA2BjF,IAA3B,EAAiCkF,KAAjC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASkB,UAAT,GAAsB;AACpB,UAAIC,KAAK,GAAG3G,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,OAAD,CAA1B,CAAZ;AACA,UAAIiF,WAAW,GAAG,IAAlB;AACA,UAAIC,KAAK,GAAG,EAAZ;;AAEA,UAAIpG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCqF,QAAAA,KAAK,GAAG3F,mBAAmB,CAACP,KAAD,CAA3B;AACAuB,QAAAA,QAAQ;AACT,OAHD,MAGO;AACL2E,QAAAA,KAAK,GAAG3G,CAAC,CAACuD,OAAF,CAAUoD,KAAV,EAAiB,EAAjB,CAAR,CADK,CACyB;AAC/B;;AAED,aAAOlG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,QAAAA,QAAQ;;AAER,YAAIW,iBAAiB,CAACvC,QAAQ,CAAC8F,MAAV,CAAjB,KAAuC,IAA3C,EAAiD;AAC/ClE,UAAAA,QAAQ;AACR4E,UAAAA,WAAW,GAAGnG,KAAK,CAACI,KAApB;AACAmB,UAAAA,QAAQ;AACT,SAJD,MAIO,IAAIW,iBAAiB,CAACxC,MAAM,CAACG,IAAR,CAAjB,KAAmC,IAAnC,IAA2CqC,iBAAiB,CAACxC,MAAM,CAACkE,OAAR,CAAjB,KAAsC,IAAjF,IAAyF5D,KAAK,CAACE,IAAN,KAAe,SAA5G,CAAsH;AAAtH,UACL;AACE;AACAkG,UAAAA,KAAK,CAAC/C,IAAN,CAAWgD,cAAc,EAAzB;AACD,SAJI,MAIE;AACP,gBAAM,YAAY;AAChB,mBAAO,IAAIvG,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,wCAAvD,GAAkG,UAAlG,GAA+GJ,aAAa,CAACL,KAAD,CAAtI,CAAP;AACD,WAFK,EAAN;AAGD;;AAEDwC,QAAAA,kBAAkB;AAClBZ,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,aAAO3D,CAAC,CAAC+G,gBAAF,CAAmBJ,KAAnB,EAA0BE,KAA1B,EAAiCD,WAAjC,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASI,OAAT,GAAmB;AACjB,UAAIJ,WAAW,GAAG,IAAlB;AACA,UAAID,KAAK,GAAG3G,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,IAAD,CAA1B,CAAZ;AACA,UAAIsF,UAAU,GAAG,EAAjB;AACA,UAAIC,UAAU,GAAG,EAAjB;AACA,UAAIC,SAAS,GAAG,EAAhB;;AAEA,UAAI1G,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCqF,QAAAA,KAAK,GAAG3F,mBAAmB,CAACP,KAAD,CAA3B;AACAuB,QAAAA,QAAQ;AACT,OAHD,MAGO;AACL2E,QAAAA,KAAK,GAAG3G,CAAC,CAACuD,OAAF,CAAUoD,KAAV,EAAiB,EAAjB,CAAR,CADK,CACyB;AAC/B;;AAED,aAAOlG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,QAAAA,QAAQ,GAD8B,CAC1B;;AAEZ;AACR;AACA;;AAEQ,YAAIxB,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC8F,MAAjB,CAAT,KAAsC,IAA1C,EAAgD;AAC9ClE,UAAAA,QAAQ;AACR4E,UAAAA,WAAW,GAAGnG,KAAK,CAACI,KAApB;AACAwB,UAAAA,cAAc,CAAClC,MAAM,CAACkE,OAAR,CAAd;AACAhC,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA;AACD;AACD;AACR;AACA;;;AAGQ,YAAInD,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACgH,IAAjB,CAAT,KAAoC,IAAxC,EAA8C;AAC5CpF,UAAAA,QAAQ,GADoC,CAChC;;AAEZ,iBAAOvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,YAAAA,QAAQ,GAD8B,CAC1B;;AAEZ,gBAAIW,iBAAiB,CAACxC,MAAM,CAACG,IAAR,CAAjB,KAAmC,IAAnC,IAA2CqC,iBAAiB,CAACxC,MAAM,CAACkE,OAAR,CAAjB,KAAsC,IAAjF,IAAyF5D,KAAK,CAACE,IAAN,KAAe,SAA5G,CAAsH;AAAtH,cACE;AACEuG,cAAAA,UAAU,CAACpD,IAAX,CAAgBgD,cAAc,EAA9B;AACD,aAHH,MAGS;AACP,oBAAM,YAAY;AAChB,uBAAO,IAAIvG,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,6CAAvD,GAAuG,UAAvG,GAAoHJ,aAAa,CAACL,KAAD,CAA3I,CAAP;AACD,eAFK,EAAN;AAGD;;AAED4B,YAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAEDtB,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA;AACD;AACD;AACR;AACA;;;AAGQ,YAAInD,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACiH,IAAjB,CAAb,EAAqC;AACnCrF,UAAAA,QAAQ,GAD2B,CACvB;;AAEZ,iBAAOvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,YAAAA,QAAQ,GAD8B,CAC1B;;AAEZ,gBAAIW,iBAAiB,CAACxC,MAAM,CAACG,IAAR,CAAjB,KAAmC,IAAnC,IAA2CqC,iBAAiB,CAACxC,MAAM,CAACkE,OAAR,CAAjB,KAAsC,IAAjF,IAAyF5D,KAAK,CAACE,IAAN,KAAe,SAA5G,CAAsH;AAAtH,cACE;AACEwG,cAAAA,SAAS,CAACrD,IAAV,CAAegD,cAAc,EAA7B;AACD,aAHH,MAGS;AACP,oBAAM,YAAY;AAChB,uBAAO,IAAIvG,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,4CAAvD,GAAsG,UAAtG,GAAmHJ,aAAa,CAACL,KAAD,CAA1I,CAAP;AACD,eAFK,EAAN;AAGD;;AAED4B,YAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAEDtB,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA;AACD;AACD;AACR;AACA;;;AAGQ,YAAIhB,iBAAiB,CAACxC,MAAM,CAACG,IAAR,CAAjB,KAAmC,IAAnC,IAA2CqC,iBAAiB,CAACxC,MAAM,CAACkE,OAAR,CAAjB,KAAsC,IAAjF,IAAyF5D,KAAK,CAACE,IAAN,KAAe,SAA5G,CAAsH;AAAtH,UACE;AACEsG,UAAAA,UAAU,CAACnD,IAAX,CAAgBgD,cAAc,EAA9B;AACAzE,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA;AACD;;AAEH,cAAM,YAAY;AAChB,iBAAO,IAAIpD,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,6BAAvD,GAAuF,UAAvF,GAAoGJ,aAAa,CAACL,KAAD,CAA3H,CAAP;AACD,SAFK,EAAN;AAGD;;AAED,aAAOT,CAAC,CAACsH,aAAF,CAAgBX,KAAhB,EAAuBM,UAAvB,EAAmCL,WAAnC,EAAgDM,UAAhD,EAA4DC,SAA5D,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASI,SAAT,GAAqB;AACnB,UAAIZ,KAAK,GAAG3G,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,MAAD,CAA1B,CAAZ;AACA,UAAIiF,WAAJ;AACA,UAAIC,KAAK,GAAG,EAAZ;;AAEA,UAAIpG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCqF,QAAAA,KAAK,GAAG3F,mBAAmB,CAACP,KAAD,CAA3B;AACAuB,QAAAA,QAAQ;AACT,OAHD,MAGO;AACL2E,QAAAA,KAAK,GAAG3G,CAAC,CAACuD,OAAF,CAAUoD,KAAV,EAAiB,EAAjB,CAAR,CADK,CACyB;AAC/B;;AAED,aAAOlG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,QAAAA,QAAQ;;AAER,YAAIW,iBAAiB,CAACvC,QAAQ,CAAC8F,MAAV,CAAjB,KAAuC,IAA3C,EAAiD;AAC/ClE,UAAAA,QAAQ;AACR4E,UAAAA,WAAW,GAAGnG,KAAK,CAACI,KAApB;AACAmB,UAAAA,QAAQ;AACT,SAJD,MAIO,IAAIW,iBAAiB,CAACxC,MAAM,CAACG,IAAR,CAAjB,KAAmC,IAAnC,IAA2CqC,iBAAiB,CAACxC,MAAM,CAACkE,OAAR,CAAjB,KAAsC,IAAjF,IAAyF5D,KAAK,CAACE,IAAN,KAAe,SAA5G,CAAsH;AAAtH,UACL;AACE;AACAkG,UAAAA,KAAK,CAAC/C,IAAN,CAAWgD,cAAc,EAAzB;AACD,SAJI,MAIE;AACP,gBAAM,YAAY;AAChB,mBAAO,IAAIvG,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,+BAAvD,GAAyF,UAAzF,GAAsGJ,aAAa,CAACL,KAAD,CAA7H,CAAP;AACD,WAFK,EAAN;AAGD;;AAED4B,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,aAAO3D,CAAC,CAACwH,eAAF,CAAkBb,KAAlB,EAAyBC,WAAzB,EAAsCC,KAAtC,CAAP;AACD;;AAED,aAASY,iBAAT,GAA6B;AAC3B,UAAI7B,OAAJ;AACA,UAAI8B,MAAM,GAAG,EAAb;AACA,UAAIC,OAAO,GAAG,EAAd;AACA,UAAIC,MAAM,GAAG,EAAb;;AAEA,aAAOnH,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA7B,EAAyC;AACvC,YAAIhB,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAACO,IAA5B,CAArB,EAAwD;AACtDqB,UAAAA,QAAQ,GAD8C,CAC1C;;AAEZA,UAAAA,QAAQ,GAH8C,CAG1C;;AAEZ4D,UAAAA,OAAO,GAAGE,kBAAkB,EAA5B;AACD,SAND,MAMO,IAAInD,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAAC2F,KAA5B,CAArB,EAAyD;AAC9D/D,UAAAA,QAAQ,GADsD,CAClD;;AAEZA,UAAAA,QAAQ,GAHsD,CAGlD;;AAEZ;AACV;AACA;AACA;;AAEU,cAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA1B,EAAsC;AACpC+D,YAAAA,MAAM,CAAC5D,IAAP,CAAYkC,KAAZ,CAAkB0B,MAAlB,EAA0BnI,kBAAkB,CAAC0G,cAAc,EAAf,CAA5C;AACD;AACF,SAbM,MAaA,IAAItD,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAAC8F,MAA5B,CAArB,EAA0D;AAC/DlE,UAAAA,QAAQ,GADuD,CACnD;;AAEZA,UAAAA,QAAQ,GAHuD,CAGnD;;AAEZ;AACV;AACA;AACA;;AAEU,cAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA1B,EAAsC;AACpCgE,YAAAA,OAAO,CAAC7D,IAAR,CAAakC,KAAb,CAAmB2B,OAAnB,EAA4BpI,kBAAkB,CAAC4G,eAAe,EAAhB,CAA9C;AACD;AACF,SAbM,MAaA;AACL9D,UAAAA,cAAc,CAAClC,MAAM,CAACqD,SAAR,CAAd;AACAoE,UAAAA,MAAM,CAAC9D,IAAP,CAAYgD,cAAc,EAA1B;AACD;;AAEDzE,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,aAAO3D,CAAC,CAAC6H,uBAAF,CAA0BjC,OAAO,KAAK5C,SAAZ,GAAwB4C,OAAxB,GAAkC5F,CAAC,CAACqG,SAAF,CAAYqB,MAAZ,EAAoBC,OAApB,CAA5D,EAA0FC,MAA1F,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASE,WAAT,GAAuB;AACrB,UAAIrH,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA1B,EAAkC;AAChC,cAAM,IAAI/C,KAAJ,CAAU,wCAAwCE,KAAK,CAACE,IAAxD,CAAN;AACD;;AAED,UAAIL,IAAI,GAAGG,KAAK,CAACI,KAAjB;AACAmB,MAAAA,QAAQ;AACR,UAAI+F,iBAAiB,GAAGC,sBAAsB,EAA9C;AACA,aAAOhI,CAAC,CAACiI,YAAF,CAAe3H,IAAf,EAAqByH,iBAArB,CAAP;AACD;;AAED,aAASC,sBAAT,GAAkC;AAChC,UAAIE,QAAQ,GAAG9F,WAAW,EAA1B;AACA,UAAIzB,IAAI,GAAG,EAAX;AACA,UAAI4B,KAAJ;AACAF,MAAAA,cAAc,CAAClC,MAAM,CAACqD,SAAR,CAAd;;AAEA,aAAO/C,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA7B,EAAyC;AACvC,YAAInD,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACqF,IAAjB,CAAb,EAAqC;AACnC9E,UAAAA,IAAI,GAAG,MAAP;AACAqB,UAAAA,QAAQ;AACRO,UAAAA,KAAK,GAAGD,gBAAgB,CAAC7B,KAAD,CAAxB;AACD,SAJD,MAIO,IAAID,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACiF,KAAjB,CAAb,EAAsC;AAC3C1E,UAAAA,IAAI,GAAG,OAAP;AACAqB,UAAAA,QAAQ;AACRO,UAAAA,KAAK,GAAGD,gBAAgB,CAAC7B,KAAD,CAAxB;AACD,SAJM,MAIA,IAAID,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACkG,MAAjB,CAAb,EAAuC;AAC5C3F,UAAAA,IAAI,GAAG,QAAP;AACAqB,UAAAA,QAAQ;AACRO,UAAAA,KAAK,GAAGD,gBAAgB,CAAC7B,KAAD,CAAxB;AACD,SAJM,MAIA,IAAID,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC6D,MAAjB,CAAb,EAAuC;AAC5CtD,UAAAA,IAAI,GAAG,QAAP;AACAqB,UAAAA,QAAQ;AACRO,UAAAA,KAAK,GAAGD,gBAAgB,CAAC7B,KAAD,CAAxB;AACD;;AAEDuB,QAAAA,QAAQ;AACT;;AAED,UAAIrB,IAAI,KAAK,EAAb,EAAiB;AACf,cAAM,IAAIJ,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,UAAIgC,KAAK,KAAKS,SAAd,EAAyB;AACvB,cAAM,IAAIzC,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,UAAI4H,IAAI,GAAGnI,CAAC,CAAC+H,iBAAF,CAAoBpH,IAApB,EAA0B4B,KAA1B,CAAX;AACA,UAAI6F,MAAM,GAAGnG,SAAS,EAAtB;AACAI,MAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,aAAO3D,CAAC,CAACqB,OAAF,CAAU8G,IAAV,EAAgBC,MAAhB,EAAwBF,QAAxB,CAAP;AACD;;AAED,aAASG,WAAT,GAAuB;AACrB,UAAI/H,IAAI,GAAG,IAAX;AACA,UAAIgI,QAAQ,GAAG,KAAf;AACA,UAAIC,OAAO,GAAG,KAAd;AACA,UAAIC,YAAY,GAAG,EAAnB;;AAEA,UAAI/H,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpChB,QAAAA,IAAI,GAAGG,KAAK,CAACI,KAAb;AACAmB,QAAAA,QAAQ;AACT;;AAED,UAAI3B,SAAS,CAAC,MAAD,CAAT,IAAqBI,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACG,IAA3C,IAAmDG,KAAK,CAACI,KAAN,KAAgB,QAAvE,EAAiF;AAC/EmB,QAAAA,QAAQ;AACRsG,QAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,UAAIjI,SAAS,CAAC,MAAD,CAAT,IAAqBI,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACG,IAA3C,IAAmDG,KAAK,CAACI,KAAN,KAAgB,OAAvE,EAAgF;AAC9EmB,QAAAA,QAAQ;AACRuG,QAAAA,OAAO,GAAG,IAAV;AACD;;AAED,UAAID,QAAQ,KAAK,IAAjB,EAAuB;AACrB,YAAIG,IAAI,GAAG,EAAX;;AAEA,eAAOhI,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA7B,EAAqC;AACnCmF,UAAAA,IAAI,CAAC3E,IAAL,CAAUrD,KAAK,CAACI,KAAhB;AACAmB,UAAAA,QAAQ;AACRiB,UAAAA,kBAAkB;AACnB;;AAEDZ,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAAC0I,YAAF,CAAepI,IAAf,EAAqBmI,IAArB,CAAP;AACD;;AAED,UAAIF,OAAO,KAAK,IAAhB,EAAsB;AACpB,YAAIjF,MAAM,GAAG,EAAb;;AAEA,eAAO7C,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA7B,EAAqC;AACnCA,UAAAA,MAAM,CAACQ,IAAP,CAAYrD,KAAK,CAACI,KAAlB;AACAmB,UAAAA,QAAQ;AACT;;AAEDK,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAAC2I,WAAF,CAAcrI,IAAd,EAAoBgD,MAApB,CAAP;AACD;;AAED,aAAO7C,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA7B,EAAyC;AACvC6E,QAAAA,YAAY,CAAC1E,IAAb,CAAkB/B,IAAI,EAAtB;;AAEA,YAAIF,KAAK,CAACC,yBAAN,CAAgCjC,MAAhC,GAAyC,CAA7C,EAAgD;AAC9CgC,UAAAA,KAAK,CAACC,yBAAN,CAAgC8G,OAAhC,CAAwC,UAAUC,IAAV,EAAgB;AACtDL,YAAAA,YAAY,CAAC1E,IAAb,CAAkB9D,CAAC,CAACiI,YAAF,CAAeY,IAAI,CAACvI,IAApB,EAA0BN,CAAC,CAAC+H,iBAAF,CAAoBc,IAAI,CAAC9E,UAAzB,EAAqC8E,IAAI,CAACnI,EAA1C,CAA1B,CAAlB;AACD,WAFD;AAGAmB,UAAAA,KAAK,CAACC,yBAAN,GAAkC,EAAlC;AACD;;AAEDrB,QAAAA,KAAK,GAAGe,UAAU,CAACE,OAAD,CAAlB;AACD;;AAEDW,MAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,aAAO3D,CAAC,CAAC8I,MAAF,CAASxI,IAAT,EAAekI,YAAf,CAAP;AACD;AACD;AACJ;AACA;;;AAGI,aAASO,uBAAT,CAAiC1C,SAAjC,EAA4C;AAC1C,UAAI2C,IAAI,GAAG,EAAX;AACA,UAAIC,SAAS,GAAG,EAAhB;AACA,UAAIC,YAAY,GAAG,CAAnB;;AAEA,aAAOzI,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACG,IAAtB,IAA8BE,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACgE,MAAjB,CAA9C,EAAwE;AACtE,YAAI+E,GAAG,GAAG1I,KAAK,CAACI,KAAhB;AACAmB,QAAAA,QAAQ;AACRK,QAAAA,cAAc,CAAClC,MAAM,CAACiJ,KAAR,CAAd;AACA,YAAIvI,KAAK,GAAG,KAAK,CAAjB;;AAEA,YAAIJ,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AAChC3B,UAAAA,KAAK,GAAGb,CAAC,CAAC0C,oBAAF,CAAuBjC,KAAK,CAACI,KAA7B,CAAR;AACD,SAFD,MAEO;AACL,gBAAM,IAAIN,KAAJ,CAAU,mCAAmCE,KAAK,CAACE,IAAnD,CAAN;AACD;;AAEDsI,QAAAA,SAAS,CAACE,GAAD,CAAT,GAAiBtI,KAAjB;AACAmB,QAAAA,QAAQ;AACT,OAnByC,CAmBxC;;;AAGF,UAAIqH,eAAe,GAAGhD,SAAS,CAACiD,MAAV,GAAmBC,QAAnB,GAA8BlD,SAAS,CAACxG,MAA9D;;AAEA,aAAOY,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAAtB,MAAsC;AAC7ClD,MAAAA,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAAtB,IAAmC0F,YAAY,GAAGG,eAD3C,CAAP,EACoE;AAClE,YAAI5I,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpC0H,UAAAA,IAAI,CAAClF,IAAL,CAAU9D,CAAC,CAACsB,UAAF,CAAab,KAAK,CAACI,KAAnB,CAAV;AACAmB,UAAAA,QAAQ;AACT,SAHD,MAGO,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAA1B,EAAmC;AACxC;AACA2E,UAAAA,IAAI,CAAClF,IAAL,CAAU9D,CAAC,CAACwJ,cAAF,CAAiB/I,KAAK,CAACI,KAAvB,CAAV;AACAmB,UAAAA,QAAQ;AACT,SAJM,MAIA,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA1B,EAAkC;AACvC0F,UAAAA,IAAI,CAAClF,IAAL,CAAU9D,CAAC,CAACyJ,aAAF,CAAgBhJ,KAAK,CAACI,KAAtB,CAAV;AACAmB,UAAAA,QAAQ;AACT,SAHM,MAGA,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AACvCwG,UAAAA,IAAI,CAAClF,IAAL,EAAW;AACX;AACA9D,UAAAA,CAAC,CAAC0C,oBAAF,CAAuBjC,KAAK,CAACI,KAA7B,EAAoC;AACpCwF,UAAAA,SAAS,CAAC6C,YAAD,CAAT,IAA2B,KAD3B,CAFA,EADuC,CAIH;;AAEpC,cAAI,CAAC7C,SAAS,CAACiD,MAAf,EAAuB;AACrB,cAAEJ,YAAF;AACD;;AAEDlH,UAAAA,QAAQ;AACT,SAXM,MAWA,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA1B,EAAqC;AAC1C;AACV;AACA;AACUxB,UAAAA,QAAQ,GAJkC,CAI9B;;AAEZ,cAAIW,iBAAiB,CAACxC,MAAM,CAACG,IAAR,CAAjB,KAAmC,IAAnC,IAA2CqC,iBAAiB,CAACxC,MAAM,CAACkE,OAAR,CAAjB,KAAsC,IAAjF,IAAyF5D,KAAK,CAACE,IAAN,KAAe,SAA5G,CAAsH;AAAtH,YACE;AACE;AACAqI,YAAAA,IAAI,CAAClF,IAAL,CAAUgD,cAAc,EAAxB;AACD,WAJH,MAIS;AACP,kBAAM,YAAY;AAChB,qBAAO,IAAIvG,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,wCAAvD,GAAkG,UAAlG,GAA+GJ,aAAa,CAACL,KAAD,CAAtI,CAAP;AACD,aAFK,EAAN;AAGD;;AAED,cAAIA,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA1B,EAAsC;AACpC3B,YAAAA,QAAQ;AACT;AACF,SAnBM,MAmBA;AACL,gBAAM,YAAY;AAChB,mBAAO,IAAIzB,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,0CAAvD,GAAoG,UAApG,GAAiHJ,aAAa,CAACL,KAAD,CAAxI,CAAP;AACD,WAFK,EAAN;AAGD;AACF;;AAED,aAAO;AACLuI,QAAAA,IAAI,EAAEA,IADD;AAELC,QAAAA,SAAS,EAAEA;AAFN,OAAP;AAID;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASnC,cAAT,GAA0B;AACxB,UAAIoB,QAAQ,GAAG9F,WAAW,EAA1B;AACAa,MAAAA,kBAAkB;AAClB;AACN;AACA;;AAEM,UAAIxC,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACG,IAAtB,IAA8BG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAAxD,EAAiE;AAC/D,YAAIqF,MAAM,GAAGjJ,KAAK,CAACI,KAAnB;AACA,YAAI8I,MAAJ;AACA3H,QAAAA,QAAQ;;AAER,YAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmE,GAA1B,EAA+B;AAC7BqF,UAAAA,MAAM,GAAGD,MAAT;AACA1H,UAAAA,QAAQ;;AAER,cAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACG,IAA1B,EAAgC;AAC9B,kBAAM,IAAIsJ,SAAJ,CAAc,oBAAoBnJ,KAAK,CAACE,IAA1B,GAAiC,iBAA/C,CAAN;AACD;;AAED+I,UAAAA,MAAM,GAAGjJ,KAAK,CAACI,KAAf;AACAmB,UAAAA,QAAQ;AACT;;AAED,YAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA1B,EAAsC;AACpC,cAAIkG,OAAO,GAAGpJ,KAAK,CAACS,GAAN,CAAUC,GAAxB;;AAEA,cAAI,OAAOwI,MAAP,KAAkB,WAAtB,EAAmC;AACjC,mBAAO3J,CAAC,CAACqB,OAAF,CAAUrB,CAAC,CAAC0E,WAAF,CAAcgF,MAAd,CAAV,EAAiCG,OAAjC,EAA0C3B,QAA1C,CAAP;AACD,WAFD,MAEO;AACL,mBAAOlI,CAAC,CAACqB,OAAF,CAAUrB,CAAC,CAACwE,iBAAF,CAAoBkF,MAApB,EAA4BC,MAA5B,EAAoC,EAApC,CAAV,EAAmDE,OAAnD,EAA4D3B,QAA5D,CAAP;AACD;AACF;;AAED,YAAI7B,SAAS,GAAGrG,CAAC,CAAC8J,kBAAF,CAAqBH,MAAM,IAAI,EAA/B,EAAmCD,MAAnC,CAAhB;;AAEA,YAAIK,qBAAqB,GAAGhB,uBAAuB,CAAC1C,SAAD,CAAnD;AAAA,YACI2D,KAAK,GAAGD,qBAAqB,CAACf,IADlC;AAAA,YAEIiB,UAAU,GAAGF,qBAAqB,CAACd,SAFvC;;AAIA,YAAIb,MAAM,GAAG3H,KAAK,CAACS,GAAN,CAAUC,GAAvB;;AAEA,YAAI,OAAOwI,MAAP,KAAkB,WAAtB,EAAmC;AACjC,iBAAO3J,CAAC,CAACqB,OAAF,CAAUrB,CAAC,CAAC0E,WAAF,CAAcgF,MAAd,EAAsBM,KAAtB,EAA6BC,UAA7B,CAAV,EAAoD7B,MAApD,EAA4DF,QAA5D,CAAP;AACD,SAFD,MAEO;AACL,iBAAOlI,CAAC,CAACqB,OAAF,CAAUrB,CAAC,CAACwE,iBAAF,CAAoBkF,MAApB,EAA4BC,MAA5B,EAAoCK,KAApC,EAA2CC,UAA3C,CAAV,EAAkE7B,MAAlE,EAA0EF,QAA1E,CAAP;AACD;AACF,OAxCD,MAwCO,IAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC8J,IAAjB,CAAb,EAAqC;AAC1C;AACR;AACA;AACQlI,QAAAA,QAAQ,GAJkC,CAI9B;;AAEZ,eAAOuF,SAAS,EAAhB;AACD,OAPM,MAOA,IAAI/G,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC+J,KAAjB,CAAb,EAAsC;AAC3CnI,QAAAA,QAAQ,GADmC,CAC/B;;AAEZ,eAAO0E,UAAU,EAAjB;AACD,OAJM,MAIA,IAAIlG,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACgK,aAAjB,CAAb,EAA8C;AACnDpI,QAAAA,QAAQ,GAD2C,CACvC;;AAEZ,eAAOyF,iBAAiB,EAAxB;AACD,OAJM,MAIA,IAAIjH,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACiK,IAAjB,CAAb,EAAqC;AAC1CrI,QAAAA,QAAQ,GADkC,CAC9B;;AAEZ,YAAIO,KAAJ;;AAEA,YAAI9B,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCiB,UAAAA,KAAK,GAAGvB,mBAAmB,CAACP,KAAD,CAA3B;AACAuB,UAAAA,QAAQ;AACT,SAHD,MAGO,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AACvCD,UAAAA,KAAK,GAAGvC,CAAC,CAACsK,YAAF,CAAe7J,KAAK,CAACI,KAArB,CAAR;AACAmB,UAAAA,QAAQ;AACT;;AAED,YAAIuI,SAAS,GAAG,EAAhB,CAb0C,CAatB;;AAEpB,eAAO9J,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,UAAAA,QAAQ;AACRuI,UAAAA,SAAS,CAACzG,IAAV,CAAegD,cAAc,EAA7B;AACAzE,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,YAAI,OAAOpB,KAAP,KAAiB,WAArB,EAAkC;AAChC,gBAAM,IAAIhC,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAED,YAAIgK,SAAS,CAAC1K,MAAV,GAAmB,CAAvB,EAA0B;AACxB,iBAAOG,CAAC,CAACwK,eAAF,CAAkBjI,KAAlB,EAAyBgI,SAAzB,CAAP;AACD,SAFD,MAEO;AACL,iBAAOvK,CAAC,CAACwK,eAAF,CAAkBjI,KAAlB,CAAP;AACD;AACF,OA9BM,MA8BA,IAAI/B,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACqK,EAAjB,CAAb,EAAmC;AACxCzI,QAAAA,QAAQ,GADgC,CAC5B;;AAEZ,eAAOgF,OAAO,EAAd;AACD,OAJM,MAIA,IAAIxG,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC0I,MAAjB,CAAT,IAAqCzI,SAAS,CAAC,MAAD,CAAlD,EAA4D;AACjE2B,QAAAA,QAAQ,GADyD,CACrD;AACZ;AACA;;AAEA,YAAI8G,MAAM,GAAGT,WAAW,EAAxB;AACA,eAAOS,MAAP;AACD,OAPM,MAOA;AACL,cAAM,YAAY;AAChB,iBAAO,IAAIvI,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,yCAAvD,GAAmG,UAAnG,GAAgHJ,aAAa,CAACL,KAAD,CAAvI,CAAP;AACD,SAFK,EAAN;AAGD;AACF;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASiK,SAAT,GAAqB;AACnB,UAAI7E,MAAM,GAAG7F,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,MAAD,CAA1B,CAAb;AACA,UAAIiE,OAAJ;AACA,UAAI+E,MAAM,GAAG,EAAb;AACA,UAAIjF,QAAQ,GAAG,EAAf;AACA,UAAIC,QAAQ,GAAG,EAAf,CALmB,CAKA;;AAEnB,UAAIlF,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCuE,QAAAA,MAAM,GAAG7E,mBAAmB,CAACP,KAAD,CAA5B;AACAuB,QAAAA,QAAQ;AACT,OAHD,MAGO;AACL6D,QAAAA,MAAM,GAAG7F,CAAC,CAACuD,OAAF,CAAUsC,MAAV,EAAkB,EAAlB,CAAT,CADK,CAC2B;AACjC;;AAED5C,MAAAA,kBAAkB;;AAElB,aAAOxC,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAAtB,IAAmC/C,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACG,IAAzD,IAAiEG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAA9F,EAAuG;AACrG;AACA,YAAI5D,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACG,IAAtB,IAA8BG,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAAxD,EAAiE;AAC/DsG,UAAAA,MAAM,CAAC7G,IAAP,CAAYgD,cAAc,EAA1B;AACA;AACD;;AAED9E,QAAAA,QAAQ;;AAER,YAAIW,iBAAiB,CAACvC,QAAQ,CAAC2F,KAAV,CAAjB,KAAsC,IAA1C,EAAgD;AAC9C/D,UAAAA,QAAQ;AACR0D,UAAAA,QAAQ,CAAC5B,IAAT,CAAckC,KAAd,CAAoBN,QAApB,EAA8BnG,kBAAkB,CAAC0G,cAAc,EAAf,CAAhD;AACD,SAHD,MAGO,IAAItD,iBAAiB,CAACvC,QAAQ,CAAC8F,MAAV,CAAjB,KAAuC,IAA3C,EAAiD;AACtDlE,UAAAA,QAAQ;AACR2D,UAAAA,QAAQ,CAAC7B,IAAT,CAAckC,KAAd,CAAoBL,QAApB,EAA8BpG,kBAAkB,CAAC4G,eAAe,EAAhB,CAAhD;AACD,SAHM,MAGA,IAAIxD,iBAAiB,CAACvC,QAAQ,CAACwD,MAAV,CAAjB,KAAuC,IAA3C,EAAiD;AACtD5B,UAAAA,QAAQ;AACR4I,UAAAA,eAAe,CAAC/E,MAAD,CAAf;AACD,SAHM,MAGA,IAAIlD,iBAAiB,CAACvC,QAAQ,CAACO,IAAV,CAAjB,KAAqC,IAAzC,EAA+C;AACpDqB,UAAAA,QAAQ;AACR4D,UAAAA,OAAO,GAAGE,kBAAkB,EAA5B;AACD,SAHM,MAGA,IAAInD,iBAAiB,CAACxC,MAAM,CAACG,IAAR,CAAjB,KAAmC,IAAnC,IAA2CqC,iBAAiB,CAACxC,MAAM,CAACkE,OAAR,CAAjB,KAAsC,IAAjF,IAAyF5D,KAAK,CAACE,IAAN,KAAe,SAA5G,CAAsH;AAAtH,UACL;AACE;AACAgK,UAAAA,MAAM,CAAC7G,IAAP,CAAYgD,cAAc,EAA1B;AACD,SAJI,MAIE;AACP,gBAAM,YAAY;AAChB,mBAAO,IAAIvG,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,+BAAvD,GAAyF,UAAzF,GAAsGJ,aAAa,CAACL,KAAD,CAA7H,CAAP;AACD,WAFK,EAAN;AAGD;;AAED4B,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,aAAO3D,CAAC,CAACyF,IAAF,CAAOI,MAAP,EAAeD,OAAO,KAAK5C,SAAZ,GAAwB4C,OAAxB,GAAkC5F,CAAC,CAACqG,SAAF,CAAYX,QAAZ,EAAsBC,QAAtB,CAAjD,EAAkFgF,MAAlF,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;;;AAGI,aAASC,eAAT,CAAyBC,MAAzB,EAAiC;AAC/B,UAAIpK,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmD,MAA1B,EAAkC;AAChC,cAAM,YAAY;AAChB,iBAAO,IAAI/C,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,mCAAvD,GAA6F,UAA7F,GAA0GJ,aAAa,CAACL,KAAD,CAAjI,CAAP;AACD,SAFK,EAAN;AAGD;;AAED,UAAIH,IAAI,GAAGG,KAAK,CAACI,KAAjB;AACAmB,MAAAA,QAAQ;AACR;AACN;AACA;AACA;AACA;AACA;;AAEM,UAAItB,EAAE,GAAGV,CAAC,CAACsB,UAAF,CAAauJ,MAAM,CAAChK,KAApB,CAAT;AACAgB,MAAAA,KAAK,CAACC,yBAAN,CAAgCgC,IAAhC,CAAqC;AACnCC,QAAAA,UAAU,EAAE,MADuB;AAEnCzD,QAAAA,IAAI,EAAEA,IAF6B;AAGnCI,QAAAA,EAAE,EAAEA;AAH+B,OAArC;AAKD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASoK,SAAT,GAAqB;AACnB,UAAIpK,EAAJ;AACA,UAAIgH,MAAM,GAAG,EAAb;AACA,UAAIxB,MAAM,GAAG,EAAb;;AAEA,UAAIzF,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCZ,QAAAA,EAAE,GAAGM,mBAAmB,CAACP,KAAD,CAAxB;AACAuB,QAAAA,QAAQ;AACT;;AAED,UAAIW,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAACqF,IAA5B,CAArB,EAAwD;AACtDzD,QAAAA,QAAQ,GAD8C,CAC1C;;AAEZA,QAAAA,QAAQ,GAH8C,CAG1C;;AAEZ,YAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA1B,EAAsC;AACpC3B,UAAAA,QAAQ,GAD4B,CACxB;;AAEZ,iBAAOhC,CAAC,CAAC+K,eAAF,CAAkBrK,EAAlB,EAAsBV,CAAC,CAACqG,SAAF,CAAY,EAAZ,EAAgB,EAAhB,CAAtB,CAAP;AACD;;AAED,YAAI1D,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAAC2F,KAA5B,CAArB,EAAyD;AACvD/D,UAAAA,QAAQ,GAD+C,CAC3C;;AAEZA,UAAAA,QAAQ,GAH+C,CAG3C;;AAEZ0F,UAAAA,MAAM,GAAGzB,cAAc,EAAvB;AACA5D,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,YAAIhB,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAAC8F,MAA5B,CAArB,EAA0D;AACxDlE,UAAAA,QAAQ,GADgD,CAC5C;;AAEZA,UAAAA,QAAQ,GAHgD,CAG5C;;AAEZkE,UAAAA,MAAM,GAAGC,eAAe,EAAxB;AACA9D,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAEDtB,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,aAAO3D,CAAC,CAAC+K,eAAF,CAAkBrK,EAAlB,EAAsBV,CAAC,CAACqG,SAAF,CAAYqB,MAAZ,EAAoBxB,MAApB,CAAtB,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASC,eAAT,GAA2B;AACzB,UAAIwB,OAAO,GAAG,EAAd;;AAEA,aAAOlH,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA7B,EAAyC;AACvC,YAAIlD,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAA1B,EAAmC;AACjC,gBAAM,YAAY;AAChB,mBAAO,IAAI9D,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,iCAAvD,GAA2F,UAA3F,GAAwGJ,aAAa,CAACL,KAAD,CAA/H,CAAP;AACD,WAFK,EAAN;AAGD;;AAED,YAAI4D,OAAO,GAAG5D,KAAK,CAACI,KAApB;AACAmB,QAAAA,QAAQ;AACR2F,QAAAA,OAAO,CAAC7D,IAAR,CAAaO,OAAb;AACD;;AAED,aAAOsD,OAAP;AACD;AACD;AACJ;AACA;AACA;;;AAGI,aAAS7B,kBAAT,GAA8B;AAC5B,UAAIkF,GAAJ;;AAEA,UAAIvK,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpC0J,QAAAA,GAAG,GAAGhK,mBAAmB,CAACP,KAAD,CAAzB;AACAuB,QAAAA,QAAQ;AACT,OAHD,MAGO,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AACvCwI,QAAAA,GAAG,GAAGhL,CAAC,CAAC0C,oBAAF,CAAuBjC,KAAK,CAACI,KAA7B,CAAN;AACAmB,QAAAA,QAAQ;AACT;;AAED,aAAOgJ,GAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASC,WAAT,GAAuB;AACrB,UAAI3K,IAAI,GAAGN,CAAC,CAACsB,UAAF,CAAaK,aAAa,CAAC,QAAD,CAA1B,CAAX;AACA,UAAIhB,IAAJ,CAFqB,CAEX;;AAEV,UAAIuK,SAAS,GAAG,IAAhB;AACAjI,MAAAA,kBAAkB;;AAElB,UAAIxC,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpChB,QAAAA,IAAI,GAAGU,mBAAmB,CAACP,KAAD,CAA1B;AACAuB,QAAAA,QAAQ;AACT,OAHD,MAGO;AACL1B,QAAAA,IAAI,GAAGN,CAAC,CAACuD,OAAF,CAAUjD,IAAV,EAAgB,EAAhB,CAAP,CADK,CACuB;AAC7B;AACD;AACN;AACA;;;AAGM,UAAIqC,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAACwD,MAA5B,CAArB,EAA0D;AACxD5B,QAAAA,QAAQ,GADgD,CAC5C;;AAEZA,QAAAA,QAAQ,GAHgD,CAG5C;;AAEZ,YAAIiD,UAAU,GAAGxE,KAAK,CAACI,KAAvB;AACAwB,QAAAA,cAAc,CAAClC,MAAM,CAACmD,MAAR,CAAd;AACAzB,QAAAA,KAAK,CAACC,yBAAN,CAAgCgC,IAAhC,CAAqC;AACnCC,UAAAA,UAAU,EAAE,QADuB;AAEnCzD,UAAAA,IAAI,EAAE2E,UAF6B;AAGnCvE,UAAAA,EAAE,EAAEJ;AAH+B,SAArC;AAKA+B,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;AACD;AACN;AACA;;;AAGM,UAAIhB,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAAC+K,MAA5B,CAArB,EAA0D;AACxDnJ,QAAAA,QAAQ,GADgD,CAC5C;;AAEZA,QAAAA,QAAQ,GAHgD,CAG5C;;AAEZ,YAAIuD,UAAU,GAAG9E,KAAK,CAACI,KAAvB;AACAwB,QAAAA,cAAc,CAAClC,MAAM,CAACmD,MAAR,CAAd;AACA,YAAI8H,MAAM,GAAG3K,KAAK,CAACI,KAAnB;AACAwB,QAAAA,cAAc,CAAClC,MAAM,CAACmD,MAAR,CAAd;AACA4H,QAAAA,SAAS,GAAG;AACVpC,UAAAA,MAAM,EAAEvD,UADE;AAEVjF,UAAAA,IAAI,EAAE8K,MAFI;AAGV5F,UAAAA,KAAK,EAAExC;AAHG,SAAZ;AAKAX,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;AACD;AACN;AACA;;;AAGM,UAAIlD,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAA1B,EAAmC;AACjC1D,QAAAA,IAAI,GAAGX,CAAC,CAACuG,UAAF,CAAa9F,KAAK,CAACI,KAAnB,EAA0B,OAA1B,CAAP;AACAmB,QAAAA,QAAQ;AACT,OAHD,MAGO,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA1B,EAAqC;AAC1CxB,QAAAA,QAAQ,GADkC,CAC9B;;AAEZ,YAAIxB,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACiL,GAAjB,CAAT,KAAmC,KAAvC,EAA8C;AAC5C,gBAAM,YAAY;AAChB,mBAAO,IAAI9K,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,uCAAvD,GAAiG,UAAjG,GAA8GJ,aAAa,CAACL,KAAD,CAArI,CAAP;AACD,WAFK,EAAN;AAGD;;AAEDuB,QAAAA,QAAQ,GATkC,CAS9B;;AAEZrB,QAAAA,IAAI,GAAGX,CAAC,CAACuG,UAAF,CAAa9F,KAAK,CAACI,KAAnB,EAA0B,KAA1B,CAAP;AACAmB,QAAAA,QAAQ;AACRK,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,UAAIhD,IAAI,KAAKqC,SAAb,EAAwB;AACtB,cAAM,YAAY;AAChB,iBAAO,IAAIzC,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,iCAAvD,GAA2F,UAA3F,GAAwGJ,aAAa,CAACL,KAAD,CAA/H,CAAP;AACD,SAFK,EAAN;AAGD;;AAEDwC,MAAAA,kBAAkB;AAClB,UAAIqI,IAAI,GAAG,EAAX;;AAEA,UAAIJ,SAAS,IAAI,IAAjB,EAAuB;AACrBA,QAAAA,SAAS,CAAC1F,KAAV,GAAkB7E,IAAlB;AACA2K,QAAAA,IAAI,CAACxH,IAAL,CAAU9D,CAAC,CAACyG,YAAF,CAAeyE,SAAS,CAACpC,MAAzB,EAAiCoC,SAAS,CAAC5K,IAA3C,EAAiD4K,SAAS,CAAC1F,KAA3D,CAAV;AACD;AACD;AACN;AACA;;;AAGM,aAAO/E,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA7B,EAAwC;AACtCxB,QAAAA,QAAQ;AACRsJ,QAAAA,IAAI,CAACxH,IAAL,CAAUgD,cAAc,EAAxB;AACAzE,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,aAAO3D,CAAC,CAACsG,MAAF,CAAS3F,IAAT,EAAe2K,IAAf,EAAqBhL,IAArB,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAAS2F,cAAT,GAA0B;AACxB,UAAIyB,MAAM,GAAG,EAAb;AACA,UAAIhH,EAAJ;AACA,UAAI2D,OAAJ;;AAEA,UAAI5D,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCZ,QAAAA,EAAE,GAAGD,KAAK,CAACI,KAAX;AACAmB,QAAAA,QAAQ;AACT;;AAED,UAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAA1B,EAAmC;AACjCA,QAAAA,OAAO,GAAG5D,KAAK,CAACI,KAAhB;AACAmB,QAAAA,QAAQ;AACR0F,QAAAA,MAAM,CAAC5D,IAAP,CAAY;AACVpD,UAAAA,EAAE,EAAEA,EADM;AAEV2D,UAAAA,OAAO,EAAEA;AAFC,SAAZ;AAIA;AACR;AACA;AACA;AACA;;AAEQ,YAAI3D,EAAE,KAAKsC,SAAX,EAAsB;AACpB,iBAAOvC,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACkE,OAA7B,EAAsC;AACpCA,YAAAA,OAAO,GAAG5D,KAAK,CAACI,KAAhB;AACAmB,YAAAA,QAAQ;AACR0F,YAAAA,MAAM,CAAC5D,IAAP,CAAY;AACVpD,cAAAA,EAAE,EAAEsC,SADM;AAEVqB,cAAAA,OAAO,EAAEA;AAFC,aAAZ;AAID;AACF;AACF,OAvBD,MAuBO,CAAC;AACP;;AAED,aAAOqD,MAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAAS6D,SAAT,GAAqB;AACnB,UAAIC,UAAU,GAAGxL,CAAC,CAACsK,YAAF,CAAe,CAAf,CAAjB;AACA,UAAIlG,MAAM,GAAG,EAAb;AACA,UAAIqH,KAAK,GAAG,EAAZ;;AAEA,UAAIhL,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpCkK,QAAAA,UAAU,GAAGxK,mBAAmB,CAACP,KAAD,CAAhC;AACAuB,QAAAA,QAAQ;AACT;;AAED,UAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AAChCgJ,QAAAA,UAAU,GAAGxL,CAAC,CAACsK,YAAF,CAAe7J,KAAK,CAACI,KAArB,CAAb;AACAmB,QAAAA,QAAQ;AACT;;AAED,aAAOvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA7B,EAAyC;AACvC,YAAIhB,iBAAiB,CAACxC,MAAM,CAACqD,SAAR,EAAmBpD,QAAQ,CAACgE,MAA5B,CAArB,EAA0D;AACxDpC,UAAAA,QAAQ,GADgD,CAC5C;;AAEZA,UAAAA,QAAQ,GAHgD,CAG5C;;AAEZ,iBAAOvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACwD,UAA7B,EAAyC;AACvCtB,YAAAA,cAAc,CAAClC,MAAM,CAACqD,SAAR,CAAd;AACAY,YAAAA,MAAM,CAACN,IAAP,CAAYgD,cAAc,EAA1B;AACAzE,YAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAEDtB,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD,SAZD,MAYO,IAAIlD,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AAC3CmK,UAAAA,KAAK,CAAC3H,IAAN,CAAW9D,CAAC,CAACsB,UAAF,CAAab,KAAK,CAACI,KAAnB,CAAX;AACAmB,UAAAA,QAAQ;AACT,SAHM,MAGA,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AACvCiJ,UAAAA,KAAK,CAAC3H,IAAN,CAAW9D,CAAC,CAACsK,YAAF,CAAe7J,KAAK,CAACI,KAArB,CAAX;AACAmB,UAAAA,QAAQ;AACT,SAHM,MAGA,IAAIvB,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA1B,EAAqC;AAC1CxB,UAAAA,QAAQ,GADkC,CAC9B;;AAEZoC,UAAAA,MAAM,CAACN,IAAP,CAAYgD,cAAc,EAA1B;AACAzE,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD,SALM,MAKA;AACL,gBAAM,YAAY;AAChB,mBAAO,IAAIpD,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,2BAAvD,GAAqF,UAArF,GAAkGJ,aAAa,CAACL,KAAD,CAAzH,CAAP;AACD,WAFK,EAAN;AAGD;AACF;;AAED,aAAOT,CAAC,CAACgF,IAAF,CAAOwG,UAAP,EAAmBpH,MAAnB,EAA2BqH,KAA3B,CAAP;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGI,aAASC,UAAT,GAAsB;AACpB,UAAIjL,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACmB,UAA1B,EAAsC;AACpC,YAAIiB,KAAK,GAAGvB,mBAAmB,CAACP,KAAD,CAA/B;AACAuB,QAAAA,QAAQ;AACR,eAAOhC,CAAC,CAACoB,KAAF,CAAQmB,KAAR,CAAP;AACD;;AAED,UAAI9B,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqC,MAA1B,EAAkC;AAChC,YAAImJ,OAAO,GAAG3L,CAAC,CAACsK,YAAF,CAAe7J,KAAK,CAACI,KAArB,CAAd;;AAEAmB,QAAAA,QAAQ;AACR,eAAOhC,CAAC,CAACoB,KAAF,CAAQuK,OAAR,CAAP;AACD;;AAED,YAAM,IAAIpL,KAAJ,CAAU,2BAA2BO,aAAa,CAACL,KAAD,CAAlD,CAAN;AACD;;AAED,QAAIA,KAAK,CAACE,IAAN,KAAeR,MAAM,CAACqD,SAA1B,EAAqC;AACnCxB,MAAAA,QAAQ;AACR,UAAIkG,QAAQ,GAAG9F,WAAW,EAA1B;;AAEA,UAAI5B,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACwD,MAAjB,CAAb,EAAuC;AACrC5B,QAAAA,QAAQ;AACR,YAAImG,IAAI,GAAGL,WAAW,EAAtB;;AAEA,YAAI8D,QAAQ,GAAG3J,SAAS,EAAxB;;AAEA,eAAOjC,CAAC,CAACqB,OAAF,CAAU8G,IAAV,EAAgByD,QAAhB,EAA0B1D,QAA1B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC8J,IAAjB,CAAb,EAAqC;AACnClI,QAAAA,QAAQ;;AAER,YAAI6J,KAAK,GAAGtE,SAAS,EAArB;;AAEA,YAAIuE,QAAQ,GAAG7J,SAAS,EAAxB;;AAEA,eAAOjC,CAAC,CAACqB,OAAF,CAAUwK,KAAV,EAAiBC,QAAjB,EAA2B5D,QAA3B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACqF,IAAjB,CAAb,EAAqC;AACnCzD,QAAAA,QAAQ;;AAER,YAAI+J,MAAM,GAAGrB,SAAS,EAAtB;;AAEA,YAAIsB,QAAQ,GAAG/J,SAAS,EAAxB;;AAEAgB,QAAAA,kBAAkB;AAClBZ,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAU0K,MAAV,EAAkBC,QAAlB,EAA4B9D,QAA5B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC0I,MAAjB,CAAb,EAAuC;AACrC9G,QAAAA,QAAQ;;AAER,YAAIiK,MAAM,GAAG5D,WAAW,EAAxB;;AAEA,YAAI6D,QAAQ,GAAGjK,SAAS,EAAxB;;AAEA,eAAOjC,CAAC,CAACqB,OAAF,CAAU4K,MAAV,EAAkBC,QAAlB,EAA4BhE,QAA5B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC+K,MAAjB,CAAb,EAAuC;AACrCnJ,QAAAA,QAAQ;;AAER,YAAImK,MAAM,GAAG7G,WAAW,EAAxB;;AAEA,YAAI8G,QAAQ,GAAGnK,SAAS,EAAxB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAU8K,MAAV,EAAkBC,QAAlB,EAA4BlE,QAA5B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC+J,KAAjB,CAAb,EAAsC;AACpCnI,QAAAA,QAAQ;;AAER,YAAIqK,MAAM,GAAG3F,UAAU,EAAvB;;AAEA,YAAI4F,QAAQ,GAAGrK,SAAS,EAAxB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAUgL,MAAV,EAAkBC,QAAlB,EAA4BpE,QAA5B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC6D,MAAjB,CAAb,EAAuC;AACrCjC,QAAAA,QAAQ;;AAER,YAAIuK,MAAM,GAAGpJ,WAAW,EAAxB;;AAEA,YAAIqJ,QAAQ,GAAGvK,SAAS,EAAxB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAUkL,MAAV,EAAkBC,QAAlB,EAA4BtE,QAA5B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACqD,IAAjB,CAAb,EAAqC;AACnCzB,QAAAA,QAAQ;;AAER,YAAIyK,MAAM,GAAGvI,SAAS,EAAtB;;AAEA,YAAIwI,QAAQ,GAAGzK,SAAS,EAAxB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAUoL,MAAV,EAAkBC,QAAlB,EAA4BxE,QAA5B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACiF,KAAjB,CAAb,EAAsC;AACpCrD,QAAAA,QAAQ;;AAER,YAAI2K,MAAM,GAAG9H,UAAU,EAAvB;;AAEA,YAAI+H,SAAS,GAAG3K,SAAS,EAAzB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAUsL,MAAV,EAAkBC,SAAlB,EAA6B1E,QAA7B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACkG,MAAjB,CAAb,EAAuC;AACrCtE,QAAAA,QAAQ;;AAER,YAAI6K,MAAM,GAAG5B,WAAW,EAAxB;;AAEA,YAAI6B,SAAS,GAAG7K,SAAS,EAAzB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAUwL,MAAV,EAAkBC,SAAlB,EAA6B5E,QAA7B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACO,IAAjB,CAAb,EAAqC;AACnCqB,QAAAA,QAAQ;;AAER,YAAI+K,OAAO,GAAGjC,SAAS,EAAvB;;AAEA,YAAIkC,SAAS,GAAG/K,SAAS,EAAzB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAU0L,OAAV,EAAmBC,SAAnB,EAA8B9E,QAA9B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAACgB,KAAjB,CAAb,EAAsC;AACpCY,QAAAA,QAAQ;;AAER,YAAIiL,OAAO,GAAGvB,UAAU,EAAxB;;AAEA,YAAIwB,SAAS,GAAGjL,SAAS,EAAzB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAU4L,OAAV,EAAmBC,SAAnB,EAA8BhF,QAA9B,CAAP;AACD;;AAED,UAAI1H,SAAS,CAACC,KAAD,EAAQL,QAAQ,CAAC4E,IAAjB,CAAb,EAAqC;AACnChD,QAAAA,QAAQ;;AAER,YAAImL,OAAO,GAAG5B,SAAS,EAAvB;;AAEA,YAAI6B,SAAS,GAAGnL,SAAS,EAAzB;;AAEAI,QAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACA,eAAO3D,CAAC,CAACqB,OAAF,CAAU8L,OAAV,EAAmBC,SAAnB,EAA8BlF,QAA9B,CAAP;AACD;;AAED,UAAIxD,WAAW,GAAGoC,cAAc,EAAhC;AACA,UAAIsB,MAAM,GAAGnG,SAAS,EAAtB;AACAgB,MAAAA,kBAAkB;;AAElB,UAAIhE,OAAO,CAACyF,WAAD,CAAP,KAAyB,QAA7B,EAAuC;AACrC,YAAI,OAAOjE,KAAP,KAAiB,WAArB,EAAkC;AAChC4B,UAAAA,cAAc,CAAClC,MAAM,CAACwD,UAAR,CAAd;AACD;;AAED,eAAO3D,CAAC,CAACqB,OAAF,CAAUqD,WAAV,EAAuB0D,MAAvB,EAA+BF,QAA/B,CAAP;AACD;AACF;;AAED,QAAIzH,KAAK,CAACE,IAAN,KAAeR,MAAM,CAAC+C,OAA1B,EAAmC;AACjC,UAAImK,SAAS,GAAGjL,WAAW,EAA3B;;AAEA,UAAIkL,OAAO,GAAG7M,KAAK,CAAC8M,IAAN,CAAW5M,IAAX,KAAoB,SAApB,GAAgCX,CAAC,CAACwN,cAAlC,GAAmDxN,CAAC,CAACyN,YAAnE;;AAEA,UAAIC,OAAO,GAAGJ,OAAO,CAAC7M,KAAK,CAACI,KAAP,CAArB;;AAEAmB,MAAAA,QAAQ,GAPyB,CAOrB;;AAEZ,UAAI2L,SAAS,GAAG1L,SAAS,EAAzB;;AAEA,aAAOjC,CAAC,CAACqB,OAAF,CAAUqM,OAAV,EAAmBC,SAAnB,EAA8BN,SAA9B,CAAP;AACD;;AAED,UAAM,YAAY;AAChB,aAAO,IAAI9M,KAAJ,CAAU,OAAOR,mBAAmB,CAAC0B,MAAD,EAAShB,KAAK,CAACS,GAAf,CAA1B,GAAgD,IAAhD,GAAuD,eAAvD,GAAyE,UAAzE,GAAsFJ,aAAa,CAACL,KAAD,CAA7G,CAAP;AACD,KAFK,EAAN;AAGD;;AAED,MAAImN,IAAI,GAAG,EAAX;;AAEA,SAAOlM,OAAO,GAAGF,UAAU,CAAC3B,MAA5B,EAAoC;AAClC+N,IAAAA,IAAI,CAAC9J,IAAL,CAAU/B,IAAI,EAAd;AACD;;AAED,SAAO/B,CAAC,CAAC6N,OAAF,CAAUD,IAAV,CAAP;AACD","sourcesContent":["function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport { codeFrameFromSource } from \"@webassemblyjs/helper-code-frame\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { parse32I } from \"./number-literals\";\nimport { parseString } from \"./string-literals\";\nimport { tokens, keywords } from \"./tokenizer\";\n\nfunction hasPlugin(name) {\n  if (name !== \"wast\") throw new Error(\"unknow plugin\");\n  return true;\n}\n\nfunction isKeyword(token, id) {\n  return token.type === tokens.keyword && token.value === id;\n}\n\nfunction tokenToString(token) {\n  if (token.type === \"keyword\") {\n    return \"keyword (\".concat(token.value, \")\");\n  }\n\n  return token.type;\n}\n\nfunction identifierFromToken(token) {\n  var _token$loc = token.loc,\n      end = _token$loc.end,\n      start = _token$loc.start;\n  return t.withLoc(t.identifier(token.value), end, start);\n}\n\nexport function parse(tokensList, source) {\n  var current = 0;\n  var getUniqueName = t.getUniqueNameGenerator();\n  var state = {\n    registredExportedElements: []\n  }; // But this time we're going to use recursion instead of a `while` loop. So we\n  // define a `walk` function.\n\n  function walk() {\n    var token = tokensList[current];\n\n    function eatToken() {\n      token = tokensList[++current];\n    }\n\n    function getEndLoc() {\n      var currentToken = token;\n\n      if (typeof currentToken === \"undefined\") {\n        var lastToken = tokensList[tokensList.length - 1];\n        currentToken = lastToken;\n      }\n\n      return currentToken.loc.end;\n    }\n\n    function getStartLoc() {\n      return token.loc.start;\n    }\n\n    function eatTokenOfType(type) {\n      if (token.type !== type) {\n        throw new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"Assertion error: expected token of type \" + type + \", given \" + tokenToString(token));\n      }\n\n      eatToken();\n    }\n\n    function parseExportIndex(token) {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return index;\n      } else if (token.type === tokens.number) {\n        var _index = t.numberLiteralFromRaw(token.value);\n\n        eatToken();\n        return _index;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"unknown export index\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n\n    function lookaheadAndCheck() {\n      var len = arguments.length;\n\n      for (var i = 0; i < len; i++) {\n        var tokenAhead = tokensList[current + i];\n        var expectedToken = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (tokenAhead.type === \"keyword\") {\n          if (isKeyword(tokenAhead, expectedToken) === false) {\n            return false;\n          }\n        } else if (expectedToken !== tokenAhead.type) {\n          return false;\n        }\n      }\n\n      return true;\n    } // TODO(sven): there is probably a better way to do this\n    // can refactor it if it get out of hands\n\n\n    function maybeIgnoreComment() {\n      if (typeof token === \"undefined\") {\n        // Ignore\n        return;\n      }\n\n      while (token.type === tokens.comment) {\n        eatToken();\n\n        if (typeof token === \"undefined\") {\n          // Hit the end\n          break;\n        }\n      }\n    }\n    /**\n     * Parses a memory instruction\n     *\n     * WAST:\n     *\n     * memory:  ( memory <name>? <memory_sig> )\n     *          ( memory <name>? ( export <string> ) <...> )\n     *          ( memory <name>? ( import <string> <string> ) <memory_sig> )\n     *          ( memory <name>? ( export <string> )* ( data <string>* )\n     * memory_sig: <nat> <nat>?\n     *\n     */\n\n\n    function parseMemory() {\n      var id = t.identifier(getUniqueName(\"memory\"));\n      var limits = t.limit(0);\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        id = t.identifier(token.value);\n        eatToken();\n      } else {\n        id = t.withRaw(id, \"\"); // preserve anonymous\n      }\n      /**\n       * Maybe data\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.data)) {\n        eatToken(); // (\n\n        eatToken(); // data\n        // TODO(sven): do something with the data collected here\n\n        var stringInitializer = token.value;\n        eatTokenOfType(tokens.string); // Update limits accordingly\n\n        limits = t.limit(stringInitializer.length);\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        if (token.type !== tokens.string) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var _name = token.value;\n        eatToken();\n        state.registredExportedElements.push({\n          exportType: \"Memory\",\n          name: _name,\n          id: id\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * Memory signature\n       */\n\n\n      if (token.type === tokens.number) {\n        limits = t.limit(parse32I(token.value));\n        eatToken();\n\n        if (token.type === tokens.number) {\n          limits.max = parse32I(token.value);\n          eatToken();\n        }\n      }\n\n      return t.memory(limits, id);\n    }\n    /**\n     * Parses a data section\n     * https://webassembly.github.io/spec/core/text/modules.html#data-segments\n     *\n     * WAST:\n     *\n     * data:  ( data <index>? <offset> <string> )\n     */\n\n\n    function parseData() {\n      // optional memory index\n      var memidx = 0;\n\n      if (token.type === tokens.number) {\n        memidx = token.value;\n        eatTokenOfType(tokens.number); // .\n      }\n\n      eatTokenOfType(tokens.openParen);\n      var offset;\n\n      if (token.type === tokens.valtype) {\n        eatTokenOfType(tokens.valtype); // i32\n\n        eatTokenOfType(tokens.dot); // .\n\n        if (token.value !== \"const\") {\n          throw new Error(\"constant expression required\");\n        }\n\n        eatTokenOfType(tokens.name); // const\n\n        var numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n        offset = t.objectInstruction(\"const\", \"i32\", [numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      } else {\n        eatTokenOfType(tokens.name); // get_global\n\n        var _numberLiteral = t.numberLiteralFromRaw(token.value, \"i32\");\n\n        offset = t.instruction(\"get_global\", [_numberLiteral]);\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      var byteArray = parseString(token.value);\n      eatToken(); // \"string\"\n\n      return t.data(t.memIndexLiteral(memidx), offset, t.byteArray(byteArray));\n    }\n    /**\n     * Parses a table instruction\n     *\n     * WAST:\n     *\n     * table:   ( table <name>? <table_type> )\n     *          ( table <name>? ( export <string> ) <...> )\n     *          ( table <name>? ( import <string> <string> ) <table_type> )\n     *          ( table <name>? ( export <string> )* <elem_type> ( elem <var>* ) )\n     *\n     * table_type:  <nat> <nat>? <elem_type>\n     * elem_type: anyfunc\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     */\n\n\n    function parseTable() {\n      var name = t.identifier(getUniqueName(\"table\"));\n      var limit = t.limit(0);\n      var elemIndices = [];\n      var elemType = \"anyfunc\";\n\n      if (token.type === tokens.string || token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n\n      while (token.type !== tokens.closeParen) {\n        /**\n         * Maybe export\n         */\n        if (lookaheadAndCheck(tokens.openParen, keywords.elem)) {\n          eatToken(); // (\n\n          eatToken(); // elem\n\n          while (token.type === tokens.identifier) {\n            elemIndices.push(t.identifier(token.value));\n            eatToken();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n          eatToken(); // (\n\n          eatToken(); // export\n\n          if (token.type !== tokens.string) {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Expected string in export\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          var exportName = token.value;\n          eatToken();\n          state.registredExportedElements.push({\n            exportType: \"Table\",\n            name: exportName,\n            id: name\n          });\n          eatTokenOfType(tokens.closeParen);\n        } else if (isKeyword(token, keywords.anyfunc)) {\n          // It's the default value, we can ignore it\n          eatToken(); // anyfunc\n        } else if (token.type === tokens.number) {\n          /**\n           * Table type\n           */\n          var min = parseInt(token.value);\n          eatToken();\n\n          if (token.type === tokens.number) {\n            var max = parseInt(token.value);\n            eatToken();\n            limit = t.limit(min, max);\n          } else {\n            limit = t.limit(min);\n          }\n\n          eatToken();\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      if (elemIndices.length > 0) {\n        return t.table(elemType, limit, name, elemIndices);\n      } else {\n        return t.table(elemType, limit, name);\n      }\n    }\n    /**\n     * Parses an import statement\n     *\n     * WAST:\n     *\n     * import:  ( import <string> <string> <imkind> )\n     * imkind:  ( func <name>? <func_sig> )\n     *          ( global <name>? <global_sig> )\n     *          ( table <name>? <table_sig> )\n     *          ( memory <name>? <memory_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     */\n\n\n    function parseImport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var moduleName = token.value;\n      eatToken();\n\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected a string, \" + token.type + \" given.\");\n      }\n\n      var name = token.value;\n      eatToken();\n      eatTokenOfType(tokens.openParen);\n      var descr;\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken(); // keyword\n\n        var fnParams = [];\n        var fnResult = [];\n        var typeRef;\n        var fnName = t.identifier(getUniqueName(\"func\"));\n\n        if (token.type === tokens.identifier) {\n          fnName = identifierFromToken(token);\n          eatToken();\n        }\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n\n          if (lookaheadAndCheck(keywords.type) === true) {\n            eatToken();\n            typeRef = parseTypeReference();\n          } else if (lookaheadAndCheck(keywords.param) === true) {\n            eatToken();\n            fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n          } else if (lookaheadAndCheck(keywords.result) === true) {\n            eatToken();\n            fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n          } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in import of type\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof fnName === \"undefined\") {\n          throw new Error(\"Imported function must have a name\");\n        }\n\n        descr = t.funcImportDescr(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult));\n      } else if (isKeyword(token, keywords.global)) {\n        eatToken(); // keyword\n\n        if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          eatTokenOfType(tokens.keyword); // mut keyword\n\n          var valtype = token.value;\n          eatToken();\n          descr = t.globalType(valtype, \"var\");\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          var _valtype = token.value;\n          eatTokenOfType(tokens.valtype);\n          descr = t.globalType(_valtype, \"const\");\n        }\n      } else if (isKeyword(token, keywords.memory) === true) {\n        eatToken(); // Keyword\n\n        descr = parseMemory();\n      } else if (isKeyword(token, keywords.table) === true) {\n        eatToken(); // Keyword\n\n        descr = parseTable();\n      } else {\n        throw new Error(\"Unsupported import type: \" + tokenToString(token));\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.moduleImport(moduleName, name, descr);\n    }\n    /**\n     * Parses a block instruction\n     *\n     * WAST:\n     *\n     * expr: ( block <name>? <block_sig> <instr>* )\n     * instr: block <name>? <block_sig> <instr>* end <name>?\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseBlock() {\n      var label = t.identifier(getUniqueName(\"block\"));\n      var blockResult = null;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in block body of type\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.blockInstruction(label, instr, blockResult);\n    }\n    /**\n     * Parses a if instruction\n     *\n     * WAST:\n     *\n     * expr:\n     * ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     * ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * instr:\n     * if <name>? <block_sig> <instr>* end <name>?\n     * if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * block_sig : ( result <type>* )*\n     *\n     */\n\n\n    function parseIf() {\n      var blockResult = null;\n      var label = t.identifier(getUniqueName(\"if\"));\n      var testInstrs = [];\n      var consequent = [];\n      var alternate = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        /**\n         * Block signature\n         */\n\n        if (isKeyword(token, keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatTokenOfType(tokens.valtype);\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Then\n         */\n\n\n        if (isKeyword(token, keywords.then) === true) {\n          eatToken(); // then\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n                consequent.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in consequent body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Alternate\n         */\n\n\n        if (isKeyword(token, keywords.else)) {\n          eatToken(); // else\n\n          while (token.type === tokens.openParen) {\n            eatToken(); // Instruction\n\n            if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n            ) {\n                alternate.push(parseFuncInstr());\n              } else {\n              throw function () {\n                return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in alternate body of type\" + \", given \" + tokenToString(token));\n              }();\n            }\n\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n          continue;\n        }\n        /**\n         * Test instruction\n         */\n\n\n        if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            testInstrs.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n            continue;\n          }\n\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in if body\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      return t.ifInstruction(label, testInstrs, blockResult, consequent, alternate);\n    }\n    /**\n     * Parses a loop instruction\n     *\n     * WAT:\n     *\n     * blockinstr :: 'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *\n     * WAST:\n     *\n     * instr     :: loop <name>? <block_sig> <instr>* end <name>?\n     * expr      :: ( loop <name>? <block_sig> <instr>* )\n     * block_sig :: ( result <type>* )*\n     *\n     */\n\n\n    function parseLoop() {\n      var label = t.identifier(getUniqueName(\"loop\"));\n      var blockResult;\n      var instr = [];\n\n      if (token.type === tokens.identifier) {\n        label = identifierFromToken(token);\n        eatToken();\n      } else {\n        label = t.withRaw(label, \"\"); // preserve anonymous\n      }\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          blockResult = token.value;\n          eatToken();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            instr.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in loop body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.loopInstruction(label, blockResult, instr);\n    }\n\n    function parseCallIndirect() {\n      var typeRef;\n      var params = [];\n      var results = [];\n      var instrs = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.type)) {\n          eatToken(); // (\n\n          eatToken(); // type\n\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          /**\n           * Params can be empty:\n           * (params)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            params.push.apply(params, _toConsumableArray(parseFuncParam()));\n          }\n        } else if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          /**\n           * Results can be empty:\n           * (result)`\n           */\n\n          if (token.type !== tokens.closeParen) {\n            results.push.apply(results, _toConsumableArray(parseFuncResult()));\n          }\n        } else {\n          eatTokenOfType(tokens.openParen);\n          instrs.push(parseFuncInstr());\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.callIndirectInstruction(typeRef !== undefined ? typeRef : t.signature(params, results), instrs);\n    }\n    /**\n     * Parses an export instruction\n     *\n     * WAT:\n     *\n     * export:  ( export <string> <exkind> )\n     * exkind:  ( func <var> )\n     *          ( global <var> )\n     *          ( table <var> )\n     *          ( memory <var> )\n     * var:    <nat> | <name>\n     *\n     */\n\n\n    function parseExport() {\n      if (token.type !== tokens.string) {\n        throw new Error(\"Expected string after export, got: \" + token.type);\n      }\n\n      var name = token.value;\n      eatToken();\n      var moduleExportDescr = parseModuleExportDescr();\n      return t.moduleExport(name, moduleExportDescr);\n    }\n\n    function parseModuleExportDescr() {\n      var startLoc = getStartLoc();\n      var type = \"\";\n      var index;\n      eatTokenOfType(tokens.openParen);\n\n      while (token.type !== tokens.closeParen) {\n        if (isKeyword(token, keywords.func)) {\n          type = \"Func\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.table)) {\n          type = \"Table\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.global)) {\n          type = \"Global\";\n          eatToken();\n          index = parseExportIndex(token);\n        } else if (isKeyword(token, keywords.memory)) {\n          type = \"Memory\";\n          eatToken();\n          index = parseExportIndex(token);\n        }\n\n        eatToken();\n      }\n\n      if (type === \"\") {\n        throw new Error(\"Unknown export type\");\n      }\n\n      if (index === undefined) {\n        throw new Error(\"Exported function must have a name\");\n      }\n\n      var node = t.moduleExportDescr(type, index);\n      var endLoc = getEndLoc();\n      eatTokenOfType(tokens.closeParen);\n      return t.withLoc(node, endLoc, startLoc);\n    }\n\n    function parseModule() {\n      var name = null;\n      var isBinary = false;\n      var isQuote = false;\n      var moduleFields = [];\n\n      if (token.type === tokens.identifier) {\n        name = token.value;\n        eatToken();\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"binary\") {\n        eatToken();\n        isBinary = true;\n      }\n\n      if (hasPlugin(\"wast\") && token.type === tokens.name && token.value === \"quote\") {\n        eatToken();\n        isQuote = true;\n      }\n\n      if (isBinary === true) {\n        var blob = [];\n\n        while (token.type === tokens.string) {\n          blob.push(token.value);\n          eatToken();\n          maybeIgnoreComment();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.binaryModule(name, blob);\n      }\n\n      if (isQuote === true) {\n        var string = [];\n\n        while (token.type === tokens.string) {\n          string.push(token.value);\n          eatToken();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n        return t.quoteModule(name, string);\n      }\n\n      while (token.type !== tokens.closeParen) {\n        moduleFields.push(walk());\n\n        if (state.registredExportedElements.length > 0) {\n          state.registredExportedElements.forEach(function (decl) {\n            moduleFields.push(t.moduleExport(decl.name, t.moduleExportDescr(decl.exportType, decl.id)));\n          });\n          state.registredExportedElements = [];\n        }\n\n        token = tokensList[current];\n      }\n\n      eatTokenOfType(tokens.closeParen);\n      return t.module(name, moduleFields);\n    }\n    /**\n     * Parses the arguments of an instruction\n     */\n\n\n    function parseFuncInstrArguments(signature) {\n      var args = [];\n      var namedArgs = {};\n      var signaturePtr = 0;\n\n      while (token.type === tokens.name || isKeyword(token, keywords.offset)) {\n        var key = token.value;\n        eatToken();\n        eatTokenOfType(tokens.equal);\n        var value = void 0;\n\n        if (token.type === tokens.number) {\n          value = t.numberLiteralFromRaw(token.value);\n        } else {\n          throw new Error(\"Unexpected type for argument: \" + token.type);\n        }\n\n        namedArgs[key] = value;\n        eatToken();\n      } // $FlowIgnore\n\n\n      var signatureLength = signature.vector ? Infinity : signature.length;\n\n      while (token.type !== tokens.closeParen && ( // $FlowIgnore\n      token.type === tokens.openParen || signaturePtr < signatureLength)) {\n        if (token.type === tokens.identifier) {\n          args.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.valtype) {\n          // Handle locals\n          args.push(t.valtypeLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.string) {\n          args.push(t.stringLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          args.push( // TODO(sven): refactor the type signature handling\n          // https://github.com/xtuc/webassemblyjs/pull/129 is a good start\n          t.numberLiteralFromRaw(token.value, // $FlowIgnore\n          signature[signaturePtr] || \"f64\")); // $FlowIgnore\n\n          if (!signature.vector) {\n            ++signaturePtr;\n          }\n\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          /**\n           * Maybe some nested instructions\n           */\n          eatToken(); // Instruction\n\n          if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n          ) {\n              // $FlowIgnore\n              args.push(parseFuncInstr());\n            } else {\n            throw function () {\n              return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in nested instruction\" + \", given \" + tokenToString(token));\n            }();\n          }\n\n          if (token.type === tokens.closeParen) {\n            eatToken();\n          }\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in instruction argument\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return {\n        args: args,\n        namedArgs: namedArgs\n      };\n    }\n    /**\n     * Parses an instruction\n     *\n     * WAT:\n     *\n     * instr      :: plaininst\n     *               blockinstr\n     *\n     * blockinstr :: 'block' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'loop' I:label rt:resulttype (in:instr*) 'end' id?\n     *               'if' I:label rt:resulttype (in:instr*) 'else' id? (in2:intr*) 'end' id?\n     *\n     * plaininst  :: 'unreachable'\n     *               'nop'\n     *               'br' l:labelidx\n     *               'br_if' l:labelidx\n     *               'br_table' l*:vec(labelidx) ln:labelidx\n     *               'return'\n     *               'call' x:funcidx\n     *               'call_indirect' x, I:typeuse\n     *\n     * WAST:\n     *\n     * instr:\n     *   <expr>\n     *   <op>\n     *   block <name>? <block_sig> <instr>* end <name>?\n     *   loop <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* end <name>?\n     *   if <name>? <block_sig> <instr>* else <name>? <instr>* end <name>?\n     *\n     * expr:\n     *   ( <op> )\n     *   ( <op> <expr>+ )\n     *   ( block <name>? <block_sig> <instr>* )\n     *   ( loop <name>? <block_sig> <instr>* )\n     *   ( if <name>? <block_sig> ( then <instr>* ) ( else <instr>* )? )\n     *   ( if <name>? <block_sig> <expr>+ ( then <instr>* ) ( else <instr>* )? )\n     *\n     * op:\n     *   unreachable\n     *   nop\n     *   br <var>\n     *   br_if <var>\n     *   br_table <var>+\n     *   return\n     *   call <var>\n     *   call_indirect <func_sig>\n     *   drop\n     *   select\n     *   get_local <var>\n     *   set_local <var>\n     *   tee_local <var>\n     *   get_global <var>\n     *   set_global <var>\n     *   <type>.load((8|16|32)_<sign>)? <offset>? <align>?\n     *   <type>.store(8|16|32)? <offset>? <align>?\n     *   current_memory\n     *   grow_memory\n     *   <type>.const <value>\n     *   <type>.<unop>\n     *   <type>.<binop>\n     *   <type>.<testop>\n     *   <type>.<relop>\n     *   <type>.<cvtop>/<type>\n     *\n     * func_type:   ( type <var> )? <param>* <result>*\n     */\n\n\n    function parseFuncInstr() {\n      var startLoc = getStartLoc();\n      maybeIgnoreComment();\n      /**\n       * A simple instruction\n       */\n\n      if (token.type === tokens.name || token.type === tokens.valtype) {\n        var _name2 = token.value;\n        var object;\n        eatToken();\n\n        if (token.type === tokens.dot) {\n          object = _name2;\n          eatToken();\n\n          if (token.type !== tokens.name) {\n            throw new TypeError(\"Unknown token: \" + token.type + \", name expected\");\n          }\n\n          _name2 = token.value;\n          eatToken();\n        }\n\n        if (token.type === tokens.closeParen) {\n          var _endLoc = token.loc.end;\n\n          if (typeof object === \"undefined\") {\n            return t.withLoc(t.instruction(_name2), _endLoc, startLoc);\n          } else {\n            return t.withLoc(t.objectInstruction(_name2, object, []), _endLoc, startLoc);\n          }\n        }\n\n        var signature = t.signatureForOpcode(object || \"\", _name2);\n\n        var _parseFuncInstrArgume = parseFuncInstrArguments(signature),\n            _args = _parseFuncInstrArgume.args,\n            _namedArgs = _parseFuncInstrArgume.namedArgs;\n\n        var endLoc = token.loc.end;\n\n        if (typeof object === \"undefined\") {\n          return t.withLoc(t.instruction(_name2, _args, _namedArgs), endLoc, startLoc);\n        } else {\n          return t.withLoc(t.objectInstruction(_name2, object, _args, _namedArgs), endLoc, startLoc);\n        }\n      } else if (isKeyword(token, keywords.loop)) {\n        /**\n         * Else a instruction with a keyword (loop or block)\n         */\n        eatToken(); // keyword\n\n        return parseLoop();\n      } else if (isKeyword(token, keywords.block)) {\n        eatToken(); // keyword\n\n        return parseBlock();\n      } else if (isKeyword(token, keywords.call_indirect)) {\n        eatToken(); // keyword\n\n        return parseCallIndirect();\n      } else if (isKeyword(token, keywords.call)) {\n        eatToken(); // keyword\n\n        var index;\n\n        if (token.type === tokens.identifier) {\n          index = identifierFromToken(token);\n          eatToken();\n        } else if (token.type === tokens.number) {\n          index = t.indexLiteral(token.value);\n          eatToken();\n        }\n\n        var instrArgs = []; // Nested instruction\n\n        while (token.type === tokens.openParen) {\n          eatToken();\n          instrArgs.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (typeof index === \"undefined\") {\n          throw new Error(\"Missing argument in call instruciton\");\n        }\n\n        if (instrArgs.length > 0) {\n          return t.callInstruction(index, instrArgs);\n        } else {\n          return t.callInstruction(index);\n        }\n      } else if (isKeyword(token, keywords.if)) {\n        eatToken(); // Keyword\n\n        return parseIf();\n      } else if (isKeyword(token, keywords.module) && hasPlugin(\"wast\")) {\n        eatToken(); // In WAST you can have a module as an instruction's argument\n        // we will cast it into a instruction to not break the flow\n        // $FlowIgnore\n\n        var module = parseModule();\n        return module;\n      } else {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected instruction in function body\" + \", given \" + tokenToString(token));\n        }();\n      }\n    }\n    /*\n     * Parses a function\n     *\n     * WAT:\n     *\n     * functype :: ( 'func' t1:vec(param) t2:vec(result) )\n     * param    :: ( 'param' id? t:valtype )\n     * result   :: ( 'result' t:valtype )\n     *\n     * WAST:\n     *\n     * func     :: ( func <name>? <func_sig> <local>* <instr>* )\n     *             ( func <name>? ( export <string> ) <...> )\n     *             ( func <name>? ( import <string> <string> ) <func_sig> )\n     * func_sig :: ( type <var> )? <param>* <result>*\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     * result   :: ( result <type>* )\n     * local    :: ( local <type>* ) | ( local <name> <type> )\n     *\n     */\n\n\n    function parseFunc() {\n      var fnName = t.identifier(getUniqueName(\"func\"));\n      var typeRef;\n      var fnBody = [];\n      var fnParams = [];\n      var fnResult = []; // name\n\n      if (token.type === tokens.identifier) {\n        fnName = identifierFromToken(token);\n        eatToken();\n      } else {\n        fnName = t.withRaw(fnName, \"\"); // preserve anonymous\n      }\n\n      maybeIgnoreComment();\n\n      while (token.type === tokens.openParen || token.type === tokens.name || token.type === tokens.valtype) {\n        // Instructions without parens\n        if (token.type === tokens.name || token.type === tokens.valtype) {\n          fnBody.push(parseFuncInstr());\n          continue;\n        }\n\n        eatToken();\n\n        if (lookaheadAndCheck(keywords.param) === true) {\n          eatToken();\n          fnParams.push.apply(fnParams, _toConsumableArray(parseFuncParam()));\n        } else if (lookaheadAndCheck(keywords.result) === true) {\n          eatToken();\n          fnResult.push.apply(fnResult, _toConsumableArray(parseFuncResult()));\n        } else if (lookaheadAndCheck(keywords.export) === true) {\n          eatToken();\n          parseFuncExport(fnName);\n        } else if (lookaheadAndCheck(keywords.type) === true) {\n          eatToken();\n          typeRef = parseTypeReference();\n        } else if (lookaheadAndCheck(tokens.name) === true || lookaheadAndCheck(tokens.valtype) === true || token.type === \"keyword\" // is any keyword\n        ) {\n            // Instruction\n            fnBody.push(parseFuncInstr());\n          } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func body\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.func(fnName, typeRef !== undefined ? typeRef : t.signature(fnParams, fnResult), fnBody);\n    }\n    /**\n     * Parses shorthand export in func\n     *\n     * export :: ( export <string> )\n     */\n\n\n    function parseFuncExport(funcId) {\n      if (token.type !== tokens.string) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Function export expected a string\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      var name = token.value;\n      eatToken();\n      /**\n       * Func export shorthand, we trait it as a syntaxic sugar.\n       * A export ModuleField will be added later.\n       *\n       * We give the anonymous function a generated name and export it.\n       */\n\n      var id = t.identifier(funcId.value);\n      state.registredExportedElements.push({\n        exportType: \"Func\",\n        name: name,\n        id: id\n      });\n    }\n    /**\n     * Parses a type instruction\n     *\n     * WAST:\n     *\n     * typedef: ( type <name>? ( func <param>* <result>* ) )\n     */\n\n\n    function parseType() {\n      var id;\n      var params = [];\n      var result = [];\n\n      if (token.type === tokens.identifier) {\n        id = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.func)) {\n        eatToken(); // (\n\n        eatToken(); // func\n\n        if (token.type === tokens.closeParen) {\n          eatToken(); // function with an empty signature, we can abort here\n\n          return t.typeInstruction(id, t.signature([], []));\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.param)) {\n          eatToken(); // (\n\n          eatToken(); // param\n\n          params = parseFuncParam();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        if (lookaheadAndCheck(tokens.openParen, keywords.result)) {\n          eatToken(); // (\n\n          eatToken(); // result\n\n          result = parseFuncResult();\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.typeInstruction(id, t.signature(params, result));\n    }\n    /**\n     * Parses a function result\n     *\n     * WAST:\n     *\n     * result :: ( result <type>* )\n     */\n\n\n    function parseFuncResult() {\n      var results = [];\n\n      while (token.type !== tokens.closeParen) {\n        if (token.type !== tokens.valtype) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unexpected token in func result\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        var valtype = token.value;\n        eatToken();\n        results.push(valtype);\n      }\n\n      return results;\n    }\n    /**\n     * Parses a type reference\n     *\n     */\n\n\n    function parseTypeReference() {\n      var ref;\n\n      if (token.type === tokens.identifier) {\n        ref = identifierFromToken(token);\n        eatToken();\n      } else if (token.type === tokens.number) {\n        ref = t.numberLiteralFromRaw(token.value);\n        eatToken();\n      }\n\n      return ref;\n    }\n    /**\n     * Parses a global instruction\n     *\n     * WAST:\n     *\n     * global:  ( global <name>? <global_sig> <instr>* )\n     *          ( global <name>? ( export <string> ) <...> )\n     *          ( global <name>? ( import <string> <string> ) <global_sig> )\n     *\n     * global_sig: <type> | ( mut <type> )\n     *\n     */\n\n\n    function parseGlobal() {\n      var name = t.identifier(getUniqueName(\"global\"));\n      var type; // Keep informations in case of a shorthand import\n\n      var importing = null;\n      maybeIgnoreComment();\n\n      if (token.type === tokens.identifier) {\n        name = identifierFromToken(token);\n        eatToken();\n      } else {\n        name = t.withRaw(name, \"\"); // preserve anonymous\n      }\n      /**\n       * maybe export\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.export)) {\n        eatToken(); // (\n\n        eatToken(); // export\n\n        var exportName = token.value;\n        eatTokenOfType(tokens.string);\n        state.registredExportedElements.push({\n          exportType: \"Global\",\n          name: exportName,\n          id: name\n        });\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * maybe import\n       */\n\n\n      if (lookaheadAndCheck(tokens.openParen, keywords.import)) {\n        eatToken(); // (\n\n        eatToken(); // import\n\n        var moduleName = token.value;\n        eatTokenOfType(tokens.string);\n        var _name3 = token.value;\n        eatTokenOfType(tokens.string);\n        importing = {\n          module: moduleName,\n          name: _name3,\n          descr: undefined\n        };\n        eatTokenOfType(tokens.closeParen);\n      }\n      /**\n       * global_sig\n       */\n\n\n      if (token.type === tokens.valtype) {\n        type = t.globalType(token.value, \"const\");\n        eatToken();\n      } else if (token.type === tokens.openParen) {\n        eatToken(); // (\n\n        if (isKeyword(token, keywords.mut) === false) {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported global type, expected mut\" + \", given \" + tokenToString(token));\n          }();\n        }\n\n        eatToken(); // mut\n\n        type = t.globalType(token.value, \"var\");\n        eatToken();\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      if (type === undefined) {\n        throw function () {\n          return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Could not determine global type\" + \", given \" + tokenToString(token));\n        }();\n      }\n\n      maybeIgnoreComment();\n      var init = [];\n\n      if (importing != null) {\n        importing.descr = type;\n        init.push(t.moduleImport(importing.module, importing.name, importing.descr));\n      }\n      /**\n       * instr*\n       */\n\n\n      while (token.type === tokens.openParen) {\n        eatToken();\n        init.push(parseFuncInstr());\n        eatTokenOfType(tokens.closeParen);\n      }\n\n      return t.global(type, init, name);\n    }\n    /**\n     * Parses a function param\n     *\n     * WAST:\n     *\n     * param    :: ( param <type>* ) | ( param <name> <type> )\n     */\n\n\n    function parseFuncParam() {\n      var params = [];\n      var id;\n      var valtype;\n\n      if (token.type === tokens.identifier) {\n        id = token.value;\n        eatToken();\n      }\n\n      if (token.type === tokens.valtype) {\n        valtype = token.value;\n        eatToken();\n        params.push({\n          id: id,\n          valtype: valtype\n        });\n        /**\n         * Shorthand notation for multiple anonymous parameters\n         * @see https://webassembly.github.io/spec/core/text/types.html#function-types\n         * @see https://github.com/xtuc/webassemblyjs/issues/6\n         */\n\n        if (id === undefined) {\n          while (token.type === tokens.valtype) {\n            valtype = token.value;\n            eatToken();\n            params.push({\n              id: undefined,\n              valtype: valtype\n            });\n          }\n        }\n      } else {// ignore\n      }\n\n      return params;\n    }\n    /**\n     * Parses an element segments instruction\n     *\n     * WAST:\n     *\n     * elem:    ( elem <var>? (offset <instr>* ) <var>* )\n     *          ( elem <var>? <expr> <var>* )\n     *\n     * var:    <nat> | <name>\n     */\n\n\n    function parseElem() {\n      var tableIndex = t.indexLiteral(0);\n      var offset = [];\n      var funcs = [];\n\n      if (token.type === tokens.identifier) {\n        tableIndex = identifierFromToken(token);\n        eatToken();\n      }\n\n      if (token.type === tokens.number) {\n        tableIndex = t.indexLiteral(token.value);\n        eatToken();\n      }\n\n      while (token.type !== tokens.closeParen) {\n        if (lookaheadAndCheck(tokens.openParen, keywords.offset)) {\n          eatToken(); // (\n\n          eatToken(); // offset\n\n          while (token.type !== tokens.closeParen) {\n            eatTokenOfType(tokens.openParen);\n            offset.push(parseFuncInstr());\n            eatTokenOfType(tokens.closeParen);\n          }\n\n          eatTokenOfType(tokens.closeParen);\n        } else if (token.type === tokens.identifier) {\n          funcs.push(t.identifier(token.value));\n          eatToken();\n        } else if (token.type === tokens.number) {\n          funcs.push(t.indexLiteral(token.value));\n          eatToken();\n        } else if (token.type === tokens.openParen) {\n          eatToken(); // (\n\n          offset.push(parseFuncInstr());\n          eatTokenOfType(tokens.closeParen);\n        } else {\n          throw function () {\n            return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unsupported token in elem\" + \", given \" + tokenToString(token));\n          }();\n        }\n      }\n\n      return t.elem(tableIndex, offset, funcs);\n    }\n    /**\n     * Parses the start instruction in a module\n     *\n     * WAST:\n     *\n     * start:   ( start <var> )\n     * var:    <nat> | <name>\n     *\n     * WAT:\n     * start ::= ‘(’ ‘start’  x:funcidx ‘)’\n     */\n\n\n    function parseStart() {\n      if (token.type === tokens.identifier) {\n        var index = identifierFromToken(token);\n        eatToken();\n        return t.start(index);\n      }\n\n      if (token.type === tokens.number) {\n        var _index2 = t.indexLiteral(token.value);\n\n        eatToken();\n        return t.start(_index2);\n      }\n\n      throw new Error(\"Unknown start, token: \" + tokenToString(token));\n    }\n\n    if (token.type === tokens.openParen) {\n      eatToken();\n      var startLoc = getStartLoc();\n\n      if (isKeyword(token, keywords.export)) {\n        eatToken();\n        var node = parseExport();\n\n        var _endLoc2 = getEndLoc();\n\n        return t.withLoc(node, _endLoc2, startLoc);\n      }\n\n      if (isKeyword(token, keywords.loop)) {\n        eatToken();\n\n        var _node = parseLoop();\n\n        var _endLoc3 = getEndLoc();\n\n        return t.withLoc(_node, _endLoc3, startLoc);\n      }\n\n      if (isKeyword(token, keywords.func)) {\n        eatToken();\n\n        var _node2 = parseFunc();\n\n        var _endLoc4 = getEndLoc();\n\n        maybeIgnoreComment();\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node2, _endLoc4, startLoc);\n      }\n\n      if (isKeyword(token, keywords.module)) {\n        eatToken();\n\n        var _node3 = parseModule();\n\n        var _endLoc5 = getEndLoc();\n\n        return t.withLoc(_node3, _endLoc5, startLoc);\n      }\n\n      if (isKeyword(token, keywords.import)) {\n        eatToken();\n\n        var _node4 = parseImport();\n\n        var _endLoc6 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node4, _endLoc6, startLoc);\n      }\n\n      if (isKeyword(token, keywords.block)) {\n        eatToken();\n\n        var _node5 = parseBlock();\n\n        var _endLoc7 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node5, _endLoc7, startLoc);\n      }\n\n      if (isKeyword(token, keywords.memory)) {\n        eatToken();\n\n        var _node6 = parseMemory();\n\n        var _endLoc8 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node6, _endLoc8, startLoc);\n      }\n\n      if (isKeyword(token, keywords.data)) {\n        eatToken();\n\n        var _node7 = parseData();\n\n        var _endLoc9 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node7, _endLoc9, startLoc);\n      }\n\n      if (isKeyword(token, keywords.table)) {\n        eatToken();\n\n        var _node8 = parseTable();\n\n        var _endLoc10 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node8, _endLoc10, startLoc);\n      }\n\n      if (isKeyword(token, keywords.global)) {\n        eatToken();\n\n        var _node9 = parseGlobal();\n\n        var _endLoc11 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node9, _endLoc11, startLoc);\n      }\n\n      if (isKeyword(token, keywords.type)) {\n        eatToken();\n\n        var _node10 = parseType();\n\n        var _endLoc12 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node10, _endLoc12, startLoc);\n      }\n\n      if (isKeyword(token, keywords.start)) {\n        eatToken();\n\n        var _node11 = parseStart();\n\n        var _endLoc13 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node11, _endLoc13, startLoc);\n      }\n\n      if (isKeyword(token, keywords.elem)) {\n        eatToken();\n\n        var _node12 = parseElem();\n\n        var _endLoc14 = getEndLoc();\n\n        eatTokenOfType(tokens.closeParen);\n        return t.withLoc(_node12, _endLoc14, startLoc);\n      }\n\n      var instruction = parseFuncInstr();\n      var endLoc = getEndLoc();\n      maybeIgnoreComment();\n\n      if (_typeof(instruction) === \"object\") {\n        if (typeof token !== \"undefined\") {\n          eatTokenOfType(tokens.closeParen);\n        }\n\n        return t.withLoc(instruction, endLoc, startLoc);\n      }\n    }\n\n    if (token.type === tokens.comment) {\n      var _startLoc = getStartLoc();\n\n      var builder = token.opts.type === \"leading\" ? t.leadingComment : t.blockComment;\n\n      var _node13 = builder(token.value);\n\n      eatToken(); // comment\n\n      var _endLoc15 = getEndLoc();\n\n      return t.withLoc(_node13, _endLoc15, _startLoc);\n    }\n\n    throw function () {\n      return new Error(\"\\n\" + codeFrameFromSource(source, token.loc) + \"\\n\" + \"Unknown token\" + \", given \" + tokenToString(token));\n    }();\n  }\n\n  var body = [];\n\n  while (current < tokensList.length) {\n    body.push(walk());\n  }\n\n  return t.program(body);\n}"]},"metadata":{},"sourceType":"module"}