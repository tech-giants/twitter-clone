{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n/** @typedef {import(\"../Module\")} Module */\n\nclass DependencyReference {\n  // TODO webpack 5: module must be dynamic, you must pass a function returning a module\n  // This is needed to remove the hack in ConcatenatedModule\n  // The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {string[] | boolean} importedNames imported named from the module\n   * @param {boolean=} weak if this is a weak reference\n   * @param {number} order the order information or NaN if don't care\n   */\n  constructor(module, importedNames, weak = false, order = NaN) {\n    // TODO webpack 5: make it a getter\n    this.module = module; // true: full object\n    // false: only sideeffects/no export\n    // array of strings: the exports with this names\n\n    this.importedNames = importedNames;\n    this.weak = !!weak;\n    this.order = order;\n  }\n  /**\n   * @param {DependencyReference[]} array an array (will be modified)\n   * @returns {DependencyReference[]} the array again\n   */\n\n\n  static sort(array) {\n    /** @type {WeakMap<DependencyReference, number>} */\n    const originalOrder = new WeakMap();\n    let i = 0;\n\n    for (const ref of array) {\n      originalOrder.set(ref, i++);\n    }\n\n    return array.sort((a, b) => {\n      const aOrder = a.order;\n      const bOrder = b.order;\n\n      if (isNaN(aOrder)) {\n        if (!isNaN(bOrder)) {\n          return 1;\n        }\n      } else {\n        if (isNaN(bOrder)) {\n          return -1;\n        }\n\n        if (aOrder !== bOrder) {\n          return aOrder - bOrder;\n        }\n      }\n\n      const aOrg = originalOrder.get(a);\n      const bOrg = originalOrder.get(b);\n      return aOrg - bOrg;\n    });\n  }\n\n}\n\nmodule.exports = DependencyReference;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/dependencies/DependencyReference.js"],"names":["DependencyReference","constructor","module","importedNames","weak","order","NaN","sort","array","originalOrder","WeakMap","i","ref","set","a","b","aOrder","bOrder","isNaN","aOrg","get","bOrg","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA,MAAMA,mBAAN,CAA0B;AACzB;AACA;AACA;;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AACCC,EAAAA,WAAW,CAACC,MAAD,EAASC,aAAT,EAAwBC,IAAI,GAAG,KAA/B,EAAsCC,KAAK,GAAGC,GAA9C,EAAmD;AAC7D;AACA,SAAKJ,MAAL,GAAcA,MAAd,CAF6D,CAG7D;AACA;AACA;;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,IAAL,GAAY,CAAC,CAACA,IAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA;AAED;AACD;AACA;AACA;;;AACY,SAAJE,IAAI,CAACC,KAAD,EAAQ;AAClB;AACA,UAAMC,aAAa,GAAG,IAAIC,OAAJ,EAAtB;AACA,QAAIC,CAAC,GAAG,CAAR;;AACA,SAAK,MAAMC,GAAX,IAAkBJ,KAAlB,EAAyB;AACxBC,MAAAA,aAAa,CAACI,GAAd,CAAkBD,GAAlB,EAAuBD,CAAC,EAAxB;AACA;;AACD,WAAOH,KAAK,CAACD,IAAN,CAAW,CAACO,CAAD,EAAIC,CAAJ,KAAU;AAC3B,YAAMC,MAAM,GAAGF,CAAC,CAACT,KAAjB;AACA,YAAMY,MAAM,GAAGF,CAAC,CAACV,KAAjB;;AACA,UAAIa,KAAK,CAACF,MAAD,CAAT,EAAmB;AAClB,YAAI,CAACE,KAAK,CAACD,MAAD,CAAV,EAAoB;AACnB,iBAAO,CAAP;AACA;AACD,OAJD,MAIO;AACN,YAAIC,KAAK,CAACD,MAAD,CAAT,EAAmB;AAClB,iBAAO,CAAC,CAAR;AACA;;AACD,YAAID,MAAM,KAAKC,MAAf,EAAuB;AACtB,iBAAOD,MAAM,GAAGC,MAAhB;AACA;AACD;;AACD,YAAME,IAAI,GAAGV,aAAa,CAACW,GAAd,CAAkBN,CAAlB,CAAb;AACA,YAAMO,IAAI,GAAGZ,aAAa,CAACW,GAAd,CAAkBL,CAAlB,CAAb;AACA,aAAOI,IAAI,GAAGE,IAAd;AACA,KAlBM,CAAP;AAmBA;;AApDwB;;AAuD1BnB,MAAM,CAACoB,OAAP,GAAiBtB,mBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n\n/** @typedef {import(\"../Module\")} Module */\n\nclass DependencyReference {\n\t// TODO webpack 5: module must be dynamic, you must pass a function returning a module\n\t// This is needed to remove the hack in ConcatenatedModule\n\t// The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\t/**\n\t *\n\t * @param {Module} module the referenced module\n\t * @param {string[] | boolean} importedNames imported named from the module\n\t * @param {boolean=} weak if this is a weak reference\n\t * @param {number} order the order information or NaN if don't care\n\t */\n\tconstructor(module, importedNames, weak = false, order = NaN) {\n\t\t// TODO webpack 5: make it a getter\n\t\tthis.module = module;\n\t\t// true: full object\n\t\t// false: only sideeffects/no export\n\t\t// array of strings: the exports with this names\n\t\tthis.importedNames = importedNames;\n\t\tthis.weak = !!weak;\n\t\tthis.order = order;\n\t}\n\n\t/**\n\t * @param {DependencyReference[]} array an array (will be modified)\n\t * @returns {DependencyReference[]} the array again\n\t */\n\tstatic sort(array) {\n\t\t/** @type {WeakMap<DependencyReference, number>} */\n\t\tconst originalOrder = new WeakMap();\n\t\tlet i = 0;\n\t\tfor (const ref of array) {\n\t\t\toriginalOrder.set(ref, i++);\n\t\t}\n\t\treturn array.sort((a, b) => {\n\t\t\tconst aOrder = a.order;\n\t\t\tconst bOrder = b.order;\n\t\t\tif (isNaN(aOrder)) {\n\t\t\t\tif (!isNaN(bOrder)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isNaN(bOrder)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (aOrder !== bOrder) {\n\t\t\t\t\treturn aOrder - bOrder;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst aOrg = originalOrder.get(a);\n\t\t\tconst bOrg = originalOrder.get(b);\n\t\t\treturn aOrg - bOrg;\n\t\t});\n\t}\n}\n\nmodule.exports = DependencyReference;\n"]},"metadata":{},"sourceType":"script"}