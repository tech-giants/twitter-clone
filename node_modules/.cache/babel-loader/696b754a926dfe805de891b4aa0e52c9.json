{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\n\nconst schema = require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n\n\nclass MinChunkSizePlugin {\n  /**\n   * @param {MinChunkSizePluginOptions} options options object\n   */\n  constructor(options) {\n    validateOptions(schema, options, \"Min Chunk Size Plugin\");\n    this.options = options;\n  }\n\n  apply(compiler) {\n    const options = this.options;\n    const minChunkSize = options.minChunkSize;\n    compiler.hooks.compilation.tap(\"MinChunkSizePlugin\", compilation => {\n      compilation.hooks.optimizeChunksAdvanced.tap(\"MinChunkSizePlugin\", chunks => {\n        const equalOptions = {\n          chunkOverhead: 1,\n          entryChunkMultiplicator: 1\n        };\n        const sortedSizeFilteredExtendedPairCombinations = chunks.reduce((combinations, a, idx) => {\n          // create combination pairs\n          for (let i = 0; i < idx; i++) {\n            const b = chunks[i];\n            combinations.push([b, a]);\n          }\n\n          return combinations;\n        }, []).filter(pair => {\n          // check if one of the chunks sizes is smaller than the minChunkSize\n          const p0SmallerThanMinChunkSize = pair[0].size(equalOptions) < minChunkSize;\n          const p1SmallerThanMinChunkSize = pair[1].size(equalOptions) < minChunkSize;\n          return p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;\n        }).map(pair => {\n          // extend combination pairs with size and integrated size\n          const a = pair[0].size(options);\n          const b = pair[1].size(options);\n          const ab = pair[0].integratedSize(pair[1], options);\n          return [a + b - ab, ab, pair[0], pair[1]];\n        }).filter(pair => {\n          // filter pairs that do not have an integratedSize\n          // meaning they can NOT be integrated!\n          return pair[1] !== false;\n        }).sort((a, b) => {\n          // sadly javascript does an inplace sort here\n          // sort by size\n          const diff = b[0] - a[0];\n          if (diff !== 0) return diff;\n          return a[1] - b[1];\n        });\n        if (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n        const pair = sortedSizeFilteredExtendedPairCombinations[0];\n        pair[2].integrate(pair[3], \"min-size\");\n        chunks.splice(chunks.indexOf(pair[3]), 1);\n        return true;\n      });\n    });\n  }\n\n}\n\nmodule.exports = MinChunkSizePlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/optimize/MinChunkSizePlugin.js"],"names":["validateOptions","require","schema","MinChunkSizePlugin","constructor","options","apply","compiler","minChunkSize","hooks","compilation","tap","optimizeChunksAdvanced","chunks","equalOptions","chunkOverhead","entryChunkMultiplicator","sortedSizeFilteredExtendedPairCombinations","reduce","combinations","a","idx","i","b","push","filter","pair","p0SmallerThanMinChunkSize","size","p1SmallerThanMinChunkSize","map","ab","integratedSize","sort","diff","length","integrate","splice","indexOf","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/MinChunkSizePlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/MinChunkSizePlugin\").MinChunkSizePluginOptions} MinChunkSizePluginOptions */\n\nclass MinChunkSizePlugin {\n\t/**\n\t * @param {MinChunkSizePluginOptions} options options object\n\t */\n\tconstructor(options) {\n\t\tvalidateOptions(schema, options, \"Min Chunk Size Plugin\");\n\t\tthis.options = options;\n\t}\n\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tconst minChunkSize = options.minChunkSize;\n\t\tcompiler.hooks.compilation.tap(\"MinChunkSizePlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"MinChunkSizePlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tconst equalOptions = {\n\t\t\t\t\t\tchunkOverhead: 1,\n\t\t\t\t\t\tentryChunkMultiplicator: 1\n\t\t\t\t\t};\n\n\t\t\t\t\tconst sortedSizeFilteredExtendedPairCombinations = chunks\n\t\t\t\t\t\t.reduce((combinations, a, idx) => {\n\t\t\t\t\t\t\t// create combination pairs\n\t\t\t\t\t\t\tfor (let i = 0; i < idx; i++) {\n\t\t\t\t\t\t\t\tconst b = chunks[i];\n\t\t\t\t\t\t\t\tcombinations.push([b, a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t\t}, [])\n\t\t\t\t\t\t.filter(pair => {\n\t\t\t\t\t\t\t// check if one of the chunks sizes is smaller than the minChunkSize\n\t\t\t\t\t\t\tconst p0SmallerThanMinChunkSize =\n\t\t\t\t\t\t\t\tpair[0].size(equalOptions) < minChunkSize;\n\t\t\t\t\t\t\tconst p1SmallerThanMinChunkSize =\n\t\t\t\t\t\t\t\tpair[1].size(equalOptions) < minChunkSize;\n\t\t\t\t\t\t\treturn p0SmallerThanMinChunkSize || p1SmallerThanMinChunkSize;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.map(pair => {\n\t\t\t\t\t\t\t// extend combination pairs with size and integrated size\n\t\t\t\t\t\t\tconst a = pair[0].size(options);\n\t\t\t\t\t\t\tconst b = pair[1].size(options);\n\t\t\t\t\t\t\tconst ab = pair[0].integratedSize(pair[1], options);\n\t\t\t\t\t\t\treturn [a + b - ab, ab, pair[0], pair[1]];\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.filter(pair => {\n\t\t\t\t\t\t\t// filter pairs that do not have an integratedSize\n\t\t\t\t\t\t\t// meaning they can NOT be integrated!\n\t\t\t\t\t\t\treturn pair[1] !== false;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t// sadly javascript does an inplace sort here\n\t\t\t\t\t\t\t// sort by size\n\t\t\t\t\t\t\tconst diff = b[0] - a[0];\n\t\t\t\t\t\t\tif (diff !== 0) return diff;\n\t\t\t\t\t\t\treturn a[1] - b[1];\n\t\t\t\t\t\t});\n\n\t\t\t\t\tif (sortedSizeFilteredExtendedPairCombinations.length === 0) return;\n\n\t\t\t\t\tconst pair = sortedSizeFilteredExtendedPairCombinations[0];\n\n\t\t\t\t\tpair[2].integrate(pair[3], \"min-size\");\n\t\t\t\t\tchunks.splice(chunks.indexOf(pair[3]), 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = MinChunkSizePlugin;\n"]},"metadata":{},"sourceType":"script"}