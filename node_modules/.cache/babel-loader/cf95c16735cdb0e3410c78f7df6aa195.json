{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst Tapable = require(\"tapable/lib/Tapable\");\n\nconst SyncHook = require(\"tapable/lib/SyncHook\");\n\nconst AsyncSeriesBailHook = require(\"tapable/lib/AsyncSeriesBailHook\");\n\nconst AsyncSeriesHook = require(\"tapable/lib/AsyncSeriesHook\");\n\nconst createInnerContext = require(\"./createInnerContext\");\n\nconst REGEXP_NOT_MODULE = /^\\.$|^\\.[\\\\/]|^\\.\\.$|^\\.\\.[\\\\/]|^\\/|^[A-Z]:[\\\\/]/i;\nconst REGEXP_DIRECTORY = /[\\\\/]$/i;\n\nconst memoryFsJoin = require(\"memory-fs/lib/join\");\n\nconst memoizedJoin = new Map();\n\nconst memoryFsNormalize = require(\"memory-fs/lib/normalize\");\n\nfunction withName(name, hook) {\n  hook.name = name;\n  return hook;\n}\n\nfunction toCamelCase(str) {\n  return str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());\n}\n\nconst deprecatedPushToMissing = util.deprecate((set, item) => {\n  set.add(item);\n}, \"Resolver: 'missing' is now a Set. Use add instead of push.\");\nconst deprecatedResolveContextInCallback = util.deprecate(x => {\n  return x;\n}, \"Resolver: The callback argument was splitted into resolveContext and callback.\");\nconst deprecatedHookAsString = util.deprecate(x => {\n  return x;\n}, \"Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.\");\n\nclass Resolver extends Tapable {\n  constructor(fileSystem) {\n    super();\n    this.fileSystem = fileSystem;\n    this.hooks = {\n      resolveStep: withName(\"resolveStep\", new SyncHook([\"hook\", \"request\"])),\n      noResolve: withName(\"noResolve\", new SyncHook([\"request\", \"error\"])),\n      resolve: withName(\"resolve\", new AsyncSeriesBailHook([\"request\", \"resolveContext\"])),\n      result: new AsyncSeriesHook([\"result\", \"resolveContext\"])\n    };\n\n    this._pluginCompat.tap(\"Resolver: before/after\", options => {\n      if (/^before-/.test(options.name)) {\n        options.name = options.name.substr(7);\n        options.stage = -10;\n      } else if (/^after-/.test(options.name)) {\n        options.name = options.name.substr(6);\n        options.stage = 10;\n      }\n    });\n\n    this._pluginCompat.tap(\"Resolver: step hooks\", options => {\n      const name = options.name;\n      const stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);\n\n      if (stepHook) {\n        options.async = true;\n        this.ensureHook(name);\n        const fn = options.fn;\n\n        options.fn = (request, resolverContext, callback) => {\n          const innerCallback = (err, result) => {\n            if (err) return callback(err);\n            if (result !== undefined) return callback(null, result);\n            callback();\n          };\n\n          for (const key in resolverContext) {\n            innerCallback[key] = resolverContext[key];\n          }\n\n          fn.call(this, request, innerCallback);\n        };\n      }\n    });\n  }\n\n  ensureHook(name) {\n    if (typeof name !== \"string\") return name;\n    name = toCamelCase(name);\n\n    if (/^before/.test(name)) {\n      return this.ensureHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n        stage: -10\n      });\n    }\n\n    if (/^after/.test(name)) {\n      return this.ensureHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n        stage: 10\n      });\n    }\n\n    const hook = this.hooks[name];\n\n    if (!hook) {\n      return this.hooks[name] = withName(name, new AsyncSeriesBailHook([\"request\", \"resolveContext\"]));\n    }\n\n    return hook;\n  }\n\n  getHook(name) {\n    if (typeof name !== \"string\") return name;\n    name = toCamelCase(name);\n\n    if (/^before/.test(name)) {\n      return this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n        stage: -10\n      });\n    }\n\n    if (/^after/.test(name)) {\n      return this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n        stage: 10\n      });\n    }\n\n    const hook = this.hooks[name];\n\n    if (!hook) {\n      throw new Error(`Hook ${name} doesn't exist`);\n    }\n\n    return hook;\n  }\n\n  resolveSync(context, path, request) {\n    let err,\n        result,\n        sync = false;\n    this.resolve(context, path, request, {}, (e, r) => {\n      err = e;\n      result = r;\n      sync = true;\n    });\n    if (!sync) throw new Error(\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\");\n    if (err) throw err;\n    return result;\n  }\n\n  resolve(context, path, request, resolveContext, callback) {\n    // TODO remove in enhanced-resolve 5\n    // For backward compatiblity START\n    if (typeof callback !== \"function\") {\n      callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties\n      // It's now used for resolveContext and callback\n    } // END\n\n\n    const obj = {\n      context: context,\n      path: path,\n      request: request\n    };\n    const message = \"resolve '\" + request + \"' in '\" + path + \"'\"; // Try to resolve assuming there is no error\n    // We don't log stuff in this case\n\n    return this.doResolve(this.hooks.resolve, obj, message, {\n      missing: resolveContext.missing,\n      stack: resolveContext.stack\n    }, (err, result) => {\n      if (!err && result) {\n        return callback(null, result.path === false ? false : result.path + (result.query || \"\"), result);\n      }\n\n      const localMissing = new Set(); // TODO remove in enhanced-resolve 5\n\n      localMissing.push = item => deprecatedPushToMissing(localMissing, item);\n\n      const log = [];\n      return this.doResolve(this.hooks.resolve, obj, message, {\n        log: msg => {\n          if (resolveContext.log) {\n            resolveContext.log(msg);\n          }\n\n          log.push(msg);\n        },\n        missing: localMissing,\n        stack: resolveContext.stack\n      }, (err, result) => {\n        if (err) return callback(err);\n        const error = new Error(\"Can't \" + message);\n        error.details = log.join(\"\\n\");\n        error.missing = Array.from(localMissing);\n        this.hooks.noResolve.call(obj, error);\n        return callback(error);\n      });\n    });\n  }\n\n  doResolve(hook, request, message, resolveContext, callback) {\n    // TODO remove in enhanced-resolve 5\n    // For backward compatiblity START\n    if (typeof callback !== \"function\") {\n      callback = deprecatedResolveContextInCallback(resolveContext); // resolveContext is a function containing additional properties\n      // It's now used for resolveContext and callback\n    }\n\n    if (typeof hook === \"string\") {\n      const name = toCamelCase(hook);\n      hook = deprecatedHookAsString(this.hooks[name]);\n\n      if (!hook) {\n        throw new Error(`Hook \"${name}\" doesn't exist`);\n      }\n    } // END\n\n\n    if (typeof callback !== \"function\") throw new Error(\"callback is not a function \" + Array.from(arguments));\n    if (!resolveContext) throw new Error(\"resolveContext is not an object \" + Array.from(arguments));\n    const stackLine = hook.name + \": (\" + request.path + \") \" + (request.request || \"\") + (request.query || \"\") + (request.directory ? \" directory\" : \"\") + (request.module ? \" module\" : \"\");\n    let newStack;\n\n    if (resolveContext.stack) {\n      newStack = new Set(resolveContext.stack);\n\n      if (resolveContext.stack.has(stackLine)) {\n        // Prevent recursion\n        const recursionError = new Error(\"Recursion in resolving\\nStack:\\n  \" + Array.from(newStack).join(\"\\n  \"));\n        recursionError.recursion = true;\n        if (resolveContext.log) resolveContext.log(\"abort resolving because of recursion\");\n        return callback(recursionError);\n      }\n\n      newStack.add(stackLine);\n    } else {\n      newStack = new Set([stackLine]);\n    }\n\n    this.hooks.resolveStep.call(hook, request);\n\n    if (hook.isUsed()) {\n      const innerContext = createInnerContext({\n        log: resolveContext.log,\n        missing: resolveContext.missing,\n        stack: newStack\n      }, message);\n      return hook.callAsync(request, innerContext, (err, result) => {\n        if (err) return callback(err);\n        if (result) return callback(null, result);\n        callback();\n      });\n    } else {\n      callback();\n    }\n  }\n\n  parse(identifier) {\n    if (identifier === \"\") return null;\n    const part = {\n      request: \"\",\n      query: \"\",\n      module: false,\n      directory: false,\n      file: false\n    };\n    const idxQuery = identifier.indexOf(\"?\");\n\n    if (idxQuery === 0) {\n      part.query = identifier;\n    } else if (idxQuery > 0) {\n      part.request = identifier.slice(0, idxQuery);\n      part.query = identifier.slice(idxQuery);\n    } else {\n      part.request = identifier;\n    }\n\n    if (part.request) {\n      part.module = this.isModule(part.request);\n      part.directory = this.isDirectory(part.request);\n\n      if (part.directory) {\n        part.request = part.request.substr(0, part.request.length - 1);\n      }\n    }\n\n    return part;\n  }\n\n  isModule(path) {\n    return !REGEXP_NOT_MODULE.test(path);\n  }\n\n  isDirectory(path) {\n    return REGEXP_DIRECTORY.test(path);\n  }\n\n  join(path, request) {\n    let cacheEntry;\n    let pathCache = memoizedJoin.get(path);\n\n    if (typeof pathCache === \"undefined\") {\n      memoizedJoin.set(path, pathCache = new Map());\n    } else {\n      cacheEntry = pathCache.get(request);\n      if (typeof cacheEntry !== \"undefined\") return cacheEntry;\n    }\n\n    cacheEntry = memoryFsJoin(path, request);\n    pathCache.set(request, cacheEntry);\n    return cacheEntry;\n  }\n\n  normalize(path) {\n    return memoryFsNormalize(path);\n  }\n\n}\n\nmodule.exports = Resolver;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/enhanced-resolve/lib/Resolver.js"],"names":["util","require","Tapable","SyncHook","AsyncSeriesBailHook","AsyncSeriesHook","createInnerContext","REGEXP_NOT_MODULE","REGEXP_DIRECTORY","memoryFsJoin","memoizedJoin","Map","memoryFsNormalize","withName","name","hook","toCamelCase","str","replace","substr","toUpperCase","deprecatedPushToMissing","deprecate","set","item","add","deprecatedResolveContextInCallback","x","deprecatedHookAsString","Resolver","constructor","fileSystem","hooks","resolveStep","noResolve","resolve","result","_pluginCompat","tap","options","test","stage","stepHook","async","ensureHook","fn","request","resolverContext","callback","innerCallback","err","undefined","key","call","toLowerCase","withOptions","getHook","Error","resolveSync","context","path","sync","e","r","resolveContext","obj","message","doResolve","missing","stack","query","localMissing","Set","push","log","msg","error","details","join","Array","from","arguments","stackLine","directory","module","newStack","has","recursionError","recursion","isUsed","innerContext","callAsync","parse","identifier","part","file","idxQuery","indexOf","slice","isModule","isDirectory","length","cacheEntry","pathCache","get","normalize","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\n\nconst Tapable = require(\"tapable/lib/Tapable\");\nconst SyncHook = require(\"tapable/lib/SyncHook\");\nconst AsyncSeriesBailHook = require(\"tapable/lib/AsyncSeriesBailHook\");\nconst AsyncSeriesHook = require(\"tapable/lib/AsyncSeriesHook\");\nconst createInnerContext = require(\"./createInnerContext\");\n\nconst REGEXP_NOT_MODULE = /^\\.$|^\\.[\\\\/]|^\\.\\.$|^\\.\\.[\\\\/]|^\\/|^[A-Z]:[\\\\/]/i;\nconst REGEXP_DIRECTORY = /[\\\\/]$/i;\n\nconst memoryFsJoin = require(\"memory-fs/lib/join\");\nconst memoizedJoin = new Map();\nconst memoryFsNormalize = require(\"memory-fs/lib/normalize\");\n\nfunction withName(name, hook) {\n\thook.name = name;\n\treturn hook;\n}\n\nfunction toCamelCase(str) {\n\treturn str.replace(/-([a-z])/g, str => str.substr(1).toUpperCase());\n}\n\nconst deprecatedPushToMissing = util.deprecate((set, item) => {\n\tset.add(item);\n}, \"Resolver: 'missing' is now a Set. Use add instead of push.\");\n\nconst deprecatedResolveContextInCallback = util.deprecate(x => {\n\treturn x;\n}, \"Resolver: The callback argument was splitted into resolveContext and callback.\");\n\nconst deprecatedHookAsString = util.deprecate(x => {\n\treturn x;\n}, \"Resolver#doResolve: The type arguments (string) is now a hook argument (Hook). Pass a reference to the hook instead.\");\n\nclass Resolver extends Tapable {\n\tconstructor(fileSystem) {\n\t\tsuper();\n\t\tthis.fileSystem = fileSystem;\n\t\tthis.hooks = {\n\t\t\tresolveStep: withName(\"resolveStep\", new SyncHook([\"hook\", \"request\"])),\n\t\t\tnoResolve: withName(\"noResolve\", new SyncHook([\"request\", \"error\"])),\n\t\t\tresolve: withName(\n\t\t\t\t\"resolve\",\n\t\t\t\tnew AsyncSeriesBailHook([\"request\", \"resolveContext\"])\n\t\t\t),\n\t\t\tresult: new AsyncSeriesHook([\"result\", \"resolveContext\"])\n\t\t};\n\t\tthis._pluginCompat.tap(\"Resolver: before/after\", options => {\n\t\t\tif (/^before-/.test(options.name)) {\n\t\t\t\toptions.name = options.name.substr(7);\n\t\t\t\toptions.stage = -10;\n\t\t\t} else if (/^after-/.test(options.name)) {\n\t\t\t\toptions.name = options.name.substr(6);\n\t\t\t\toptions.stage = 10;\n\t\t\t}\n\t\t});\n\t\tthis._pluginCompat.tap(\"Resolver: step hooks\", options => {\n\t\t\tconst name = options.name;\n\t\t\tconst stepHook = !/^resolve(-s|S)tep$|^no(-r|R)esolve$/.test(name);\n\t\t\tif (stepHook) {\n\t\t\t\toptions.async = true;\n\t\t\t\tthis.ensureHook(name);\n\t\t\t\tconst fn = options.fn;\n\t\t\t\toptions.fn = (request, resolverContext, callback) => {\n\t\t\t\t\tconst innerCallback = (err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tif (result !== undefined) return callback(null, result);\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t};\n\t\t\t\t\tfor (const key in resolverContext) {\n\t\t\t\t\t\tinnerCallback[key] = resolverContext[key];\n\t\t\t\t\t}\n\t\t\t\t\tfn.call(this, request, innerCallback);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n\n\tensureHook(name) {\n\t\tif (typeof name !== \"string\") return name;\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn this.ensureHook(\n\t\t\t\tname[6].toLowerCase() + name.substr(7)\n\t\t\t).withOptions({\n\t\t\t\tstage: -10\n\t\t\t});\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn this.ensureHook(\n\t\t\t\tname[5].toLowerCase() + name.substr(6)\n\t\t\t).withOptions({\n\t\t\t\tstage: 10\n\t\t\t});\n\t\t}\n\t\tconst hook = this.hooks[name];\n\t\tif (!hook) {\n\t\t\treturn (this.hooks[name] = withName(\n\t\t\t\tname,\n\t\t\t\tnew AsyncSeriesBailHook([\"request\", \"resolveContext\"])\n\t\t\t));\n\t\t}\n\t\treturn hook;\n\t}\n\n\tgetHook(name) {\n\t\tif (typeof name !== \"string\") return name;\n\t\tname = toCamelCase(name);\n\t\tif (/^before/.test(name)) {\n\t\t\treturn this.getHook(name[6].toLowerCase() + name.substr(7)).withOptions({\n\t\t\t\tstage: -10\n\t\t\t});\n\t\t}\n\t\tif (/^after/.test(name)) {\n\t\t\treturn this.getHook(name[5].toLowerCase() + name.substr(6)).withOptions({\n\t\t\t\tstage: 10\n\t\t\t});\n\t\t}\n\t\tconst hook = this.hooks[name];\n\t\tif (!hook) {\n\t\t\tthrow new Error(`Hook ${name} doesn't exist`);\n\t\t}\n\t\treturn hook;\n\t}\n\n\tresolveSync(context, path, request) {\n\t\tlet err,\n\t\t\tresult,\n\t\t\tsync = false;\n\t\tthis.resolve(context, path, request, {}, (e, r) => {\n\t\t\terr = e;\n\t\t\tresult = r;\n\t\t\tsync = true;\n\t\t});\n\t\tif (!sync)\n\t\t\tthrow new Error(\n\t\t\t\t\"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!\"\n\t\t\t);\n\t\tif (err) throw err;\n\t\treturn result;\n\t}\n\n\tresolve(context, path, request, resolveContext, callback) {\n\t\t// TODO remove in enhanced-resolve 5\n\t\t// For backward compatiblity START\n\t\tif (typeof callback !== \"function\") {\n\t\t\tcallback = deprecatedResolveContextInCallback(resolveContext);\n\t\t\t// resolveContext is a function containing additional properties\n\t\t\t// It's now used for resolveContext and callback\n\t\t}\n\t\t// END\n\t\tconst obj = {\n\t\t\tcontext: context,\n\t\t\tpath: path,\n\t\t\trequest: request\n\t\t};\n\n\t\tconst message = \"resolve '\" + request + \"' in '\" + path + \"'\";\n\n\t\t// Try to resolve assuming there is no error\n\t\t// We don't log stuff in this case\n\t\treturn this.doResolve(\n\t\t\tthis.hooks.resolve,\n\t\t\tobj,\n\t\t\tmessage,\n\t\t\t{\n\t\t\t\tmissing: resolveContext.missing,\n\t\t\t\tstack: resolveContext.stack\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (!err && result) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tresult.path === false ? false : result.path + (result.query || \"\"),\n\t\t\t\t\t\tresult\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst localMissing = new Set();\n\t\t\t\t// TODO remove in enhanced-resolve 5\n\t\t\t\tlocalMissing.push = item => deprecatedPushToMissing(localMissing, item);\n\t\t\t\tconst log = [];\n\n\t\t\t\treturn this.doResolve(\n\t\t\t\t\tthis.hooks.resolve,\n\t\t\t\t\tobj,\n\t\t\t\t\tmessage,\n\t\t\t\t\t{\n\t\t\t\t\t\tlog: msg => {\n\t\t\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\t\t\tresolveContext.log(msg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlog.push(msg);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmissing: localMissing,\n\t\t\t\t\t\tstack: resolveContext.stack\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tconst error = new Error(\"Can't \" + message);\n\t\t\t\t\t\terror.details = log.join(\"\\n\");\n\t\t\t\t\t\terror.missing = Array.from(localMissing);\n\t\t\t\t\t\tthis.hooks.noResolve.call(obj, error);\n\t\t\t\t\t\treturn callback(error);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\tdoResolve(hook, request, message, resolveContext, callback) {\n\t\t// TODO remove in enhanced-resolve 5\n\t\t// For backward compatiblity START\n\t\tif (typeof callback !== \"function\") {\n\t\t\tcallback = deprecatedResolveContextInCallback(resolveContext);\n\t\t\t// resolveContext is a function containing additional properties\n\t\t\t// It's now used for resolveContext and callback\n\t\t}\n\t\tif (typeof hook === \"string\") {\n\t\t\tconst name = toCamelCase(hook);\n\t\t\thook = deprecatedHookAsString(this.hooks[name]);\n\t\t\tif (!hook) {\n\t\t\t\tthrow new Error(`Hook \"${name}\" doesn't exist`);\n\t\t\t}\n\t\t}\n\t\t// END\n\t\tif (typeof callback !== \"function\")\n\t\t\tthrow new Error(\"callback is not a function \" + Array.from(arguments));\n\t\tif (!resolveContext)\n\t\t\tthrow new Error(\n\t\t\t\t\"resolveContext is not an object \" + Array.from(arguments)\n\t\t\t);\n\n\t\tconst stackLine =\n\t\t\thook.name +\n\t\t\t\": (\" +\n\t\t\trequest.path +\n\t\t\t\") \" +\n\t\t\t(request.request || \"\") +\n\t\t\t(request.query || \"\") +\n\t\t\t(request.directory ? \" directory\" : \"\") +\n\t\t\t(request.module ? \" module\" : \"\");\n\n\t\tlet newStack;\n\t\tif (resolveContext.stack) {\n\t\t\tnewStack = new Set(resolveContext.stack);\n\t\t\tif (resolveContext.stack.has(stackLine)) {\n\t\t\t\t// Prevent recursion\n\t\t\t\tconst recursionError = new Error(\n\t\t\t\t\t\"Recursion in resolving\\nStack:\\n  \" +\n\t\t\t\t\t\tArray.from(newStack).join(\"\\n  \")\n\t\t\t\t);\n\t\t\t\trecursionError.recursion = true;\n\t\t\t\tif (resolveContext.log)\n\t\t\t\t\tresolveContext.log(\"abort resolving because of recursion\");\n\t\t\t\treturn callback(recursionError);\n\t\t\t}\n\t\t\tnewStack.add(stackLine);\n\t\t} else {\n\t\t\tnewStack = new Set([stackLine]);\n\t\t}\n\t\tthis.hooks.resolveStep.call(hook, request);\n\n\t\tif (hook.isUsed()) {\n\t\t\tconst innerContext = createInnerContext(\n\t\t\t\t{\n\t\t\t\t\tlog: resolveContext.log,\n\t\t\t\t\tmissing: resolveContext.missing,\n\t\t\t\t\tstack: newStack\n\t\t\t\t},\n\t\t\t\tmessage\n\t\t\t);\n\t\t\treturn hook.callAsync(request, innerContext, (err, result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tif (result) return callback(null, result);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\tparse(identifier) {\n\t\tif (identifier === \"\") return null;\n\t\tconst part = {\n\t\t\trequest: \"\",\n\t\t\tquery: \"\",\n\t\t\tmodule: false,\n\t\t\tdirectory: false,\n\t\t\tfile: false\n\t\t};\n\t\tconst idxQuery = identifier.indexOf(\"?\");\n\t\tif (idxQuery === 0) {\n\t\t\tpart.query = identifier;\n\t\t} else if (idxQuery > 0) {\n\t\t\tpart.request = identifier.slice(0, idxQuery);\n\t\t\tpart.query = identifier.slice(idxQuery);\n\t\t} else {\n\t\t\tpart.request = identifier;\n\t\t}\n\t\tif (part.request) {\n\t\t\tpart.module = this.isModule(part.request);\n\t\t\tpart.directory = this.isDirectory(part.request);\n\t\t\tif (part.directory) {\n\t\t\t\tpart.request = part.request.substr(0, part.request.length - 1);\n\t\t\t}\n\t\t}\n\t\treturn part;\n\t}\n\n\tisModule(path) {\n\t\treturn !REGEXP_NOT_MODULE.test(path);\n\t}\n\n\tisDirectory(path) {\n\t\treturn REGEXP_DIRECTORY.test(path);\n\t}\n\n\tjoin(path, request) {\n\t\tlet cacheEntry;\n\t\tlet pathCache = memoizedJoin.get(path);\n\t\tif (typeof pathCache === \"undefined\") {\n\t\t\tmemoizedJoin.set(path, (pathCache = new Map()));\n\t\t} else {\n\t\t\tcacheEntry = pathCache.get(request);\n\t\t\tif (typeof cacheEntry !== \"undefined\") return cacheEntry;\n\t\t}\n\t\tcacheEntry = memoryFsJoin(path, request);\n\t\tpathCache.set(request, cacheEntry);\n\t\treturn cacheEntry;\n\t}\n\n\tnormalize(path) {\n\t\treturn memoryFsNormalize(path);\n\t}\n}\n\nmodule.exports = Resolver;\n"]},"metadata":{},"sourceType":"script"}