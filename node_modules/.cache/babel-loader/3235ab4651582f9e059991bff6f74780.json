{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n  constructor(config) {\n    this.config = config;\n    this.options = undefined;\n    this._args = undefined;\n  }\n\n  create(options) {\n    this.init(options);\n    let fn;\n\n    switch (this.options.type) {\n      case \"sync\":\n        fn = new Function(this.args(), '\"use strict\";\\n' + this.header() + this.content({\n          onError: err => `throw ${err};\\n`,\n          onResult: result => `return ${result};\\n`,\n          resultReturns: true,\n          onDone: () => \"\",\n          rethrowIfPossible: true\n        }));\n        break;\n\n      case \"async\":\n        fn = new Function(this.args({\n          after: \"_callback\"\n        }), '\"use strict\";\\n' + this.header() + this.content({\n          onError: err => `_callback(${err});\\n`,\n          onResult: result => `_callback(null, ${result});\\n`,\n          onDone: () => \"_callback();\\n\"\n        }));\n        break;\n\n      case \"promise\":\n        let errorHelperUsed = false;\n        const content = this.content({\n          onError: err => {\n            errorHelperUsed = true;\n            return `_error(${err});\\n`;\n          },\n          onResult: result => `_resolve(${result});\\n`,\n          onDone: () => \"_resolve();\\n\"\n        });\n        let code = \"\";\n        code += '\"use strict\";\\n';\n        code += \"return new Promise((_resolve, _reject) => {\\n\";\n\n        if (errorHelperUsed) {\n          code += \"var _sync = true;\\n\";\n          code += \"function _error(_err) {\\n\";\n          code += \"if(_sync)\\n\";\n          code += \"_resolve(Promise.resolve().then(() => { throw _err; }));\\n\";\n          code += \"else\\n\";\n          code += \"_reject(_err);\\n\";\n          code += \"};\\n\";\n        }\n\n        code += this.header();\n        code += content;\n\n        if (errorHelperUsed) {\n          code += \"_sync = false;\\n\";\n        }\n\n        code += \"});\\n\";\n        fn = new Function(this.args(), code);\n        break;\n    }\n\n    this.deinit();\n    return fn;\n  }\n\n  setup(instance, options) {\n    instance._x = options.taps.map(t => t.fn);\n  }\n  /**\n   * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n   */\n\n\n  init(options) {\n    this.options = options;\n    this._args = options.args.slice();\n  }\n\n  deinit() {\n    this.options = undefined;\n    this._args = undefined;\n  }\n\n  header() {\n    let code = \"\";\n\n    if (this.needContext()) {\n      code += \"var _context = {};\\n\";\n    } else {\n      code += \"var _context;\\n\";\n    }\n\n    code += \"var _x = this._x;\\n\";\n\n    if (this.options.interceptors.length > 0) {\n      code += \"var _taps = this.taps;\\n\";\n      code += \"var _interceptors = this.interceptors;\\n\";\n    }\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.call) {\n        code += `${this.getInterceptor(i)}.call(${this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        })});\\n`;\n      }\n    }\n\n    return code;\n  }\n\n  needContext() {\n    for (const tap of this.options.taps) if (tap.context) return true;\n\n    return false;\n  }\n\n  callTap(tapIndex, {\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible\n  }) {\n    let code = \"\";\n    let hasTapCached = false;\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.tap) {\n        if (!hasTapCached) {\n          code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n          hasTapCached = true;\n        }\n\n        code += `${this.getInterceptor(i)}.tap(${interceptor.context ? \"_context, \" : \"\"}_tap${tapIndex});\\n`;\n      }\n    }\n\n    code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n    const tap = this.options.taps[tapIndex];\n\n    switch (tap.type) {\n      case \"sync\":\n        if (!rethrowIfPossible) {\n          code += `var _hasError${tapIndex} = false;\\n`;\n          code += \"try {\\n\";\n        }\n\n        if (onResult) {\n          code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        } else {\n          code += `_fn${tapIndex}(${this.args({\n            before: tap.context ? \"_context\" : undefined\n          })});\\n`;\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"} catch(_err) {\\n\";\n          code += `_hasError${tapIndex} = true;\\n`;\n          code += onError(\"_err\");\n          code += \"}\\n\";\n          code += `if(!_hasError${tapIndex}) {\\n`;\n        }\n\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        if (!rethrowIfPossible) {\n          code += \"}\\n\";\n        }\n\n        break;\n\n      case \"async\":\n        let cbCode = \"\";\n        if (onResult) cbCode += `(_err${tapIndex}, _result${tapIndex}) => {\\n`;else cbCode += `_err${tapIndex} => {\\n`;\n        cbCode += `if(_err${tapIndex}) {\\n`;\n        cbCode += onError(`_err${tapIndex}`);\n        cbCode += \"} else {\\n\";\n\n        if (onResult) {\n          cbCode += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          cbCode += onDone();\n        }\n\n        cbCode += \"}\\n\";\n        cbCode += \"}\";\n        code += `_fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined,\n          after: cbCode\n        })});\\n`;\n        break;\n\n      case \"promise\":\n        code += `var _hasResult${tapIndex} = false;\\n`;\n        code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({\n          before: tap.context ? \"_context\" : undefined\n        })});\\n`;\n        code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\\n`;\n        code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\\n`;\n        code += `_promise${tapIndex}.then(_result${tapIndex} => {\\n`;\n        code += `_hasResult${tapIndex} = true;\\n`;\n\n        if (onResult) {\n          code += onResult(`_result${tapIndex}`);\n        }\n\n        if (onDone) {\n          code += onDone();\n        }\n\n        code += `}, _err${tapIndex} => {\\n`;\n        code += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n        code += onError(`_err${tapIndex}`);\n        code += \"});\\n\";\n        break;\n    }\n\n    return code;\n  }\n\n  callTapsSeries({\n    onError,\n    onResult,\n    resultReturns,\n    onDone,\n    doneReturns,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n    const somethingReturns = resultReturns || doneReturns || false;\n    let code = \"\";\n    let current = onDone;\n\n    for (let j = this.options.taps.length - 1; j >= 0; j--) {\n      const i = j;\n      const unroll = current !== onDone && this.options.taps[i].type !== \"sync\";\n\n      if (unroll) {\n        code += `function _next${i}() {\\n`;\n        code += current();\n        code += `}\\n`;\n\n        current = () => `${somethingReturns ? \"return \" : \"\"}_next${i}();\\n`;\n      }\n\n      const done = current;\n\n      const doneBreak = skipDone => {\n        if (skipDone) return \"\";\n        return onDone();\n      };\n\n      const content = this.callTap(i, {\n        onError: error => onError(i, error, done, doneBreak),\n        onResult: onResult && (result => {\n          return onResult(i, result, done, doneBreak);\n        }),\n        onDone: !onResult && done,\n        rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n      });\n\n      current = () => content;\n    }\n\n    code += current();\n    return code;\n  }\n\n  callTapsLooping({\n    onError,\n    onDone,\n    rethrowIfPossible\n  }) {\n    if (this.options.taps.length === 0) return onDone();\n    const syncOnly = this.options.taps.every(t => t.type === \"sync\");\n    let code = \"\";\n\n    if (!syncOnly) {\n      code += \"var _looper = () => {\\n\";\n      code += \"var _loopAsync = false;\\n\";\n    }\n\n    code += \"var _loop;\\n\";\n    code += \"do {\\n\";\n    code += \"_loop = false;\\n\";\n\n    for (let i = 0; i < this.options.interceptors.length; i++) {\n      const interceptor = this.options.interceptors[i];\n\n      if (interceptor.loop) {\n        code += `${this.getInterceptor(i)}.loop(${this.args({\n          before: interceptor.context ? \"_context\" : undefined\n        })});\\n`;\n      }\n    }\n\n    code += this.callTapsSeries({\n      onError,\n      onResult: (i, result, next, doneBreak) => {\n        let code = \"\";\n        code += `if(${result} !== undefined) {\\n`;\n        code += \"_loop = true;\\n\";\n        if (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n        code += doneBreak(true);\n        code += `} else {\\n`;\n        code += next();\n        code += `}\\n`;\n        return code;\n      },\n      onDone: onDone && (() => {\n        let code = \"\";\n        code += \"if(!_loop) {\\n\";\n        code += onDone();\n        code += \"}\\n\";\n        return code;\n      }),\n      rethrowIfPossible: rethrowIfPossible && syncOnly\n    });\n    code += \"} while(_loop);\\n\";\n\n    if (!syncOnly) {\n      code += \"_loopAsync = true;\\n\";\n      code += \"};\\n\";\n      code += \"_looper();\\n\";\n    }\n\n    return code;\n  }\n\n  callTapsParallel({\n    onError,\n    onResult,\n    onDone,\n    rethrowIfPossible,\n    onTap = (i, run) => run()\n  }) {\n    if (this.options.taps.length <= 1) {\n      return this.callTapsSeries({\n        onError,\n        onResult,\n        onDone,\n        rethrowIfPossible\n      });\n    }\n\n    let code = \"\";\n    code += \"do {\\n\";\n    code += `var _counter = ${this.options.taps.length};\\n`;\n\n    if (onDone) {\n      code += \"var _done = () => {\\n\";\n      code += onDone();\n      code += \"};\\n\";\n    }\n\n    for (let i = 0; i < this.options.taps.length; i++) {\n      const done = () => {\n        if (onDone) return \"if(--_counter === 0) _done();\\n\";else return \"--_counter;\";\n      };\n\n      const doneBreak = skipDone => {\n        if (skipDone || !onDone) return \"_counter = 0;\\n\";else return \"_counter = 0;\\n_done();\\n\";\n      };\n\n      code += \"if(_counter <= 0) break;\\n\";\n      code += onTap(i, () => this.callTap(i, {\n        onError: error => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onError(i, error, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        },\n        onResult: onResult && (result => {\n          let code = \"\";\n          code += \"if(_counter > 0) {\\n\";\n          code += onResult(i, result, done, doneBreak);\n          code += \"}\\n\";\n          return code;\n        }),\n        onDone: !onResult && (() => {\n          return done();\n        }),\n        rethrowIfPossible\n      }), done, doneBreak);\n    }\n\n    code += \"} while(false);\\n\";\n    return code;\n  }\n\n  args({\n    before,\n    after\n  } = {}) {\n    let allArgs = this._args;\n    if (before) allArgs = [before].concat(allArgs);\n    if (after) allArgs = allArgs.concat(after);\n\n    if (allArgs.length === 0) {\n      return \"\";\n    } else {\n      return allArgs.join(\", \");\n    }\n  }\n\n  getTapFn(idx) {\n    return `_x[${idx}]`;\n  }\n\n  getTap(idx) {\n    return `_taps[${idx}]`;\n  }\n\n  getInterceptor(idx) {\n    return `_interceptors[${idx}]`;\n  }\n\n}\n\nmodule.exports = HookCodeFactory;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/tapable/lib/HookCodeFactory.js"],"names":["HookCodeFactory","constructor","config","options","undefined","_args","create","init","fn","type","Function","args","header","content","onError","err","onResult","result","resultReturns","onDone","rethrowIfPossible","after","errorHelperUsed","code","deinit","setup","instance","_x","taps","map","t","slice","needContext","interceptors","length","i","interceptor","call","getInterceptor","before","context","tap","callTap","tapIndex","hasTapCached","getTap","getTapFn","cbCode","callTapsSeries","doneReturns","firstAsync","findIndex","somethingReturns","current","j","unroll","done","doneBreak","skipDone","error","callTapsLooping","syncOnly","every","loop","next","callTapsParallel","onTap","run","allArgs","concat","join","idx","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass HookCodeFactory {\n\tconstructor(config) {\n\t\tthis.config = config;\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\tcreate(options) {\n\t\tthis.init(options);\n\t\tlet fn;\n\t\tswitch (this.options.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args(),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.content({\n\t\t\t\t\t\t\tonError: err => `throw ${err};\\n`,\n\t\t\t\t\t\t\tonResult: result => `return ${result};\\n`,\n\t\t\t\t\t\t\tresultReturns: true,\n\t\t\t\t\t\t\tonDone: () => \"\",\n\t\t\t\t\t\t\trethrowIfPossible: true\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tfn = new Function(\n\t\t\t\t\tthis.args({\n\t\t\t\t\t\tafter: \"_callback\"\n\t\t\t\t\t}),\n\t\t\t\t\t'\"use strict\";\\n' +\n\t\t\t\t\t\tthis.header() +\n\t\t\t\t\t\tthis.content({\n\t\t\t\t\t\t\tonError: err => `_callback(${err});\\n`,\n\t\t\t\t\t\t\tonResult: result => `_callback(null, ${result});\\n`,\n\t\t\t\t\t\t\tonDone: () => \"_callback();\\n\"\n\t\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tlet errorHelperUsed = false;\n\t\t\t\tconst content = this.content({\n\t\t\t\t\tonError: err => {\n\t\t\t\t\t\terrorHelperUsed = true;\n\t\t\t\t\t\treturn `_error(${err});\\n`;\n\t\t\t\t\t},\n\t\t\t\t\tonResult: result => `_resolve(${result});\\n`,\n\t\t\t\t\tonDone: () => \"_resolve();\\n\"\n\t\t\t\t});\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += '\"use strict\";\\n';\n\t\t\t\tcode += \"return new Promise((_resolve, _reject) => {\\n\";\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"var _sync = true;\\n\";\n\t\t\t\t\tcode += \"function _error(_err) {\\n\";\n\t\t\t\t\tcode += \"if(_sync)\\n\";\n\t\t\t\t\tcode += \"_resolve(Promise.resolve().then(() => { throw _err; }));\\n\";\n\t\t\t\t\tcode += \"else\\n\";\n\t\t\t\t\tcode += \"_reject(_err);\\n\";\n\t\t\t\t\tcode += \"};\\n\";\n\t\t\t\t}\n\t\t\t\tcode += this.header();\n\t\t\t\tcode += content;\n\t\t\t\tif (errorHelperUsed) {\n\t\t\t\t\tcode += \"_sync = false;\\n\";\n\t\t\t\t}\n\t\t\t\tcode += \"});\\n\";\n\t\t\t\tfn = new Function(this.args(), code);\n\t\t\t\tbreak;\n\t\t}\n\t\tthis.deinit();\n\t\treturn fn;\n\t}\n\n\tsetup(instance, options) {\n\t\tinstance._x = options.taps.map(t => t.fn);\n\t}\n\n\t/**\n\t * @param {{ type: \"sync\" | \"promise\" | \"async\", taps: Array<Tap>, interceptors: Array<Interceptor> }} options\n\t */\n\tinit(options) {\n\t\tthis.options = options;\n\t\tthis._args = options.args.slice();\n\t}\n\n\tdeinit() {\n\t\tthis.options = undefined;\n\t\tthis._args = undefined;\n\t}\n\n\theader() {\n\t\tlet code = \"\";\n\t\tif (this.needContext()) {\n\t\t\tcode += \"var _context = {};\\n\";\n\t\t} else {\n\t\t\tcode += \"var _context;\\n\";\n\t\t}\n\t\tcode += \"var _x = this._x;\\n\";\n\t\tif (this.options.interceptors.length > 0) {\n\t\t\tcode += \"var _taps = this.taps;\\n\";\n\t\t\tcode += \"var _interceptors = this.interceptors;\\n\";\n\t\t}\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.call) {\n\t\t\t\tcode += `${this.getInterceptor(i)}.call(${this.args({\n\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t}\n\t\t}\n\t\treturn code;\n\t}\n\n\tneedContext() {\n\t\tfor (const tap of this.options.taps) if (tap.context) return true;\n\t\treturn false;\n\t}\n\n\tcallTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {\n\t\tlet code = \"\";\n\t\tlet hasTapCached = false;\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.tap) {\n\t\t\t\tif (!hasTapCached) {\n\t\t\t\t\tcode += `var _tap${tapIndex} = ${this.getTap(tapIndex)};\\n`;\n\t\t\t\t\thasTapCached = true;\n\t\t\t\t}\n\t\t\t\tcode += `${this.getInterceptor(i)}.tap(${\n\t\t\t\t\tinterceptor.context ? \"_context, \" : \"\"\n\t\t\t\t}_tap${tapIndex});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};\\n`;\n\t\tconst tap = this.options.taps[tapIndex];\n\t\tswitch (tap.type) {\n\t\t\tcase \"sync\":\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += `var _hasError${tapIndex} = false;\\n`;\n\t\t\t\t\tcode += \"try {\\n\";\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += `var _result${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t} else {\n\t\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t\t})});\\n`;\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"} catch(_err) {\\n\";\n\t\t\t\t\tcode += `_hasError${tapIndex} = true;\\n`;\n\t\t\t\t\tcode += onError(\"_err\");\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\tcode += `if(!_hasError${tapIndex}) {\\n`;\n\t\t\t\t}\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tif (!rethrowIfPossible) {\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"async\":\n\t\t\t\tlet cbCode = \"\";\n\t\t\t\tif (onResult) cbCode += `(_err${tapIndex}, _result${tapIndex}) => {\\n`;\n\t\t\t\telse cbCode += `_err${tapIndex} => {\\n`;\n\t\t\t\tcbCode += `if(_err${tapIndex}) {\\n`;\n\t\t\t\tcbCode += onError(`_err${tapIndex}`);\n\t\t\t\tcbCode += \"} else {\\n\";\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcbCode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcbCode += onDone();\n\t\t\t\t}\n\t\t\t\tcbCode += \"}\\n\";\n\t\t\t\tcbCode += \"}\";\n\t\t\t\tcode += `_fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined,\n\t\t\t\t\tafter: cbCode\n\t\t\t\t})});\\n`;\n\t\t\t\tbreak;\n\t\t\tcase \"promise\":\n\t\t\t\tcode += `var _hasResult${tapIndex} = false;\\n`;\n\t\t\t\tcode += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({\n\t\t\t\t\tbefore: tap.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t\tcode += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)\\n`;\n\t\t\t\tcode += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');\\n`;\n\t\t\t\tcode += `_promise${tapIndex}.then(_result${tapIndex} => {\\n`;\n\t\t\t\tcode += `_hasResult${tapIndex} = true;\\n`;\n\t\t\t\tif (onResult) {\n\t\t\t\t\tcode += onResult(`_result${tapIndex}`);\n\t\t\t\t}\n\t\t\t\tif (onDone) {\n\t\t\t\t\tcode += onDone();\n\t\t\t\t}\n\t\t\t\tcode += `}, _err${tapIndex} => {\\n`;\n\t\t\t\tcode += `if(_hasResult${tapIndex}) throw _err${tapIndex};\\n`;\n\t\t\t\tcode += onError(`_err${tapIndex}`);\n\t\t\t\tcode += \"});\\n\";\n\t\t\t\tbreak;\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsSeries({\n\t\tonError,\n\t\tonResult,\n\t\tresultReturns,\n\t\tonDone,\n\t\tdoneReturns,\n\t\trethrowIfPossible\n\t}) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst firstAsync = this.options.taps.findIndex(t => t.type !== \"sync\");\n\t\tconst somethingReturns = resultReturns || doneReturns || false;\n\t\tlet code = \"\";\n\t\tlet current = onDone;\n\t\tfor (let j = this.options.taps.length - 1; j >= 0; j--) {\n\t\t\tconst i = j;\n\t\t\tconst unroll = current !== onDone && this.options.taps[i].type !== \"sync\";\n\t\t\tif (unroll) {\n\t\t\t\tcode += `function _next${i}() {\\n`;\n\t\t\t\tcode += current();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\tcurrent = () => `${somethingReturns ? \"return \" : \"\"}_next${i}();\\n`;\n\t\t\t}\n\t\t\tconst done = current;\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone) return \"\";\n\t\t\t\treturn onDone();\n\t\t\t};\n\t\t\tconst content = this.callTap(i, {\n\t\t\t\tonError: error => onError(i, error, done, doneBreak),\n\t\t\t\tonResult:\n\t\t\t\t\tonResult &&\n\t\t\t\t\t(result => {\n\t\t\t\t\t\treturn onResult(i, result, done, doneBreak);\n\t\t\t\t\t}),\n\t\t\t\tonDone: !onResult && done,\n\t\t\t\trethrowIfPossible:\n\t\t\t\t\trethrowIfPossible && (firstAsync < 0 || i < firstAsync)\n\t\t\t});\n\t\t\tcurrent = () => content;\n\t\t}\n\t\tcode += current();\n\t\treturn code;\n\t}\n\n\tcallTapsLooping({ onError, onDone, rethrowIfPossible }) {\n\t\tif (this.options.taps.length === 0) return onDone();\n\t\tconst syncOnly = this.options.taps.every(t => t.type === \"sync\");\n\t\tlet code = \"\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"var _looper = () => {\\n\";\n\t\t\tcode += \"var _loopAsync = false;\\n\";\n\t\t}\n\t\tcode += \"var _loop;\\n\";\n\t\tcode += \"do {\\n\";\n\t\tcode += \"_loop = false;\\n\";\n\t\tfor (let i = 0; i < this.options.interceptors.length; i++) {\n\t\t\tconst interceptor = this.options.interceptors[i];\n\t\t\tif (interceptor.loop) {\n\t\t\t\tcode += `${this.getInterceptor(i)}.loop(${this.args({\n\t\t\t\t\tbefore: interceptor.context ? \"_context\" : undefined\n\t\t\t\t})});\\n`;\n\t\t\t}\n\t\t}\n\t\tcode += this.callTapsSeries({\n\t\t\tonError,\n\t\t\tonResult: (i, result, next, doneBreak) => {\n\t\t\t\tlet code = \"\";\n\t\t\t\tcode += `if(${result} !== undefined) {\\n`;\n\t\t\t\tcode += \"_loop = true;\\n\";\n\t\t\t\tif (!syncOnly) code += \"if(_loopAsync) _looper();\\n\";\n\t\t\t\tcode += doneBreak(true);\n\t\t\t\tcode += `} else {\\n`;\n\t\t\t\tcode += next();\n\t\t\t\tcode += `}\\n`;\n\t\t\t\treturn code;\n\t\t\t},\n\t\t\tonDone:\n\t\t\t\tonDone &&\n\t\t\t\t(() => {\n\t\t\t\t\tlet code = \"\";\n\t\t\t\t\tcode += \"if(!_loop) {\\n\";\n\t\t\t\t\tcode += onDone();\n\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\treturn code;\n\t\t\t\t}),\n\t\t\trethrowIfPossible: rethrowIfPossible && syncOnly\n\t\t});\n\t\tcode += \"} while(_loop);\\n\";\n\t\tif (!syncOnly) {\n\t\t\tcode += \"_loopAsync = true;\\n\";\n\t\t\tcode += \"};\\n\";\n\t\t\tcode += \"_looper();\\n\";\n\t\t}\n\t\treturn code;\n\t}\n\n\tcallTapsParallel({\n\t\tonError,\n\t\tonResult,\n\t\tonDone,\n\t\trethrowIfPossible,\n\t\tonTap = (i, run) => run()\n\t}) {\n\t\tif (this.options.taps.length <= 1) {\n\t\t\treturn this.callTapsSeries({\n\t\t\t\tonError,\n\t\t\t\tonResult,\n\t\t\t\tonDone,\n\t\t\t\trethrowIfPossible\n\t\t\t});\n\t\t}\n\t\tlet code = \"\";\n\t\tcode += \"do {\\n\";\n\t\tcode += `var _counter = ${this.options.taps.length};\\n`;\n\t\tif (onDone) {\n\t\t\tcode += \"var _done = () => {\\n\";\n\t\t\tcode += onDone();\n\t\t\tcode += \"};\\n\";\n\t\t}\n\t\tfor (let i = 0; i < this.options.taps.length; i++) {\n\t\t\tconst done = () => {\n\t\t\t\tif (onDone) return \"if(--_counter === 0) _done();\\n\";\n\t\t\t\telse return \"--_counter;\";\n\t\t\t};\n\t\t\tconst doneBreak = skipDone => {\n\t\t\t\tif (skipDone || !onDone) return \"_counter = 0;\\n\";\n\t\t\t\telse return \"_counter = 0;\\n_done();\\n\";\n\t\t\t};\n\t\t\tcode += \"if(_counter <= 0) break;\\n\";\n\t\t\tcode += onTap(\n\t\t\t\ti,\n\t\t\t\t() =>\n\t\t\t\t\tthis.callTap(i, {\n\t\t\t\t\t\tonError: error => {\n\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\tcode += onError(i, error, done, doneBreak);\n\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tonResult:\n\t\t\t\t\t\t\tonResult &&\n\t\t\t\t\t\t\t(result => {\n\t\t\t\t\t\t\t\tlet code = \"\";\n\t\t\t\t\t\t\t\tcode += \"if(_counter > 0) {\\n\";\n\t\t\t\t\t\t\t\tcode += onResult(i, result, done, doneBreak);\n\t\t\t\t\t\t\t\tcode += \"}\\n\";\n\t\t\t\t\t\t\t\treturn code;\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\tonDone:\n\t\t\t\t\t\t\t!onResult &&\n\t\t\t\t\t\t\t(() => {\n\t\t\t\t\t\t\t\treturn done();\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\trethrowIfPossible\n\t\t\t\t\t}),\n\t\t\t\tdone,\n\t\t\t\tdoneBreak\n\t\t\t);\n\t\t}\n\t\tcode += \"} while(false);\\n\";\n\t\treturn code;\n\t}\n\n\targs({ before, after } = {}) {\n\t\tlet allArgs = this._args;\n\t\tif (before) allArgs = [before].concat(allArgs);\n\t\tif (after) allArgs = allArgs.concat(after);\n\t\tif (allArgs.length === 0) {\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn allArgs.join(\", \");\n\t\t}\n\t}\n\n\tgetTapFn(idx) {\n\t\treturn `_x[${idx}]`;\n\t}\n\n\tgetTap(idx) {\n\t\treturn `_taps[${idx}]`;\n\t}\n\n\tgetInterceptor(idx) {\n\t\treturn `_interceptors[${idx}]`;\n\t}\n}\n\nmodule.exports = HookCodeFactory;\n"]},"metadata":{},"sourceType":"script"}