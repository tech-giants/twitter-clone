{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\n\nconst contentPath = require('./content/path');\n\nconst crypto = require('crypto');\n\nconst figgyPudding = require('figgy-pudding');\n\nconst fixOwner = require('./util/fix-owner');\n\nconst fs = require('graceful-fs');\n\nconst hashToSegments = require('./util/hash-to-segments');\n\nconst ms = require('mississippi');\n\nconst path = require('path');\n\nconst ssri = require('ssri');\n\nconst Y = require('./util/y.js');\n\nconst indexV = require('../package.json')['cache-version'].index;\n\nconst appendFileAsync = BB.promisify(fs.appendFile);\nconst readFileAsync = BB.promisify(fs.readFile);\nconst readdirAsync = BB.promisify(fs.readdir);\nconst concat = ms.concat;\nconst from = ms.from;\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor(cache, key) {\n    super(Y`No cache entry for \\`${key}\\` found in \\`${cache}\\``);\n    this.code = 'ENOENT';\n    this.cache = cache;\n    this.key = key;\n  }\n\n};\nconst IndexOpts = figgyPudding({\n  metadata: {},\n  size: {}\n});\nmodule.exports.insert = insert;\n\nfunction insert(cache, key, integrity, opts) {\n  opts = IndexOpts(opts);\n  const bucket = bucketPath(cache, key);\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  };\n  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(() => {\n    const stringified = JSON.stringify(entry); // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n\n    return appendFileAsync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`);\n  }).then(() => fixOwner.chownr(cache, bucket)).catch({\n    code: 'ENOENT'\n  }, () => {// There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(() => {\n    return formatEntry(cache, entry);\n  });\n}\n\nmodule.exports.insert.sync = insertSync;\n\nfunction insertSync(cache, key, integrity, opts) {\n  opts = IndexOpts(opts);\n  const bucket = bucketPath(cache, key);\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  };\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));\n  const stringified = JSON.stringify(entry);\n  fs.appendFileSync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`);\n\n  try {\n    fixOwner.chownr.sync(cache, bucket);\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n\n  return formatEntry(cache, entry);\n}\n\nmodule.exports.find = find;\n\nfunction find(cache, key) {\n  const bucket = bucketPath(cache, key);\n  return bucketEntries(bucket).then(entries => {\n    return entries.reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  }).catch(err => {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  });\n}\n\nmodule.exports.find.sync = findSync;\n\nfunction findSync(cache, key) {\n  const bucket = bucketPath(cache, key);\n\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}\n\nmodule.exports.delete = del;\n\nfunction del(cache, key, opts) {\n  return insert(cache, key, null, opts);\n}\n\nmodule.exports.delete.sync = delSync;\n\nfunction delSync(cache, key, opts) {\n  return insertSync(cache, key, null, opts);\n}\n\nmodule.exports.lsStream = lsStream;\n\nfunction lsStream(cache) {\n  const indexDir = bucketDir(cache);\n  const stream = from.obj(); // \"/cachename/*\"\n\n  readdirOrEmpty(indexDir).map(bucket => {\n    const bucketPath = path.join(indexDir, bucket); // \"/cachename/<bucket 0xFF>/*\"\n\n    return readdirOrEmpty(bucketPath).map(subbucket => {\n      const subbucketPath = path.join(bucketPath, subbucket); // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n\n      return readdirOrEmpty(subbucketPath).map(entry => {\n        const getKeyToEntry = bucketEntries(path.join(subbucketPath, entry)).reduce((acc, entry) => {\n          acc.set(entry.key, entry);\n          return acc;\n        }, new Map());\n        return getKeyToEntry.then(reduced => {\n          for (let entry of reduced.values()) {\n            const formatted = formatEntry(cache, entry);\n            formatted && stream.push(formatted);\n          }\n        }).catch({\n          code: 'ENOENT'\n        }, nop);\n      });\n    });\n  }).then(() => {\n    stream.push(null);\n  }, err => {\n    stream.emit('error', err);\n  });\n  return stream;\n}\n\nmodule.exports.ls = ls;\n\nfunction ls(cache) {\n  return BB.fromNode(cb => {\n    lsStream(cache).on('error', cb).pipe(concat(entries => {\n      cb(null, entries.reduce((acc, xs) => {\n        acc[xs.key] = xs;\n        return acc;\n      }, {}));\n    }));\n  });\n}\n\nfunction bucketEntries(bucket, filter) {\n  return readFileAsync(bucket, 'utf8').then(data => _bucketEntries(data, filter));\n}\n\nfunction bucketEntriesSync(bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8');\n  return _bucketEntries(data, filter);\n}\n\nfunction _bucketEntries(data, filter) {\n  let entries = [];\n  data.split('\\n').forEach(entry => {\n    if (!entry) {\n      return;\n    }\n\n    const pieces = entry.split('\\t');\n\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return;\n    }\n\n    let obj;\n\n    try {\n      obj = JSON.parse(pieces[1]);\n    } catch (e) {\n      // Entry is corrupted!\n      return;\n    }\n\n    if (obj) {\n      entries.push(obj);\n    }\n  });\n  return entries;\n}\n\nmodule.exports._bucketDir = bucketDir;\n\nfunction bucketDir(cache) {\n  return path.join(cache, `index-v${indexV}`);\n}\n\nmodule.exports._bucketPath = bucketPath;\n\nfunction bucketPath(cache, key) {\n  const hashed = hashKey(key);\n  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));\n}\n\nmodule.exports._hashKey = hashKey;\n\nfunction hashKey(key) {\n  return hash(key, 'sha256');\n}\n\nmodule.exports._hashEntry = hashEntry;\n\nfunction hashEntry(str) {\n  return hash(str, 'sha1');\n}\n\nfunction hash(str, digest) {\n  return crypto.createHash(digest).update(str).digest('hex');\n}\n\nfunction formatEntry(cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) {\n    return null;\n  }\n\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  };\n}\n\nfunction readdirOrEmpty(dir) {\n  return readdirAsync(dir).catch({\n    code: 'ENOENT'\n  }, () => []).catch({\n    code: 'ENOTDIR'\n  }, () => []);\n}\n\nfunction nop() {}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/node_modules/cacache/lib/entry-index.js"],"names":["BB","require","contentPath","crypto","figgyPudding","fixOwner","fs","hashToSegments","ms","path","ssri","Y","indexV","index","appendFileAsync","promisify","appendFile","readFileAsync","readFile","readdirAsync","readdir","concat","from","module","exports","NotFoundError","Error","constructor","cache","key","code","IndexOpts","metadata","size","insert","integrity","opts","bucket","bucketPath","entry","stringify","time","Date","now","mkdirfix","dirname","then","stringified","JSON","hashEntry","chownr","catch","formatEntry","sync","insertSync","appendFileSync","err","find","bucketEntries","entries","reduce","latest","next","findSync","bucketEntriesSync","delete","del","delSync","lsStream","indexDir","bucketDir","stream","obj","readdirOrEmpty","map","join","subbucket","subbucketPath","getKeyToEntry","acc","set","Map","reduced","values","formatted","push","nop","emit","ls","fromNode","cb","on","pipe","xs","filter","data","_bucketEntries","readFileSync","split","forEach","pieces","parse","e","_bucketDir","_bucketPath","hashed","hashKey","apply","_hashKey","hash","_hashEntry","str","digest","createHash","update","dir"],"mappings":"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","sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst contentPath = require('./content/path')\nconst crypto = require('crypto')\nconst figgyPudding = require('figgy-pudding')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('graceful-fs')\nconst hashToSegments = require('./util/hash-to-segments')\nconst ms = require('mississippi')\nconst path = require('path')\nconst ssri = require('ssri')\nconst Y = require('./util/y.js')\n\nconst indexV = require('../package.json')['cache-version'].index\n\nconst appendFileAsync = BB.promisify(fs.appendFile)\nconst readFileAsync = BB.promisify(fs.readFile)\nconst readdirAsync = BB.promisify(fs.readdir)\nconst concat = ms.concat\nconst from = ms.from\n\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor (cache, key) {\n    super(Y`No cache entry for \\`${key}\\` found in \\`${cache}\\``)\n    this.code = 'ENOENT'\n    this.cache = cache\n    this.key = key\n  }\n}\n\nconst IndexOpts = figgyPudding({\n  metadata: {},\n  size: {}\n})\n\nmodule.exports.insert = insert\nfunction insert (cache, key, integrity, opts) {\n  opts = IndexOpts(opts)\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  }\n  return fixOwner.mkdirfix(\n    cache, path.dirname(bucket)\n  ).then(() => {\n    const stringified = JSON.stringify(entry)\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n    return appendFileAsync(\n      bucket, `\\n${hashEntry(stringified)}\\t${stringified}`\n    )\n  }).then(\n    () => fixOwner.chownr(cache, bucket)\n  ).catch({ code: 'ENOENT' }, () => {\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(() => {\n    return formatEntry(cache, entry)\n  })\n}\n\nmodule.exports.insert.sync = insertSync\nfunction insertSync (cache, key, integrity, opts) {\n  opts = IndexOpts(opts)\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  }\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket))\n  const stringified = JSON.stringify(entry)\n  fs.appendFileSync(\n    bucket, `\\n${hashEntry(stringified)}\\t${stringified}`\n  )\n  try {\n    fixOwner.chownr.sync(cache, bucket)\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err\n    }\n  }\n  return formatEntry(cache, entry)\n}\n\nmodule.exports.find = find\nfunction find (cache, key) {\n  const bucket = bucketPath(cache, key)\n  return bucketEntries(bucket).then(entries => {\n    return entries.reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  }).catch(err => {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  })\n}\n\nmodule.exports.find.sync = findSync\nfunction findSync (cache, key) {\n  const bucket = bucketPath(cache, key)\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports.delete = del\nfunction del (cache, key, opts) {\n  return insert(cache, key, null, opts)\n}\n\nmodule.exports.delete.sync = delSync\nfunction delSync (cache, key, opts) {\n  return insertSync(cache, key, null, opts)\n}\n\nmodule.exports.lsStream = lsStream\nfunction lsStream (cache) {\n  const indexDir = bucketDir(cache)\n  const stream = from.obj()\n\n  // \"/cachename/*\"\n  readdirOrEmpty(indexDir).map(bucket => {\n    const bucketPath = path.join(indexDir, bucket)\n\n    // \"/cachename/<bucket 0xFF>/*\"\n    return readdirOrEmpty(bucketPath).map(subbucket => {\n      const subbucketPath = path.join(bucketPath, subbucket)\n\n      // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n      return readdirOrEmpty(subbucketPath).map(entry => {\n        const getKeyToEntry = bucketEntries(\n          path.join(subbucketPath, entry)\n        ).reduce((acc, entry) => {\n          acc.set(entry.key, entry)\n          return acc\n        }, new Map())\n\n        return getKeyToEntry.then(reduced => {\n          for (let entry of reduced.values()) {\n            const formatted = formatEntry(cache, entry)\n            formatted && stream.push(formatted)\n          }\n        }).catch({ code: 'ENOENT' }, nop)\n      })\n    })\n  }).then(() => {\n    stream.push(null)\n  }, err => {\n    stream.emit('error', err)\n  })\n\n  return stream\n}\n\nmodule.exports.ls = ls\nfunction ls (cache) {\n  return BB.fromNode(cb => {\n    lsStream(cache).on('error', cb).pipe(concat(entries => {\n      cb(null, entries.reduce((acc, xs) => {\n        acc[xs.key] = xs\n        return acc\n      }, {}))\n    }))\n  })\n}\n\nfunction bucketEntries (bucket, filter) {\n  return readFileAsync(\n    bucket, 'utf8'\n  ).then(data => _bucketEntries(data, filter))\n}\n\nfunction bucketEntriesSync (bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8')\n  return _bucketEntries(data, filter)\n}\n\nfunction _bucketEntries (data, filter) {\n  let entries = []\n  data.split('\\n').forEach(entry => {\n    if (!entry) { return }\n    const pieces = entry.split('\\t')\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return\n    }\n    let obj\n    try {\n      obj = JSON.parse(pieces[1])\n    } catch (e) {\n      // Entry is corrupted!\n      return\n    }\n    if (obj) {\n      entries.push(obj)\n    }\n  })\n  return entries\n}\n\nmodule.exports._bucketDir = bucketDir\nfunction bucketDir (cache) {\n  return path.join(cache, `index-v${indexV}`)\n}\n\nmodule.exports._bucketPath = bucketPath\nfunction bucketPath (cache, key) {\n  const hashed = hashKey(key)\n  return path.join.apply(path, [bucketDir(cache)].concat(\n    hashToSegments(hashed)\n  ))\n}\n\nmodule.exports._hashKey = hashKey\nfunction hashKey (key) {\n  return hash(key, 'sha256')\n}\n\nmodule.exports._hashEntry = hashEntry\nfunction hashEntry (str) {\n  return hash(str, 'sha1')\n}\n\nfunction hash (str, digest) {\n  return crypto\n    .createHash(digest)\n    .update(str)\n    .digest('hex')\n}\n\nfunction formatEntry (cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) { return null }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  }\n}\n\nfunction readdirOrEmpty (dir) {\n  return readdirAsync(dir)\n    .catch({ code: 'ENOENT' }, () => [])\n    .catch({ code: 'ENOTDIR' }, () => [])\n}\n\nfunction nop () {\n}\n"]},"metadata":{},"sourceType":"script"}