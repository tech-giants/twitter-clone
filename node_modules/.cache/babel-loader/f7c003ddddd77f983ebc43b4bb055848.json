{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\"use strict\";\n\nconst notMatcher = matcher => {\n  return str => {\n    return !matcher(str);\n  };\n};\n\nconst orMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (items[i](str)) return true;\n    }\n\n    return false;\n  };\n};\n\nconst andMatcher = items => {\n  return str => {\n    for (let i = 0; i < items.length; i++) {\n      if (!items[i](str)) return false;\n    }\n\n    return true;\n  };\n};\n\nmodule.exports = class RuleSet {\n  constructor(rules) {\n    this.references = Object.create(null);\n    this.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n  }\n\n  static normalizeRules(rules, refs, ident) {\n    if (Array.isArray(rules)) {\n      return rules.map((rule, idx) => {\n        return RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);\n      });\n    } else if (rules) {\n      return [RuleSet.normalizeRule(rules, refs, ident)];\n    } else {\n      return [];\n    }\n  }\n\n  static normalizeRule(rule, refs, ident) {\n    if (typeof rule === \"string\") {\n      return {\n        use: [{\n          loader: rule\n        }]\n      };\n    }\n\n    if (!rule) {\n      throw new Error(\"Unexcepted null when object was expected as rule\");\n    }\n\n    if (typeof rule !== \"object\") {\n      throw new Error(\"Unexcepted \" + typeof rule + \" when object was expected as rule (\" + rule + \")\");\n    }\n\n    const newRule = {};\n    let useSource;\n    let resourceSource;\n    let condition;\n\n    const checkUseSource = newSource => {\n      if (useSource && useSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one result source (provided \" + newSource + \" and \" + useSource + \")\")));\n      }\n\n      useSource = newSource;\n    };\n\n    const checkResourceSource = newSource => {\n      if (resourceSource && resourceSource !== newSource) {\n        throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Rule can only have one resource source (provided \" + newSource + \" and \" + resourceSource + \")\")));\n      }\n\n      resourceSource = newSource;\n    };\n\n    if (rule.test || rule.include || rule.exclude) {\n      checkResourceSource(\"test + include + exclude\");\n      condition = {\n        test: rule.test,\n        include: rule.include,\n        exclude: rule.exclude\n      };\n\n      try {\n        newRule.resource = RuleSet.normalizeCondition(condition);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(condition, error));\n      }\n    }\n\n    if (rule.resource) {\n      checkResourceSource(\"resource\");\n\n      try {\n        newRule.resource = RuleSet.normalizeCondition(rule.resource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resource, error));\n      }\n    }\n\n    if (rule.realResource) {\n      try {\n        newRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n      }\n    }\n\n    if (rule.resourceQuery) {\n      try {\n        newRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n      }\n    }\n\n    if (rule.compiler) {\n      try {\n        newRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n      }\n    }\n\n    if (rule.issuer) {\n      try {\n        newRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n      } catch (error) {\n        throw new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n      }\n    }\n\n    if (rule.loader && rule.loaders) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"Provided loader and loaders for rule (use only one of them)\")));\n    }\n\n    const loader = rule.loaders || rule.loader;\n\n    if (typeof loader === \"string\" && !rule.options && !rule.query) {\n      checkUseSource(\"loader\");\n      newRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n    } else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n      checkUseSource(\"loader + options/query\");\n      newRule.use = RuleSet.normalizeUse({\n        loader: loader,\n        options: rule.options,\n        query: rule.query\n      }, ident);\n    } else if (loader && (rule.options || rule.query)) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query cannot be used with loaders (use options for each array item)\")));\n    } else if (loader) {\n      checkUseSource(\"loaders\");\n      newRule.use = RuleSet.normalizeUse(loader, ident);\n    } else if (rule.options || rule.query) {\n      throw new Error(RuleSet.buildErrorMessage(rule, new Error(\"options/query provided without loader (use loader + options)\")));\n    }\n\n    if (rule.use) {\n      checkUseSource(\"use\");\n      newRule.use = RuleSet.normalizeUse(rule.use, ident);\n    }\n\n    if (rule.rules) {\n      newRule.rules = RuleSet.normalizeRules(rule.rules, refs, `${ident}-rules`);\n    }\n\n    if (rule.oneOf) {\n      newRule.oneOf = RuleSet.normalizeRules(rule.oneOf, refs, `${ident}-oneOf`);\n    }\n\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"resourceQuery\", \"compiler\", \"test\", \"include\", \"exclude\", \"issuer\", \"loader\", \"options\", \"query\", \"loaders\", \"use\", \"rules\", \"oneOf\"].includes(key);\n    });\n\n    for (const key of keys) {\n      newRule[key] = rule[key];\n    }\n\n    if (Array.isArray(newRule.use)) {\n      for (const item of newRule.use) {\n        if (item.ident) {\n          refs[item.ident] = item.options;\n        }\n      }\n    }\n\n    return newRule;\n  }\n\n  static buildErrorMessage(condition, error) {\n    const conditionAsText = JSON.stringify(condition, (key, value) => {\n      return value === undefined ? \"undefined\" : value;\n    }, 2);\n    return error.message + \" in \" + conditionAsText;\n  }\n\n  static normalizeUse(use, ident) {\n    if (typeof use === \"function\") {\n      return data => RuleSet.normalizeUse(use(data), ident);\n    }\n\n    if (Array.isArray(use)) {\n      return use.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`)).reduce((arr, items) => arr.concat(items), []);\n    }\n\n    return [RuleSet.normalizeUseItem(use, ident)];\n  }\n\n  static normalizeUseItemString(useItemString) {\n    const idx = useItemString.indexOf(\"?\");\n\n    if (idx >= 0) {\n      return {\n        loader: useItemString.substr(0, idx),\n        options: useItemString.substr(idx + 1)\n      };\n    }\n\n    return {\n      loader: useItemString,\n      options: undefined\n    };\n  }\n\n  static normalizeUseItem(item, ident) {\n    if (typeof item === \"string\") {\n      return RuleSet.normalizeUseItemString(item);\n    }\n\n    const newItem = {};\n\n    if (item.options && item.query) {\n      throw new Error(\"Provided options and query in use\");\n    }\n\n    if (!item.loader) {\n      throw new Error(\"No loader specified\");\n    }\n\n    newItem.options = item.options || item.query;\n\n    if (typeof newItem.options === \"object\" && newItem.options) {\n      if (newItem.options.ident) {\n        newItem.ident = newItem.options.ident;\n      } else {\n        newItem.ident = ident;\n      }\n    }\n\n    const keys = Object.keys(item).filter(function (key) {\n      return ![\"options\", \"query\"].includes(key);\n    });\n\n    for (const key of keys) {\n      newItem[key] = item[key];\n    }\n\n    return newItem;\n  }\n\n  static normalizeCondition(condition) {\n    if (!condition) throw new Error(\"Expected condition but got falsy value\");\n\n    if (typeof condition === \"string\") {\n      return str => str.indexOf(condition) === 0;\n    }\n\n    if (typeof condition === \"function\") {\n      return condition;\n    }\n\n    if (condition instanceof RegExp) {\n      return condition.test.bind(condition);\n    }\n\n    if (Array.isArray(condition)) {\n      const items = condition.map(c => RuleSet.normalizeCondition(c));\n      return orMatcher(items);\n    }\n\n    if (typeof condition !== \"object\") {\n      throw Error(\"Unexcepted \" + typeof condition + \" when condition was expected (\" + condition + \")\");\n    }\n\n    const matchers = [];\n    Object.keys(condition).forEach(key => {\n      const value = condition[key];\n\n      switch (key) {\n        case \"or\":\n        case \"include\":\n        case \"test\":\n          if (value) matchers.push(RuleSet.normalizeCondition(value));\n          break;\n\n        case \"and\":\n          if (value) {\n            const items = value.map(c => RuleSet.normalizeCondition(c));\n            matchers.push(andMatcher(items));\n          }\n\n          break;\n\n        case \"not\":\n        case \"exclude\":\n          if (value) {\n            const matcher = RuleSet.normalizeCondition(value);\n            matchers.push(notMatcher(matcher));\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unexcepted property \" + key + \" in condition\");\n      }\n    });\n\n    if (matchers.length === 0) {\n      throw new Error(\"Excepted condition but got \" + condition);\n    }\n\n    if (matchers.length === 1) {\n      return matchers[0];\n    }\n\n    return andMatcher(matchers);\n  }\n\n  exec(data) {\n    const result = [];\n\n    this._run(data, {\n      rules: this.rules\n    }, result);\n\n    return result;\n  }\n\n  _run(data, rule, result) {\n    // test conditions\n    if (rule.resource && !data.resource) return false;\n    if (rule.realResource && !data.realResource) return false;\n    if (rule.resourceQuery && !data.resourceQuery) return false;\n    if (rule.compiler && !data.compiler) return false;\n    if (rule.issuer && !data.issuer) return false;\n    if (rule.resource && !rule.resource(data.resource)) return false;\n    if (rule.realResource && !rule.realResource(data.realResource)) return false;\n    if (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n\n    if (data.resourceQuery && rule.resourceQuery && !rule.resourceQuery(data.resourceQuery)) {\n      return false;\n    }\n\n    if (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n      return false;\n    } // apply\n\n\n    const keys = Object.keys(rule).filter(key => {\n      return ![\"resource\", \"realResource\", \"resourceQuery\", \"compiler\", \"issuer\", \"rules\", \"oneOf\", \"use\", \"enforce\"].includes(key);\n    });\n\n    for (const key of keys) {\n      result.push({\n        type: key,\n        value: rule[key]\n      });\n    }\n\n    if (rule.use) {\n      const process = use => {\n        if (typeof use === \"function\") {\n          process(use(data));\n        } else if (Array.isArray(use)) {\n          use.forEach(process);\n        } else {\n          result.push({\n            type: \"use\",\n            value: use,\n            enforce: rule.enforce\n          });\n        }\n      };\n\n      process(rule.use);\n    }\n\n    if (rule.rules) {\n      for (let i = 0; i < rule.rules.length; i++) {\n        this._run(data, rule.rules[i], result);\n      }\n    }\n\n    if (rule.oneOf) {\n      for (let i = 0; i < rule.oneOf.length; i++) {\n        if (this._run(data, rule.oneOf[i], result)) break;\n      }\n    }\n\n    return true;\n  }\n\n  findOptionsByIdent(ident) {\n    const options = this.references[ident];\n\n    if (!options) {\n      throw new Error(\"Can't find options with ident '\" + ident + \"'\");\n    }\n\n    return options;\n  }\n\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/RuleSet.js"],"names":["notMatcher","matcher","str","orMatcher","items","i","length","andMatcher","module","exports","RuleSet","constructor","rules","references","Object","create","normalizeRules","refs","ident","Array","isArray","map","rule","idx","normalizeRule","use","loader","Error","newRule","useSource","resourceSource","condition","checkUseSource","newSource","buildErrorMessage","checkResourceSource","test","include","exclude","resource","normalizeCondition","error","realResource","resourceQuery","compiler","issuer","loaders","options","query","normalizeUse","split","oneOf","keys","filter","key","includes","item","conditionAsText","JSON","stringify","value","undefined","message","data","reduce","arr","concat","normalizeUseItem","normalizeUseItemString","useItemString","indexOf","substr","newItem","RegExp","bind","c","matchers","forEach","push","exec","result","_run","type","process","enforce","findOptionsByIdent"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n/*\n<rules>: <rule>\n<rules>: [<rule>]\n<rule>: {\n\tresource: {\n\t\ttest: <condition>,\n\t\tinclude: <condition>,\n\t\texclude: <condition>,\n\t},\n\tresource: <condition>, -> resource.test\n\ttest: <condition>, -> resource.test\n\tinclude: <condition>, -> resource.include\n\texclude: <condition>, -> resource.exclude\n\tresourceQuery: <condition>,\n\tcompiler: <condition>,\n\tissuer: <condition>,\n\tuse: \"loader\", -> use[0].loader\n\tloader: <>, -> use[0].loader\n\tloaders: <>, -> use\n\toptions: {}, -> use[0].options,\n\tquery: {}, -> options\n\tparser: {},\n\tuse: [\n\t\t\"loader\" -> use[x].loader\n\t],\n\tuse: [\n\t\t{\n\t\t\tloader: \"loader\",\n\t\t\toptions: {}\n\t\t}\n\t],\n\trules: [\n\t\t<rule>\n\t],\n\toneOf: [\n\t\t<rule>\n\t]\n}\n\n<condition>: /regExp/\n<condition>: function(arg) {}\n<condition>: \"starting\"\n<condition>: [<condition>] // or\n<condition>: { and: [<condition>] }\n<condition>: { or: [<condition>] }\n<condition>: { not: [<condition>] }\n<condition>: { test: <condition>, include: <condition>, exclude: <condition> }\n\n\nnormalized:\n\n{\n\tresource: function(),\n\tresourceQuery: function(),\n\tcompiler: function(),\n\tissuer: function(),\n\tuse: [\n\t\t{\n\t\t\tloader: string,\n\t\t\toptions: string,\n\t\t\t<any>: <any>\n\t\t}\n\t],\n\trules: [<rule>],\n\toneOf: [<rule>],\n\t<any>: <any>,\n}\n\n*/\n\n\"use strict\";\n\nconst notMatcher = matcher => {\n\treturn str => {\n\t\treturn !matcher(str);\n\t};\n};\n\nconst orMatcher = items => {\n\treturn str => {\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tif (items[i](str)) return true;\n\t\t}\n\t\treturn false;\n\t};\n};\n\nconst andMatcher = items => {\n\treturn str => {\n\t\tfor (let i = 0; i < items.length; i++) {\n\t\t\tif (!items[i](str)) return false;\n\t\t}\n\t\treturn true;\n\t};\n};\n\nmodule.exports = class RuleSet {\n\tconstructor(rules) {\n\t\tthis.references = Object.create(null);\n\t\tthis.rules = RuleSet.normalizeRules(rules, this.references, \"ref-\");\n\t}\n\n\tstatic normalizeRules(rules, refs, ident) {\n\t\tif (Array.isArray(rules)) {\n\t\t\treturn rules.map((rule, idx) => {\n\t\t\t\treturn RuleSet.normalizeRule(rule, refs, `${ident}-${idx}`);\n\t\t\t});\n\t\t} else if (rules) {\n\t\t\treturn [RuleSet.normalizeRule(rules, refs, ident)];\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tstatic normalizeRule(rule, refs, ident) {\n\t\tif (typeof rule === \"string\") {\n\t\t\treturn {\n\t\t\t\tuse: [\n\t\t\t\t\t{\n\t\t\t\t\t\tloader: rule\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t};\n\t\t}\n\t\tif (!rule) {\n\t\t\tthrow new Error(\"Unexcepted null when object was expected as rule\");\n\t\t}\n\t\tif (typeof rule !== \"object\") {\n\t\t\tthrow new Error(\n\t\t\t\t\"Unexcepted \" +\n\t\t\t\t\ttypeof rule +\n\t\t\t\t\t\" when object was expected as rule (\" +\n\t\t\t\t\trule +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t}\n\n\t\tconst newRule = {};\n\t\tlet useSource;\n\t\tlet resourceSource;\n\t\tlet condition;\n\n\t\tconst checkUseSource = newSource => {\n\t\t\tif (useSource && useSource !== newSource) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"Rule can only have one result source (provided \" +\n\t\t\t\t\t\t\t\tnewSource +\n\t\t\t\t\t\t\t\t\" and \" +\n\t\t\t\t\t\t\t\tuseSource +\n\t\t\t\t\t\t\t\t\")\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tuseSource = newSource;\n\t\t};\n\n\t\tconst checkResourceSource = newSource => {\n\t\t\tif (resourceSource && resourceSource !== newSource) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\t\trule,\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\"Rule can only have one resource source (provided \" +\n\t\t\t\t\t\t\t\tnewSource +\n\t\t\t\t\t\t\t\t\" and \" +\n\t\t\t\t\t\t\t\tresourceSource +\n\t\t\t\t\t\t\t\t\")\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t}\n\t\t\tresourceSource = newSource;\n\t\t};\n\n\t\tif (rule.test || rule.include || rule.exclude) {\n\t\t\tcheckResourceSource(\"test + include + exclude\");\n\t\t\tcondition = {\n\t\t\t\ttest: rule.test,\n\t\t\t\tinclude: rule.include,\n\t\t\t\texclude: rule.exclude\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tnewRule.resource = RuleSet.normalizeCondition(condition);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(condition, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.resource) {\n\t\t\tcheckResourceSource(\"resource\");\n\t\t\ttry {\n\t\t\t\tnewRule.resource = RuleSet.normalizeCondition(rule.resource);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.resource, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.realResource) {\n\t\t\ttry {\n\t\t\t\tnewRule.realResource = RuleSet.normalizeCondition(rule.realResource);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.realResource, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.resourceQuery) {\n\t\t\ttry {\n\t\t\t\tnewRule.resourceQuery = RuleSet.normalizeCondition(rule.resourceQuery);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.resourceQuery, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.compiler) {\n\t\t\ttry {\n\t\t\t\tnewRule.compiler = RuleSet.normalizeCondition(rule.compiler);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.compiler, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.issuer) {\n\t\t\ttry {\n\t\t\t\tnewRule.issuer = RuleSet.normalizeCondition(rule.issuer);\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error(RuleSet.buildErrorMessage(rule.issuer, error));\n\t\t\t}\n\t\t}\n\n\t\tif (rule.loader && rule.loaders) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"Provided loader and loaders for rule (use only one of them)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tconst loader = rule.loaders || rule.loader;\n\t\tif (typeof loader === \"string\" && !rule.options && !rule.query) {\n\t\t\tcheckUseSource(\"loader\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(loader.split(\"!\"), ident);\n\t\t} else if (typeof loader === \"string\" && (rule.options || rule.query)) {\n\t\t\tcheckUseSource(\"loader + options/query\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(\n\t\t\t\t{\n\t\t\t\t\tloader: loader,\n\t\t\t\t\toptions: rule.options,\n\t\t\t\t\tquery: rule.query\n\t\t\t\t},\n\t\t\t\tident\n\t\t\t);\n\t\t} else if (loader && (rule.options || rule.query)) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"options/query cannot be used with loaders (use options for each array item)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t} else if (loader) {\n\t\t\tcheckUseSource(\"loaders\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(loader, ident);\n\t\t} else if (rule.options || rule.query) {\n\t\t\tthrow new Error(\n\t\t\t\tRuleSet.buildErrorMessage(\n\t\t\t\t\trule,\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\"options/query provided without loader (use loader + options)\"\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\tif (rule.use) {\n\t\t\tcheckUseSource(\"use\");\n\t\t\tnewRule.use = RuleSet.normalizeUse(rule.use, ident);\n\t\t}\n\n\t\tif (rule.rules) {\n\t\t\tnewRule.rules = RuleSet.normalizeRules(\n\t\t\t\trule.rules,\n\t\t\t\trefs,\n\t\t\t\t`${ident}-rules`\n\t\t\t);\n\t\t}\n\n\t\tif (rule.oneOf) {\n\t\t\tnewRule.oneOf = RuleSet.normalizeRules(\n\t\t\t\trule.oneOf,\n\t\t\t\trefs,\n\t\t\t\t`${ident}-oneOf`\n\t\t\t);\n\t\t}\n\n\t\tconst keys = Object.keys(rule).filter(key => {\n\t\t\treturn ![\n\t\t\t\t\"resource\",\n\t\t\t\t\"resourceQuery\",\n\t\t\t\t\"compiler\",\n\t\t\t\t\"test\",\n\t\t\t\t\"include\",\n\t\t\t\t\"exclude\",\n\t\t\t\t\"issuer\",\n\t\t\t\t\"loader\",\n\t\t\t\t\"options\",\n\t\t\t\t\"query\",\n\t\t\t\t\"loaders\",\n\t\t\t\t\"use\",\n\t\t\t\t\"rules\",\n\t\t\t\t\"oneOf\"\n\t\t\t].includes(key);\n\t\t});\n\t\tfor (const key of keys) {\n\t\t\tnewRule[key] = rule[key];\n\t\t}\n\n\t\tif (Array.isArray(newRule.use)) {\n\t\t\tfor (const item of newRule.use) {\n\t\t\t\tif (item.ident) {\n\t\t\t\t\trefs[item.ident] = item.options;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newRule;\n\t}\n\n\tstatic buildErrorMessage(condition, error) {\n\t\tconst conditionAsText = JSON.stringify(\n\t\t\tcondition,\n\t\t\t(key, value) => {\n\t\t\t\treturn value === undefined ? \"undefined\" : value;\n\t\t\t},\n\t\t\t2\n\t\t);\n\t\treturn error.message + \" in \" + conditionAsText;\n\t}\n\n\tstatic normalizeUse(use, ident) {\n\t\tif (typeof use === \"function\") {\n\t\t\treturn data => RuleSet.normalizeUse(use(data), ident);\n\t\t}\n\t\tif (Array.isArray(use)) {\n\t\t\treturn use\n\t\t\t\t.map((item, idx) => RuleSet.normalizeUse(item, `${ident}-${idx}`))\n\t\t\t\t.reduce((arr, items) => arr.concat(items), []);\n\t\t}\n\t\treturn [RuleSet.normalizeUseItem(use, ident)];\n\t}\n\n\tstatic normalizeUseItemString(useItemString) {\n\t\tconst idx = useItemString.indexOf(\"?\");\n\t\tif (idx >= 0) {\n\t\t\treturn {\n\t\t\t\tloader: useItemString.substr(0, idx),\n\t\t\t\toptions: useItemString.substr(idx + 1)\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tloader: useItemString,\n\t\t\toptions: undefined\n\t\t};\n\t}\n\n\tstatic normalizeUseItem(item, ident) {\n\t\tif (typeof item === \"string\") {\n\t\t\treturn RuleSet.normalizeUseItemString(item);\n\t\t}\n\n\t\tconst newItem = {};\n\n\t\tif (item.options && item.query) {\n\t\t\tthrow new Error(\"Provided options and query in use\");\n\t\t}\n\n\t\tif (!item.loader) {\n\t\t\tthrow new Error(\"No loader specified\");\n\t\t}\n\n\t\tnewItem.options = item.options || item.query;\n\n\t\tif (typeof newItem.options === \"object\" && newItem.options) {\n\t\t\tif (newItem.options.ident) {\n\t\t\t\tnewItem.ident = newItem.options.ident;\n\t\t\t} else {\n\t\t\t\tnewItem.ident = ident;\n\t\t\t}\n\t\t}\n\n\t\tconst keys = Object.keys(item).filter(function(key) {\n\t\t\treturn ![\"options\", \"query\"].includes(key);\n\t\t});\n\n\t\tfor (const key of keys) {\n\t\t\tnewItem[key] = item[key];\n\t\t}\n\n\t\treturn newItem;\n\t}\n\n\tstatic normalizeCondition(condition) {\n\t\tif (!condition) throw new Error(\"Expected condition but got falsy value\");\n\t\tif (typeof condition === \"string\") {\n\t\t\treturn str => str.indexOf(condition) === 0;\n\t\t}\n\t\tif (typeof condition === \"function\") {\n\t\t\treturn condition;\n\t\t}\n\t\tif (condition instanceof RegExp) {\n\t\t\treturn condition.test.bind(condition);\n\t\t}\n\t\tif (Array.isArray(condition)) {\n\t\t\tconst items = condition.map(c => RuleSet.normalizeCondition(c));\n\t\t\treturn orMatcher(items);\n\t\t}\n\t\tif (typeof condition !== \"object\") {\n\t\t\tthrow Error(\n\t\t\t\t\"Unexcepted \" +\n\t\t\t\t\ttypeof condition +\n\t\t\t\t\t\" when condition was expected (\" +\n\t\t\t\t\tcondition +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t}\n\n\t\tconst matchers = [];\n\t\tObject.keys(condition).forEach(key => {\n\t\t\tconst value = condition[key];\n\t\t\tswitch (key) {\n\t\t\t\tcase \"or\":\n\t\t\t\tcase \"include\":\n\t\t\t\tcase \"test\":\n\t\t\t\t\tif (value) matchers.push(RuleSet.normalizeCondition(value));\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"and\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst items = value.map(c => RuleSet.normalizeCondition(c));\n\t\t\t\t\t\tmatchers.push(andMatcher(items));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"not\":\n\t\t\t\tcase \"exclude\":\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tconst matcher = RuleSet.normalizeCondition(value);\n\t\t\t\t\t\tmatchers.push(notMatcher(matcher));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unexcepted property \" + key + \" in condition\");\n\t\t\t}\n\t\t});\n\t\tif (matchers.length === 0) {\n\t\t\tthrow new Error(\"Excepted condition but got \" + condition);\n\t\t}\n\t\tif (matchers.length === 1) {\n\t\t\treturn matchers[0];\n\t\t}\n\t\treturn andMatcher(matchers);\n\t}\n\n\texec(data) {\n\t\tconst result = [];\n\t\tthis._run(\n\t\t\tdata,\n\t\t\t{\n\t\t\t\trules: this.rules\n\t\t\t},\n\t\t\tresult\n\t\t);\n\t\treturn result;\n\t}\n\n\t_run(data, rule, result) {\n\t\t// test conditions\n\t\tif (rule.resource && !data.resource) return false;\n\t\tif (rule.realResource && !data.realResource) return false;\n\t\tif (rule.resourceQuery && !data.resourceQuery) return false;\n\t\tif (rule.compiler && !data.compiler) return false;\n\t\tif (rule.issuer && !data.issuer) return false;\n\t\tif (rule.resource && !rule.resource(data.resource)) return false;\n\t\tif (rule.realResource && !rule.realResource(data.realResource))\n\t\t\treturn false;\n\t\tif (data.issuer && rule.issuer && !rule.issuer(data.issuer)) return false;\n\t\tif (\n\t\t\tdata.resourceQuery &&\n\t\t\trule.resourceQuery &&\n\t\t\t!rule.resourceQuery(data.resourceQuery)\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tif (data.compiler && rule.compiler && !rule.compiler(data.compiler)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// apply\n\t\tconst keys = Object.keys(rule).filter(key => {\n\t\t\treturn ![\n\t\t\t\t\"resource\",\n\t\t\t\t\"realResource\",\n\t\t\t\t\"resourceQuery\",\n\t\t\t\t\"compiler\",\n\t\t\t\t\"issuer\",\n\t\t\t\t\"rules\",\n\t\t\t\t\"oneOf\",\n\t\t\t\t\"use\",\n\t\t\t\t\"enforce\"\n\t\t\t].includes(key);\n\t\t});\n\t\tfor (const key of keys) {\n\t\t\tresult.push({\n\t\t\t\ttype: key,\n\t\t\t\tvalue: rule[key]\n\t\t\t});\n\t\t}\n\n\t\tif (rule.use) {\n\t\t\tconst process = use => {\n\t\t\t\tif (typeof use === \"function\") {\n\t\t\t\t\tprocess(use(data));\n\t\t\t\t} else if (Array.isArray(use)) {\n\t\t\t\t\tuse.forEach(process);\n\t\t\t\t} else {\n\t\t\t\t\tresult.push({\n\t\t\t\t\t\ttype: \"use\",\n\t\t\t\t\t\tvalue: use,\n\t\t\t\t\t\tenforce: rule.enforce\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t\tprocess(rule.use);\n\t\t}\n\n\t\tif (rule.rules) {\n\t\t\tfor (let i = 0; i < rule.rules.length; i++) {\n\t\t\t\tthis._run(data, rule.rules[i], result);\n\t\t\t}\n\t\t}\n\n\t\tif (rule.oneOf) {\n\t\t\tfor (let i = 0; i < rule.oneOf.length; i++) {\n\t\t\t\tif (this._run(data, rule.oneOf[i], result)) break;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tfindOptionsByIdent(ident) {\n\t\tconst options = this.references[ident];\n\t\tif (!options) {\n\t\t\tthrow new Error(\"Can't find options with ident '\" + ident + \"'\");\n\t\t}\n\t\treturn options;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}