{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  Tapable,\n  SyncHook,\n  MultiHook\n} = require(\"tapable\");\n\nconst asyncLib = require(\"neo-async\");\n\nconst MultiWatching = require(\"./MultiWatching\");\n\nconst MultiStats = require(\"./MultiStats\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nmodule.exports = class MultiCompiler extends Tapable {\n  constructor(compilers) {\n    super();\n    this.hooks = {\n      done: new SyncHook([\"stats\"]),\n      invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n      run: new MultiHook(compilers.map(c => c.hooks.run)),\n      watchClose: new SyncHook([]),\n      watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n      infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))\n    };\n\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(name => {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    this.compilers = compilers;\n    let doneCompilers = 0;\n    let compilerStats = [];\n    let index = 0;\n\n    for (const compiler of this.compilers) {\n      let compilerDone = false;\n      const compilerIndex = index++; // eslint-disable-next-line no-loop-func\n\n      compiler.hooks.done.tap(\"MultiCompiler\", stats => {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n\n        compilerStats[compilerIndex] = stats;\n\n        if (doneCompilers === this.compilers.length) {\n          this.hooks.done.call(new MultiStats(compilerStats));\n        }\n      }); // eslint-disable-next-line no-loop-func\n\n      compiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    }\n\n    this.running = false;\n  }\n\n  get outputPath() {\n    let commonPath = this.compilers[0].outputPath;\n\n    for (const compiler of this.compilers) {\n      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n        commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n      }\n    }\n\n    if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n    return commonPath;\n  }\n\n  get inputFileSystem() {\n    throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n  }\n\n  get outputFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  set inputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.inputFileSystem = value;\n    }\n  }\n\n  set outputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.outputFileSystem = value;\n    }\n  }\n\n  getInfrastructureLogger(name) {\n    return this.compilers[0].getInfrastructureLogger(name);\n  }\n\n  validateDependencies(callback) {\n    const edges = new Set();\n    const missing = [];\n\n    const targetFound = compiler => {\n      for (const edge of edges) {\n        if (edge.target === compiler) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const sortEdges = (e1, e2) => {\n      return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n    };\n\n    for (const source of this.compilers) {\n      if (source.dependencies) {\n        for (const dep of source.dependencies) {\n          const target = this.compilers.find(c => c.name === dep);\n\n          if (!target) {\n            missing.push(dep);\n          } else {\n            edges.add({\n              source,\n              target\n            });\n          }\n        }\n      }\n    }\n\n    const errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n    const stack = this.compilers.filter(c => !targetFound(c));\n\n    while (stack.length > 0) {\n      const current = stack.pop();\n\n      for (const edge of edges) {\n        if (edge.source === current) {\n          edges.delete(edge);\n          const target = edge.target;\n\n          if (!targetFound(target)) {\n            stack.push(target);\n          }\n        }\n      }\n    }\n\n    if (edges.size > 0) {\n      const lines = Array.from(edges).sort(sortEdges).map(edge => `${edge.source.name} -> ${edge.target.name}`);\n      lines.unshift(\"Circular dependency found in compiler dependencies.\");\n      errors.unshift(lines.join(\"\\n\"));\n    }\n\n    if (errors.length > 0) {\n      const message = errors.join(\"\\n\");\n      callback(new Error(message));\n      return false;\n    }\n\n    return true;\n  }\n\n  runWithDependencies(compilers, fn, callback) {\n    const fulfilledNames = new Set();\n    let remainingCompilers = compilers;\n\n    const isDependencyFulfilled = d => fulfilledNames.has(d);\n\n    const getReadyCompilers = () => {\n      let readyCompilers = [];\n      let list = remainingCompilers;\n      remainingCompilers = [];\n\n      for (const c of list) {\n        const ready = !c.dependencies || c.dependencies.every(isDependencyFulfilled);\n\n        if (ready) {\n          readyCompilers.push(c);\n        } else {\n          remainingCompilers.push(c);\n        }\n      }\n\n      return readyCompilers;\n    };\n\n    const runCompilers = callback => {\n      if (remainingCompilers.length === 0) return callback();\n      asyncLib.map(getReadyCompilers(), (compiler, callback) => {\n        fn(compiler, err => {\n          if (err) return callback(err);\n          fulfilledNames.add(compiler.name);\n          runCompilers(callback);\n        });\n      }, callback);\n    };\n\n    runCompilers(callback);\n  }\n\n  watch(watchOptions, handler) {\n    if (this.running) return handler(new ConcurrentCompilationError());\n    let watchings = [];\n    let allStats = this.compilers.map(() => null);\n    let compilerStatus = this.compilers.map(() => false);\n\n    if (this.validateDependencies(handler)) {\n      this.running = true;\n      this.runWithDependencies(this.compilers, (compiler, callback) => {\n        const compilerIdx = this.compilers.indexOf(compiler);\n        let firstRun = true;\n        let watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, (err, stats) => {\n          if (err) handler(err);\n\n          if (stats) {\n            allStats[compilerIdx] = stats;\n            compilerStatus[compilerIdx] = \"new\";\n\n            if (compilerStatus.every(Boolean)) {\n              const freshStats = allStats.filter((s, idx) => {\n                return compilerStatus[idx] === \"new\";\n              });\n              compilerStatus.fill(true);\n              const multiStats = new MultiStats(freshStats);\n              handler(null, multiStats);\n            }\n          }\n\n          if (firstRun && !err) {\n            firstRun = false;\n            callback();\n          }\n        });\n        watchings.push(watching);\n      }, () => {// ignore\n      });\n    }\n\n    return new MultiWatching(watchings, this);\n  }\n\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n\n    const finalCallback = (err, stats) => {\n      this.running = false;\n\n      if (callback !== undefined) {\n        return callback(err, stats);\n      }\n    };\n\n    const allStats = this.compilers.map(() => null);\n\n    if (this.validateDependencies(callback)) {\n      this.running = true;\n      this.runWithDependencies(this.compilers, (compiler, callback) => {\n        const compilerIdx = this.compilers.indexOf(compiler);\n        compiler.run((err, stats) => {\n          if (err) {\n            return callback(err);\n          }\n\n          allStats[compilerIdx] = stats;\n          callback();\n        });\n      }, err => {\n        if (err) {\n          return finalCallback(err);\n        }\n\n        finalCallback(null, new MultiStats(allStats));\n      });\n    }\n  }\n\n  purgeInputFileSystem() {\n    for (const compiler of this.compilers) {\n      if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n        compiler.inputFileSystem.purge();\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/MultiCompiler.js"],"names":["Tapable","SyncHook","MultiHook","require","asyncLib","MultiWatching","MultiStats","ConcurrentCompilationError","module","exports","MultiCompiler","constructor","compilers","hooks","done","invalid","map","c","run","watchClose","watchRun","infrastructureLog","Array","isArray","Object","keys","name","doneCompilers","compilerStats","index","compiler","compilerDone","compilerIndex","tap","stats","length","call","running","outputPath","commonPath","indexOf","test","replace","inputFileSystem","Error","outputFileSystem","value","getInfrastructureLogger","validateDependencies","callback","edges","Set","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","dependencies","dep","find","push","add","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","runWithDependencies","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","has","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","watch","watchOptions","handler","watchings","allStats","compilerStatus","compilerIdx","firstRun","watching","Boolean","freshStats","s","idx","fill","multiStats","finalCallback","undefined","purgeInputFileSystem","purge"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { Tapable, SyncHook, MultiHook } = require(\"tapable\");\nconst asyncLib = require(\"neo-async\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst MultiStats = require(\"./MultiStats\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nmodule.exports = class MultiCompiler extends Tapable {\n\tconstructor(compilers) {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\twatchClose: new SyncHook([]),\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t};\n\t\tif (!Array.isArray(compilers)) {\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\tcompilers[name].name = name;\n\t\t\t\treturn compilers[name];\n\t\t\t});\n\t\t}\n\t\tthis.compilers = compilers;\n\t\tlet doneCompilers = 0;\n\t\tlet compilerStats = [];\n\t\tlet index = 0;\n\t\tfor (const compiler of this.compilers) {\n\t\t\tlet compilerDone = false;\n\t\t\tconst compilerIndex = index++;\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(new MultiStats(compilerStats));\n\t\t\t\t}\n\t\t\t});\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.running = false;\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\tvalidateDependencies(callback) {\n\t\tconst edges = new Set();\n\t\tconst missing = [];\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\tconst sortEdges = (e1, e2) => {\n\t\t\treturn (\n\t\t\t\te1.source.name.localeCompare(e2.source.name) ||\n\t\t\t\te1.target.name.localeCompare(e2.target.name)\n\t\t\t);\n\t\t};\n\t\tfor (const source of this.compilers) {\n\t\t\tif (source.dependencies) {\n\t\t\t\tfor (const dep of source.dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\tconst getReadyCompilers = () => {\n\t\t\tlet readyCompilers = [];\n\t\t\tlet list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst ready =\n\t\t\t\t\t!c.dependencies || c.dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback();\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\twatch(watchOptions, handler) {\n\t\tif (this.running) return handler(new ConcurrentCompilationError());\n\n\t\tlet watchings = [];\n\t\tlet allStats = this.compilers.map(() => null);\n\t\tlet compilerStatus = this.compilers.map(() => false);\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tthis.running = true;\n\t\t\tthis.runWithDependencies(\n\t\t\t\tthis.compilers,\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tconst compilerIdx = this.compilers.indexOf(compiler);\n\t\t\t\t\tlet firstRun = true;\n\t\t\t\t\tlet watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions)\n\t\t\t\t\t\t\t? watchOptions[compilerIdx]\n\t\t\t\t\t\t\t: watchOptions,\n\t\t\t\t\t\t(err, stats) => {\n\t\t\t\t\t\t\tif (err) handler(err);\n\t\t\t\t\t\t\tif (stats) {\n\t\t\t\t\t\t\t\tallStats[compilerIdx] = stats;\n\t\t\t\t\t\t\t\tcompilerStatus[compilerIdx] = \"new\";\n\t\t\t\t\t\t\t\tif (compilerStatus.every(Boolean)) {\n\t\t\t\t\t\t\t\t\tconst freshStats = allStats.filter((s, idx) => {\n\t\t\t\t\t\t\t\t\t\treturn compilerStatus[idx] === \"new\";\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tcompilerStatus.fill(true);\n\t\t\t\t\t\t\t\t\tconst multiStats = new MultiStats(freshStats);\n\t\t\t\t\t\t\t\t\thandler(null, multiStats);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (firstRun && !err) {\n\t\t\t\t\t\t\t\tfirstRun = false;\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\twatchings.push(watching);\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\treturn new MultiWatching(watchings, this);\n\t}\n\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\n\t\tconst finalCallback = (err, stats) => {\n\t\t\tthis.running = false;\n\n\t\t\tif (callback !== undefined) {\n\t\t\t\treturn callback(err, stats);\n\t\t\t}\n\t\t};\n\n\t\tconst allStats = this.compilers.map(() => null);\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis.running = true;\n\t\t\tthis.runWithDependencies(\n\t\t\t\tthis.compilers,\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tconst compilerIdx = this.compilers.indexOf(compiler);\n\t\t\t\t\tcompiler.run((err, stats) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tallStats[compilerIdx] = stats;\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn finalCallback(err);\n\t\t\t\t\t}\n\t\t\t\t\tfinalCallback(null, new MultiStats(allStats));\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}