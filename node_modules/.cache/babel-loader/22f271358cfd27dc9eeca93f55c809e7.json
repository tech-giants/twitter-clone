{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\n\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nconst ParserHelpers = require(\"./ParserHelpers\");\n\nconst NullFactory = require(\"./NullFactory\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Parser\")} Parser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\n\nclass RuntimeValue {\n  constructor(fn, fileDependencies) {\n    this.fn = fn;\n    this.fileDependencies = fileDependencies || [];\n  }\n\n  exec(parser) {\n    if (this.fileDependencies === true) {\n      parser.state.module.buildInfo.cacheable = false;\n    } else {\n      for (const fileDependency of this.fileDependencies) {\n        parser.state.module.buildInfo.fileDependencies.add(fileDependency);\n      }\n    }\n\n    return this.fn({\n      module: parser.state.module\n    });\n  }\n\n}\n\nconst stringifyObj = (obj, parser) => {\n  return \"Object({\" + Object.keys(obj).map(key => {\n    const code = obj[key];\n    return JSON.stringify(key) + \":\" + toCode(code, parser);\n  }).join(\",\") + \"})\";\n};\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\n\n\nconst toCode = (code, parser) => {\n  if (code === null) {\n    return \"null\";\n  }\n\n  if (code === undefined) {\n    return \"undefined\";\n  }\n\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser), parser);\n  }\n\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser);\n  }\n\n  return code + \"\";\n};\n\nclass DefinePlugin {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  constructor(definitions) {\n    this.definitions = definitions;\n  }\n\n  static runtimeValue(fn, fileDependencies) {\n    return new RuntimeValue(fn, fileDependencies);\n  }\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler Webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const definitions = this.definitions;\n    compiler.hooks.compilation.tap(\"DefinePlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      /**\n       * Handler\n       * @param {Parser} parser Parser\n       * @returns {void}\n       */\n\n      const handler = parser => {\n        /**\n         * Walk definitions\n         * @param {Object} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n        const walkDefinitions = (definitions, prefix) => {\n          Object.keys(definitions).forEach(key => {\n            const code = definitions[key];\n\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitions(code, prefix + key + \".\");\n              applyObjectDefine(prefix + key, code);\n              return;\n            }\n\n            applyDefineKey(prefix, key);\n            applyDefine(prefix + key, code);\n          });\n        };\n        /**\n         * Apply define key\n         * @param {string} prefix Prefix\n         * @param {string} key Key\n         * @returns {void}\n         */\n\n\n        const applyDefineKey = (prefix, key) => {\n          const splittedKey = key.split(\".\");\n          splittedKey.slice(1).forEach((_, i) => {\n            const fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n            parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", ParserHelpers.approve);\n          });\n        };\n        /**\n         * Apply Code\n         * @param {string} key Key\n         * @param {CodeValue} code Code\n         * @returns {void}\n         */\n\n\n        const applyDefine = (key, code) => {\n          const isTypeof = /^typeof\\s+/.test(key);\n          if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n          let recurse = false;\n          let recurseTypeof = false;\n\n          if (!isTypeof) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"a\": \"b\",\n               * \"b\": \"a\"\n               * });\n               */\n              if (recurse) return;\n              recurse = true;\n              const res = parser.evaluate(toCode(code, parser));\n              recurse = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n              const strCode = toCode(code, parser);\n\n              if (/__webpack_require__/.test(strCode)) {\n                return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n              } else {\n                return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n              }\n            });\n          }\n\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            /**\n             * this is needed in case there is a recursion in the DefinePlugin\n             * to prevent an endless recursion\n             * e.g.: new DefinePlugin({\n             * \"typeof a\": \"typeof b\",\n             * \"typeof b\": \"typeof a\"\n             * });\n             */\n            if (recurseTypeof) return;\n            recurseTypeof = true;\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            recurseTypeof = false;\n            res.setRange(expr.range);\n            return res;\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            const typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n            const res = parser.evaluate(typeofCode);\n            if (!res.isString()) return;\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n          });\n        };\n        /**\n         * Apply Object\n         * @param {string} key Key\n         * @param {Object} obj Object\n         * @returns {void}\n         */\n\n\n        const applyObjectDefine = (key, obj) => {\n          parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n          parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", expr => new BasicEvaluatedExpression().setTruthy().setRange(expr.range));\n          parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.evaluateToString(\"object\")(expr);\n          });\n          parser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n            const strCode = stringifyObj(obj, parser);\n\n            if (/__webpack_require__/.test(strCode)) {\n              return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n            } else {\n              return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n            }\n          });\n          parser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n            return ParserHelpers.toConstantDependency(parser, JSON.stringify(\"object\"))(expr);\n          });\n        };\n\n        walkDefinitions(definitions, \"\");\n      };\n\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n    });\n  }\n\n}\n\nmodule.exports = DefinePlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/DefinePlugin.js"],"names":["ConstDependency","require","BasicEvaluatedExpression","ParserHelpers","NullFactory","RuntimeValue","constructor","fn","fileDependencies","exec","parser","state","module","buildInfo","cacheable","fileDependency","add","stringifyObj","obj","Object","keys","map","key","code","JSON","stringify","toCode","join","undefined","RegExp","toString","DefinePlugin","definitions","runtimeValue","apply","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","handler","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","approve","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","strCode","toConstantDependencyWithWebpackRequire","toConstantDependency","evaluateTypeof","typeofCode","typeof","isString","string","bind","setTruthy","evaluateToString","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst NullFactory = require(\"./NullFactory\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Parser\")} Parser */\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\nclass RuntimeValue {\n\tconstructor(fn, fileDependencies) {\n\t\tthis.fn = fn;\n\t\tthis.fileDependencies = fileDependencies || [];\n\t}\n\n\texec(parser) {\n\t\tif (this.fileDependencies === true) {\n\t\t\tparser.state.module.buildInfo.cacheable = false;\n\t\t} else {\n\t\t\tfor (const fileDependency of this.fileDependencies) {\n\t\t\t\tparser.state.module.buildInfo.fileDependencies.add(fileDependency);\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({ module: parser.state.module });\n\t}\n}\n\nconst stringifyObj = (obj, parser) => {\n\treturn (\n\t\t\"Object({\" +\n\t\tObject.keys(obj)\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn JSON.stringify(key) + \":\" + toCode(code, parser);\n\t\t\t})\n\t\t\t.join(\",\") +\n\t\t\"})\"\n\t);\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser) => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn toCode(code.exec(parser), parser);\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\treturn stringifyObj(code, parser);\n\t}\n\treturn code + \"\";\n};\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\tstatic runtimeValue(fn, fileDependencies) {\n\t\treturn new RuntimeValue(fn, fileDependencies);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler Webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DefinePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(ConstDependency, new NullFactory());\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {Parser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(fullKey)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst isTypeof = /^typeof\\s+/.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(toCode(code, parser));\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\tconst strCode = toCode(code, parser);\n\t\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr =>\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression().setTruthy().setRange(expr.range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\"object\")(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst strCode = stringifyObj(obj, parser);\n\n\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(\"object\")\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"]},"metadata":{},"sourceType":"script"}