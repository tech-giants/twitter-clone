{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Naoyuki Kanezawa @nkzawa\n*/\n\"use strict\";\n\nconst MultiEntryDependency = require(\"./dependencies/MultiEntryDependency\");\n\nconst SingleEntryDependency = require(\"./dependencies/SingleEntryDependency\");\n\nconst MultiModuleFactory = require(\"./MultiModuleFactory\");\n\nconst MultiEntryPlugin = require(\"./MultiEntryPlugin\");\n\nconst SingleEntryPlugin = require(\"./SingleEntryPlugin\");\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryDynamic} EntryDynamic */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryStatic} EntryStatic */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n\nclass DynamicEntryPlugin {\n  /**\n   * @param {string} context the context path\n   * @param {EntryDynamic} entry the entry value\n   */\n  constructor(context, entry) {\n    this.context = context;\n    this.entry = entry;\n  }\n  /**\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"DynamicEntryPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      const multiModuleFactory = new MultiModuleFactory();\n      compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);\n      compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);\n    });\n    compiler.hooks.make.tapAsync(\"DynamicEntryPlugin\", (compilation, callback) => {\n      /**\n       * @param {string|string[]} entry entry value or array of entry values\n       * @param {string} name name of entry\n       * @returns {Promise<EntryStatic>} returns the promise resolving the Compilation#addEntry function\n       */\n      const addEntry = (entry, name) => {\n        const dep = DynamicEntryPlugin.createDependency(entry, name);\n        return new Promise((resolve, reject) => {\n          compilation.addEntry(this.context, dep, name, err => {\n            if (err) return reject(err);\n            resolve();\n          });\n        });\n      };\n\n      Promise.resolve(this.entry()).then(entry => {\n        if (typeof entry === \"string\" || Array.isArray(entry)) {\n          addEntry(entry, \"main\").then(() => callback(), callback);\n        } else if (typeof entry === \"object\") {\n          Promise.all(Object.keys(entry).map(name => {\n            return addEntry(entry[name], name);\n          })).then(() => callback(), callback);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = DynamicEntryPlugin;\n/**\n * @param {string|string[]} entry entry value or array of entry paths\n * @param {string} name name of entry\n * @returns {SingleEntryDependency|MultiEntryDependency} returns dep\n */\n\nDynamicEntryPlugin.createDependency = (entry, name) => {\n  if (Array.isArray(entry)) {\n    return MultiEntryPlugin.createDependency(entry, name);\n  } else {\n    return SingleEntryPlugin.createDependency(entry, name);\n  }\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/DynamicEntryPlugin.js"],"names":["MultiEntryDependency","require","SingleEntryDependency","MultiModuleFactory","MultiEntryPlugin","SingleEntryPlugin","DynamicEntryPlugin","constructor","context","entry","apply","compiler","hooks","compilation","tap","normalModuleFactory","multiModuleFactory","dependencyFactories","set","make","tapAsync","callback","addEntry","name","dep","createDependency","Promise","resolve","reject","err","then","Array","isArray","all","Object","keys","map","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Naoyuki Kanezawa @nkzawa\n*/\n\"use strict\";\n\nconst MultiEntryDependency = require(\"./dependencies/MultiEntryDependency\");\nconst SingleEntryDependency = require(\"./dependencies/SingleEntryDependency\");\nconst MultiModuleFactory = require(\"./MultiModuleFactory\");\nconst MultiEntryPlugin = require(\"./MultiEntryPlugin\");\nconst SingleEntryPlugin = require(\"./SingleEntryPlugin\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryDynamic} EntryDynamic */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryStatic} EntryStatic */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nclass DynamicEntryPlugin {\n\t/**\n\t * @param {string} context the context path\n\t * @param {EntryDynamic} entry the entry value\n\t */\n\tconstructor(context, entry) {\n\t\tthis.context = context;\n\t\tthis.entry = entry;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DynamicEntryPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst multiModuleFactory = new MultiModuleFactory();\n\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tMultiEntryDependency,\n\t\t\t\t\tmultiModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tSingleEntryDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.hooks.make.tapAsync(\n\t\t\t\"DynamicEntryPlugin\",\n\t\t\t(compilation, callback) => {\n\t\t\t\t/**\n\t\t\t\t * @param {string|string[]} entry entry value or array of entry values\n\t\t\t\t * @param {string} name name of entry\n\t\t\t\t * @returns {Promise<EntryStatic>} returns the promise resolving the Compilation#addEntry function\n\t\t\t\t */\n\t\t\t\tconst addEntry = (entry, name) => {\n\t\t\t\t\tconst dep = DynamicEntryPlugin.createDependency(entry, name);\n\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\tcompilation.addEntry(this.context, dep, name, err => {\n\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tPromise.resolve(this.entry()).then(entry => {\n\t\t\t\t\tif (typeof entry === \"string\" || Array.isArray(entry)) {\n\t\t\t\t\t\taddEntry(entry, \"main\").then(() => callback(), callback);\n\t\t\t\t\t} else if (typeof entry === \"object\") {\n\t\t\t\t\t\tPromise.all(\n\t\t\t\t\t\t\tObject.keys(entry).map(name => {\n\t\t\t\t\t\t\t\treturn addEntry(entry[name], name);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t).then(() => callback(), callback);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = DynamicEntryPlugin;\n/**\n * @param {string|string[]} entry entry value or array of entry paths\n * @param {string} name name of entry\n * @returns {SingleEntryDependency|MultiEntryDependency} returns dep\n */\nDynamicEntryPlugin.createDependency = (entry, name) => {\n\tif (Array.isArray(entry)) {\n\t\treturn MultiEntryPlugin.createDependency(entry, name);\n\t} else {\n\t\treturn SingleEntryPlugin.createDependency(entry, name);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}