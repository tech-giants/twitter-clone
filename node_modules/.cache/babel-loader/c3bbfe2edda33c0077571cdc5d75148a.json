{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\n\nconst {\n  intersect\n} = require(\"../util/SetHelpers\");\n\nconst getParentChunksWithModule = (currentChunk, module) => {\n  const chunks = [];\n  const stack = new Set(currentChunk.parentsIterable);\n\n  for (const chunk of stack) {\n    if (chunk.containsModule(module)) {\n      chunks.push(chunk);\n    } else {\n      for (const parent of chunk.parentsIterable) {\n        stack.add(parent);\n      }\n    }\n  }\n\n  return chunks;\n};\n\nclass RemoveParentModulesPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n      const handler = (chunks, chunkGroups) => {\n        const queue = new Queue();\n        const availableModulesMap = new WeakMap();\n\n        for (const chunkGroup of compilation.entrypoints.values()) {\n          // initialize available modules for chunks without parents\n          availableModulesMap.set(chunkGroup, new Set());\n\n          for (const child of chunkGroup.childrenIterable) {\n            queue.enqueue(child);\n          }\n        }\n\n        while (queue.length > 0) {\n          const chunkGroup = queue.dequeue();\n          let availableModules = availableModulesMap.get(chunkGroup);\n          let changed = false;\n\n          for (const parent of chunkGroup.parentsIterable) {\n            const availableModulesInParent = availableModulesMap.get(parent);\n\n            if (availableModulesInParent !== undefined) {\n              // If we know the available modules in parent: process these\n              if (availableModules === undefined) {\n                // if we have not own info yet: create new entry\n                availableModules = new Set(availableModulesInParent);\n\n                for (const chunk of parent.chunks) {\n                  for (const m of chunk.modulesIterable) {\n                    availableModules.add(m);\n                  }\n                }\n\n                availableModulesMap.set(chunkGroup, availableModules);\n                changed = true;\n              } else {\n                for (const m of availableModules) {\n                  if (!parent.containsModule(m) && !availableModulesInParent.has(m)) {\n                    availableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              }\n            }\n          }\n\n          if (changed) {\n            // if something changed: enqueue our children\n            for (const child of chunkGroup.childrenIterable) {\n              queue.enqueue(child);\n            }\n          }\n        } // now we have available modules for every chunk\n\n\n        for (const chunk of chunks) {\n          const availableModulesSets = Array.from(chunk.groupsIterable, chunkGroup => availableModulesMap.get(chunkGroup));\n          if (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\n          const availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n          const numberOfModules = chunk.getNumberOfModules();\n          const toRemove = new Set();\n\n          if (numberOfModules < availableModules.size) {\n            for (const m of chunk.modulesIterable) {\n              if (availableModules.has(m)) {\n                toRemove.add(m);\n              }\n            }\n          } else {\n            for (const m of availableModules) {\n              if (chunk.containsModule(m)) {\n                toRemove.add(m);\n              }\n            }\n          }\n\n          for (const module of toRemove) {\n            module.rewriteChunkInReasons(chunk, getParentChunksWithModule(chunk, module));\n            chunk.removeModule(module);\n          }\n        }\n      };\n\n      compilation.hooks.optimizeChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n      compilation.hooks.optimizeExtractedChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n    });\n  }\n\n}\n\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"names":["Queue","require","intersect","getParentChunksWithModule","currentChunk","module","chunks","stack","Set","parentsIterable","chunk","containsModule","push","parent","add","RemoveParentModulesPlugin","apply","compiler","hooks","compilation","tap","handler","chunkGroups","queue","availableModulesMap","WeakMap","chunkGroup","entrypoints","values","set","child","childrenIterable","enqueue","length","dequeue","availableModules","get","changed","availableModulesInParent","undefined","m","modulesIterable","has","delete","availableModulesSets","Array","from","groupsIterable","some","s","numberOfModules","getNumberOfModules","toRemove","size","rewriteChunkInReasons","removeModule","optimizeChunksBasic","optimizeExtractedChunksBasic","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\nconst { intersect } = require(\"../util/SetHelpers\");\n\nconst getParentChunksWithModule = (currentChunk, module) => {\n\tconst chunks = [];\n\tconst stack = new Set(currentChunk.parentsIterable);\n\n\tfor (const chunk of stack) {\n\t\tif (chunk.containsModule(module)) {\n\t\t\tchunks.push(chunk);\n\t\t} else {\n\t\t\tfor (const parent of chunk.parentsIterable) {\n\t\t\t\tstack.add(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chunks;\n};\n\nclass RemoveParentModulesPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst queue = new Queue();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst chunkGroup = queue.dequeue();\n\t\t\t\t\tlet availableModules = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModules === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModules = new Set(availableModulesInParent);\n\t\t\t\t\t\t\t\tfor (const chunk of parent.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.add(m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModules);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!parent.containsModule(m) &&\n\t\t\t\t\t\t\t\t\t\t!availableModulesInParent.has(m)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\t\t\t\t\tconst availableModules =\n\t\t\t\t\t\tavailableModulesSets.length === 1\n\t\t\t\t\t\t\t? availableModulesSets[0]\n\t\t\t\t\t\t\t: intersect(availableModulesSets);\n\t\t\t\t\tconst numberOfModules = chunk.getNumberOfModules();\n\t\t\t\t\tconst toRemove = new Set();\n\t\t\t\t\tif (numberOfModules < availableModules.size) {\n\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\tif (availableModules.has(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\tif (chunk.containsModule(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of toRemove) {\n\t\t\t\t\t\tmodule.rewriteChunkInReasons(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tgetParentChunksWithModule(chunk, module)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t\tcompilation.hooks.optimizeExtractedChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"]},"metadata":{},"sourceType":"script"}