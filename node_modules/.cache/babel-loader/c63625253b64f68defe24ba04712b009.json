{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst compareLocations = require(\"./compareLocations\");\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */\n\n/** @typedef {string|{name: string}} ChunkGroupOptions */\n\n\nlet debugId = 5000;\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\n\nconst getArray = set => Array.from(set);\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\n\n\nconst sortById = (a, b) => {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\n\n\nconst sortOrigin = (a, b) => {\n  const aIdent = a.module ? a.module.identifier() : \"\";\n  const bIdent = b.module ? b.module.identifier() : \"\";\n  if (aIdent < bIdent) return -1;\n  if (aIdent > bIdent) return 1;\n  return compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n  /**\n   * Creates an instance of ChunkGroup.\n   * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup\n   */\n  constructor(options) {\n    if (typeof options === \"string\") {\n      options = {\n        name: options\n      };\n    } else if (!options) {\n      options = {\n        name: undefined\n      };\n    }\n    /** @type {number} */\n\n\n    this.groupDebugId = debugId++;\n    this.options = options;\n    /** @type {SortableSet<ChunkGroup>} */\n\n    this._children = new SortableSet(undefined, sortById);\n    this._parents = new SortableSet(undefined, sortById);\n    this._blocks = new SortableSet();\n    /** @type {Chunk[]} */\n\n    this.chunks = [];\n    /** @type {OriginRecord[]} */\n\n    this.origins = [];\n    /** Indices in top-down order */\n\n    /** @private @type {Map<Module, number>} */\n\n    this._moduleIndices = new Map();\n    /** Indices in bottom-up order */\n\n    /** @private @type {Map<Module, number>} */\n\n    this._moduleIndices2 = new Map();\n  }\n  /**\n   * when a new chunk is added to a chunkGroup, addingOptions will occur.\n   * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n   * @returns {void}\n   */\n\n\n  addOptions(options) {\n    for (const key of Object.keys(options)) {\n      if (this.options[key] === undefined) {\n        this.options[key] = options[key];\n      } else if (this.options[key] !== options[key]) {\n        if (key.endsWith(\"Order\")) {\n          this.options[key] = Math.max(this.options[key], options[key]);\n        } else {\n          throw new Error(`ChunkGroup.addOptions: No option merge strategy for ${key}`);\n        }\n      }\n    }\n  }\n  /**\n   * returns the name of current ChunkGroup\n   * @returns {string|undefined} returns the ChunkGroup name\n   */\n\n\n  get name() {\n    return this.options.name;\n  }\n  /**\n   * sets a new name for current ChunkGroup\n   * @param {string} value the new name for ChunkGroup\n   * @returns {void}\n   */\n\n\n  set name(value) {\n    this.options.name = value;\n  }\n  /**\n   * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n   * @returns {string} a unique concatenation of chunk debugId's\n   */\n\n\n  get debugId() {\n    return Array.from(this.chunks, x => x.debugId).join(\"+\");\n  }\n  /**\n   * get a unique id for ChunkGroup, made up of its member Chunk id's\n   * @returns {string} a unique concatenation of chunk ids\n   */\n\n\n  get id() {\n    return Array.from(this.chunks, x => x.id).join(\"+\");\n  }\n  /**\n   * Performs an unshift of a specific chunk\n   * @param {Chunk} chunk chunk being unshifted\n   * @returns {boolean} returns true if attempted chunk shift is accepted\n   */\n\n\n  unshiftChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n\n    if (oldIdx > 0) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.unshift(chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.unshift(chunk);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * inserts a chunk before another existing chunk in group\n   * @param {Chunk} chunk Chunk being inserted\n   * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n   * @returns {boolean} return true if insertion was successful\n   */\n\n\n  insertChunk(chunk, before) {\n    const oldIdx = this.chunks.indexOf(chunk);\n    const idx = this.chunks.indexOf(before);\n\n    if (idx < 0) {\n      throw new Error(\"before chunk not found\");\n    }\n\n    if (oldIdx >= 0 && oldIdx > idx) {\n      this.chunks.splice(oldIdx, 1);\n      this.chunks.splice(idx, 0, chunk);\n    } else if (oldIdx < 0) {\n      this.chunks.splice(idx, 0, chunk);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * add a chunk into ChunkGroup. Is pushed on or prepended\n   * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n   * @returns {boolean} returns true if chunk addition was successful.\n   */\n\n\n  pushChunk(chunk) {\n    const oldIdx = this.chunks.indexOf(chunk);\n\n    if (oldIdx >= 0) {\n      return false;\n    }\n\n    this.chunks.push(chunk);\n    return true;\n  }\n  /**\n   * @param {Chunk} oldChunk chunk to be replaced\n   * @param {Chunk} newChunk New chunk that will be replaced with\n   * @returns {boolean} returns true if the replacement was successful\n   */\n\n\n  replaceChunk(oldChunk, newChunk) {\n    const oldIdx = this.chunks.indexOf(oldChunk);\n    if (oldIdx < 0) return false;\n    const newIdx = this.chunks.indexOf(newChunk);\n\n    if (newIdx < 0) {\n      this.chunks[oldIdx] = newChunk;\n      return true;\n    }\n\n    if (newIdx < oldIdx) {\n      this.chunks.splice(oldIdx, 1);\n      return true;\n    } else if (newIdx !== oldIdx) {\n      this.chunks[oldIdx] = newChunk;\n      this.chunks.splice(newIdx, 1);\n      return true;\n    }\n  }\n\n  removeChunk(chunk) {\n    const idx = this.chunks.indexOf(chunk);\n\n    if (idx >= 0) {\n      this.chunks.splice(idx, 1);\n      return true;\n    }\n\n    return false;\n  }\n\n  isInitial() {\n    return false;\n  }\n\n  addChild(chunk) {\n    if (this._children.has(chunk)) {\n      return false;\n    }\n\n    this._children.add(chunk);\n\n    return true;\n  }\n\n  getChildren() {\n    return this._children.getFromCache(getArray);\n  }\n\n  getNumberOfChildren() {\n    return this._children.size;\n  }\n\n  get childrenIterable() {\n    return this._children;\n  }\n\n  removeChild(chunk) {\n    if (!this._children.has(chunk)) {\n      return false;\n    }\n\n    this._children.delete(chunk);\n\n    chunk.removeParent(this);\n    return true;\n  }\n\n  addParent(parentChunk) {\n    if (!this._parents.has(parentChunk)) {\n      this._parents.add(parentChunk);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  getParents() {\n    return this._parents.getFromCache(getArray);\n  }\n\n  setParents(newParents) {\n    this._parents.clear();\n\n    for (const p of newParents) {\n      this._parents.add(p);\n    }\n  }\n\n  getNumberOfParents() {\n    return this._parents.size;\n  }\n\n  hasParent(parent) {\n    return this._parents.has(parent);\n  }\n\n  get parentsIterable() {\n    return this._parents;\n  }\n\n  removeParent(chunk) {\n    if (this._parents.delete(chunk)) {\n      chunk.removeChunk(this);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @returns {Array} - an array containing the blocks\n   */\n\n\n  getBlocks() {\n    return this._blocks.getFromCache(getArray);\n  }\n\n  getNumberOfBlocks() {\n    return this._blocks.size;\n  }\n\n  hasBlock(block) {\n    return this._blocks.has(block);\n  }\n\n  get blocksIterable() {\n    return this._blocks;\n  }\n\n  addBlock(block) {\n    if (!this._blocks.has(block)) {\n      this._blocks.add(block);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  addOrigin(module, loc, request) {\n    this.origins.push({\n      module,\n      loc,\n      request\n    });\n  }\n\n  containsModule(module) {\n    for (const chunk of this.chunks) {\n      if (chunk.containsModule(module)) return true;\n    }\n\n    return false;\n  }\n\n  getFiles() {\n    const files = new Set();\n\n    for (const chunk of this.chunks) {\n      for (const file of chunk.files) {\n        files.add(file);\n      }\n    }\n\n    return Array.from(files);\n  }\n  /**\n   * @param {string=} reason reason for removing ChunkGroup\n   * @returns {void}\n   */\n\n\n  remove(reason) {\n    // cleanup parents\n    for (const parentChunkGroup of this._parents) {\n      // remove this chunk from its parents\n      parentChunkGroup._children.delete(this); // cleanup \"sub chunks\"\n\n\n      for (const chunkGroup of this._children) {\n        /**\n         * remove this chunk as \"intermediary\" and connect\n         * it \"sub chunks\" and parents directly\n         */\n        // add parent to each \"sub chunk\"\n        chunkGroup.addParent(parentChunkGroup); // add \"sub chunk\" to parent\n\n        parentChunkGroup.addChild(chunkGroup);\n      }\n    }\n    /**\n     * we need to iterate again over the children\n     * to remove this from the child's parents.\n     * This can not be done in the above loop\n     * as it is not guaranteed that `this._parents` contains anything.\n     */\n\n\n    for (const chunkGroup of this._children) {\n      // remove this as parent of every \"sub chunk\"\n      chunkGroup._parents.delete(this);\n    } // cleanup blocks\n\n\n    for (const block of this._blocks) {\n      block.chunkGroup = null;\n    } // remove chunks\n\n\n    for (const chunk of this.chunks) {\n      chunk.removeGroup(this);\n    }\n  }\n\n  sortItems() {\n    this.origins.sort(sortOrigin);\n\n    this._parents.sort();\n\n    this._children.sort();\n  }\n  /**\n   * Sorting predicate which allows current ChunkGroup to be compared against another.\n   * Sorting values are based off of number of chunks in ChunkGroup.\n   *\n   * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n   * @returns {-1|0|1} sort position for comparison\n   */\n\n\n  compareTo(otherGroup) {\n    if (this.chunks.length > otherGroup.chunks.length) return -1;\n    if (this.chunks.length < otherGroup.chunks.length) return 1;\n    const a = this.chunks[Symbol.iterator]();\n    const b = otherGroup.chunks[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      const aItem = a.next();\n      const bItem = b.next();\n      if (aItem.done) return 0;\n      const cmp = aItem.value.compareTo(bItem.value);\n      if (cmp !== 0) return cmp;\n    }\n  }\n\n  getChildrenByOrders() {\n    const lists = new Map();\n\n    for (const childGroup of this._children) {\n      // TODO webpack 5 remove this check for options\n      if (typeof childGroup.options === \"object\") {\n        for (const key of Object.keys(childGroup.options)) {\n          if (key.endsWith(\"Order\")) {\n            const name = key.substr(0, key.length - \"Order\".length);\n            let list = lists.get(name);\n\n            if (list === undefined) {\n              lists.set(name, list = []);\n            }\n\n            list.push({\n              order: childGroup.options[key],\n              group: childGroup\n            });\n          }\n        }\n      }\n    }\n\n    const result = Object.create(null);\n\n    for (const [name, list] of lists) {\n      list.sort((a, b) => {\n        const cmp = b.order - a.order;\n        if (cmp !== 0) return cmp; // TODO webpack 5 remove this check of compareTo\n\n        if (a.group.compareTo) {\n          return a.group.compareTo(b.group);\n        }\n\n        return 0;\n      });\n      result[name] = list.map(i => i.group);\n    }\n\n    return result;\n  }\n  /**\n   * Sets the top-down index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n\n\n  setModuleIndex(module, index) {\n    this._moduleIndices.set(module, index);\n  }\n  /**\n   * Gets the top-down index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n\n\n  getModuleIndex(module) {\n    return this._moduleIndices.get(module);\n  }\n  /**\n   * Sets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module module for which the index should be set\n   * @param {number} index the index of the module\n   * @returns {void}\n   */\n\n\n  setModuleIndex2(module, index) {\n    this._moduleIndices2.set(module, index);\n  }\n  /**\n   * Gets the bottom-up index of a module in this ChunkGroup\n   * @param {Module} module the module\n   * @returns {number} index\n   */\n\n\n  getModuleIndex2(module) {\n    return this._moduleIndices2.get(module);\n  }\n\n  checkConstraints() {\n    const chunk = this;\n\n    for (const child of chunk._children) {\n      if (!child._parents.has(chunk)) {\n        throw new Error(`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`);\n      }\n    }\n\n    for (const parentChunk of chunk._parents) {\n      if (!parentChunk._children.has(chunk)) {\n        throw new Error(`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`);\n      }\n    }\n  }\n\n}\n\nmodule.exports = ChunkGroup;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/ChunkGroup.js"],"names":["SortableSet","require","compareLocations","debugId","getArray","set","Array","from","sortById","a","b","id","sortOrigin","aIdent","module","identifier","bIdent","loc","ChunkGroup","constructor","options","name","undefined","groupDebugId","_children","_parents","_blocks","chunks","origins","_moduleIndices","Map","_moduleIndices2","addOptions","key","Object","keys","endsWith","Math","max","Error","value","x","join","unshiftChunk","chunk","oldIdx","indexOf","splice","unshift","insertChunk","before","idx","pushChunk","push","replaceChunk","oldChunk","newChunk","newIdx","removeChunk","isInitial","addChild","has","add","getChildren","getFromCache","getNumberOfChildren","size","childrenIterable","removeChild","delete","removeParent","addParent","parentChunk","getParents","setParents","newParents","clear","p","getNumberOfParents","hasParent","parent","parentsIterable","getBlocks","getNumberOfBlocks","hasBlock","block","blocksIterable","addBlock","addOrigin","request","containsModule","getFiles","files","Set","file","remove","reason","parentChunkGroup","chunkGroup","removeGroup","sortItems","sort","compareTo","otherGroup","length","Symbol","iterator","aItem","next","bItem","done","cmp","getChildrenByOrders","lists","childGroup","substr","list","get","order","group","result","create","map","i","setModuleIndex","index","getModuleIndex","setModuleIndex2","getModuleIndex2","checkConstraints","child","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst SortableSet = require(\"./util/SortableSet\");\nconst compareLocations = require(\"./compareLocations\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {{module: Module, loc: TODO, request: string}} OriginRecord */\n/** @typedef {string|{name: string}} ChunkGroupOptions */\n\nlet debugId = 5000;\n\n/**\n * @template T\n * @param {SortableSet<T>} set set to convert to array.\n * @returns {T[]} the array format of existing set\n */\nconst getArray = set => Array.from(set);\n\n/**\n * A convenience method used to sort chunks based on their id's\n * @param {ChunkGroup} a first sorting comparator\n * @param {ChunkGroup} b second sorting comparator\n * @returns {1|0|-1} a sorting index to determine order\n */\nconst sortById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {OriginRecord} a the first comparator in sort\n * @param {OriginRecord} b the second comparator in sort\n * @returns {1|-1|0} returns sorting order as index\n */\nconst sortOrigin = (a, b) => {\n\tconst aIdent = a.module ? a.module.identifier() : \"\";\n\tconst bIdent = b.module ? b.module.identifier() : \"\";\n\tif (aIdent < bIdent) return -1;\n\tif (aIdent > bIdent) return 1;\n\treturn compareLocations(a.loc, b.loc);\n};\n\nclass ChunkGroup {\n\t/**\n\t * Creates an instance of ChunkGroup.\n\t * @param {ChunkGroupOptions=} options chunk group options passed to chunkGroup\n\t */\n\tconstructor(options) {\n\t\tif (typeof options === \"string\") {\n\t\t\toptions = { name: options };\n\t\t} else if (!options) {\n\t\t\toptions = { name: undefined };\n\t\t}\n\t\t/** @type {number} */\n\t\tthis.groupDebugId = debugId++;\n\t\tthis.options = options;\n\t\t/** @type {SortableSet<ChunkGroup>} */\n\t\tthis._children = new SortableSet(undefined, sortById);\n\t\tthis._parents = new SortableSet(undefined, sortById);\n\t\tthis._blocks = new SortableSet();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {OriginRecord[]} */\n\t\tthis.origins = [];\n\t\t/** Indices in top-down order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._moduleIndices = new Map();\n\t\t/** Indices in bottom-up order */\n\t\t/** @private @type {Map<Module, number>} */\n\t\tthis._moduleIndices2 = new Map();\n\t}\n\n\t/**\n\t * when a new chunk is added to a chunkGroup, addingOptions will occur.\n\t * @param {ChunkGroupOptions} options the chunkGroup options passed to addOptions\n\t * @returns {void}\n\t */\n\taddOptions(options) {\n\t\tfor (const key of Object.keys(options)) {\n\t\t\tif (this.options[key] === undefined) {\n\t\t\t\tthis.options[key] = options[key];\n\t\t\t} else if (this.options[key] !== options[key]) {\n\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\tthis.options[key] = Math.max(this.options[key], options[key]);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkGroup.addOptions: No option merge strategy for ${key}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * returns the name of current ChunkGroup\n\t * @returns {string|undefined} returns the ChunkGroup name\n\t */\n\tget name() {\n\t\treturn this.options.name;\n\t}\n\n\t/**\n\t * sets a new name for current ChunkGroup\n\t * @param {string} value the new name for ChunkGroup\n\t * @returns {void}\n\t */\n\tset name(value) {\n\t\tthis.options.name = value;\n\t}\n\n\t/**\n\t * get a uniqueId for ChunkGroup, made up of its member Chunk debugId's\n\t * @returns {string} a unique concatenation of chunk debugId's\n\t */\n\tget debugId() {\n\t\treturn Array.from(this.chunks, x => x.debugId).join(\"+\");\n\t}\n\n\t/**\n\t * get a unique id for ChunkGroup, made up of its member Chunk id's\n\t * @returns {string} a unique concatenation of chunk ids\n\t */\n\tget id() {\n\t\treturn Array.from(this.chunks, x => x.id).join(\"+\");\n\t}\n\n\t/**\n\t * Performs an unshift of a specific chunk\n\t * @param {Chunk} chunk chunk being unshifted\n\t * @returns {boolean} returns true if attempted chunk shift is accepted\n\t */\n\tunshiftChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx > 0) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.unshift(chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.unshift(chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * inserts a chunk before another existing chunk in group\n\t * @param {Chunk} chunk Chunk being inserted\n\t * @param {Chunk} before Placeholder/target chunk marking new chunk insertion point\n\t * @returns {boolean} return true if insertion was successful\n\t */\n\tinsertChunk(chunk, before) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tconst idx = this.chunks.indexOf(before);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"before chunk not found\");\n\t\t}\n\t\tif (oldIdx >= 0 && oldIdx > idx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t} else if (oldIdx < 0) {\n\t\t\tthis.chunks.splice(idx, 0, chunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * add a chunk into ChunkGroup. Is pushed on or prepended\n\t * @param {Chunk} chunk chunk being pushed into ChunkGroupS\n\t * @returns {boolean} returns true if chunk addition was successful.\n\t */\n\tpushChunk(chunk) {\n\t\tconst oldIdx = this.chunks.indexOf(chunk);\n\t\tif (oldIdx >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.chunks.push(chunk);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} oldChunk chunk to be replaced\n\t * @param {Chunk} newChunk New chunk that will be replaced with\n\t * @returns {boolean} returns true if the replacement was successful\n\t */\n\treplaceChunk(oldChunk, newChunk) {\n\t\tconst oldIdx = this.chunks.indexOf(oldChunk);\n\t\tif (oldIdx < 0) return false;\n\t\tconst newIdx = this.chunks.indexOf(newChunk);\n\t\tif (newIdx < 0) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\treturn true;\n\t\t}\n\t\tif (newIdx < oldIdx) {\n\t\t\tthis.chunks.splice(oldIdx, 1);\n\t\t\treturn true;\n\t\t} else if (newIdx !== oldIdx) {\n\t\t\tthis.chunks[oldIdx] = newChunk;\n\t\t\tthis.chunks.splice(newIdx, 1);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tremoveChunk(chunk) {\n\t\tconst idx = this.chunks.indexOf(chunk);\n\t\tif (idx >= 0) {\n\t\t\tthis.chunks.splice(idx, 1);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tisInitial() {\n\t\treturn false;\n\t}\n\n\taddChild(chunk) {\n\t\tif (this._children.has(chunk)) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._children.add(chunk);\n\t\treturn true;\n\t}\n\n\tgetChildren() {\n\t\treturn this._children.getFromCache(getArray);\n\t}\n\n\tgetNumberOfChildren() {\n\t\treturn this._children.size;\n\t}\n\n\tget childrenIterable() {\n\t\treturn this._children;\n\t}\n\n\tremoveChild(chunk) {\n\t\tif (!this._children.has(chunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._children.delete(chunk);\n\t\tchunk.removeParent(this);\n\t\treturn true;\n\t}\n\n\taddParent(parentChunk) {\n\t\tif (!this._parents.has(parentChunk)) {\n\t\t\tthis._parents.add(parentChunk);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetParents() {\n\t\treturn this._parents.getFromCache(getArray);\n\t}\n\n\tsetParents(newParents) {\n\t\tthis._parents.clear();\n\t\tfor (const p of newParents) {\n\t\t\tthis._parents.add(p);\n\t\t}\n\t}\n\n\tgetNumberOfParents() {\n\t\treturn this._parents.size;\n\t}\n\n\thasParent(parent) {\n\t\treturn this._parents.has(parent);\n\t}\n\n\tget parentsIterable() {\n\t\treturn this._parents;\n\t}\n\n\tremoveParent(chunk) {\n\t\tif (this._parents.delete(chunk)) {\n\t\t\tchunk.removeChunk(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {Array} - an array containing the blocks\n\t */\n\tgetBlocks() {\n\t\treturn this._blocks.getFromCache(getArray);\n\t}\n\n\tgetNumberOfBlocks() {\n\t\treturn this._blocks.size;\n\t}\n\n\thasBlock(block) {\n\t\treturn this._blocks.has(block);\n\t}\n\n\tget blocksIterable() {\n\t\treturn this._blocks;\n\t}\n\n\taddBlock(block) {\n\t\tif (!this._blocks.has(block)) {\n\t\t\tthis._blocks.add(block);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\taddOrigin(module, loc, request) {\n\t\tthis.origins.push({\n\t\t\tmodule,\n\t\t\tloc,\n\t\t\trequest\n\t\t});\n\t}\n\n\tcontainsModule(module) {\n\t\tfor (const chunk of this.chunks) {\n\t\t\tif (chunk.containsModule(module)) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tgetFiles() {\n\t\tconst files = new Set();\n\n\t\tfor (const chunk of this.chunks) {\n\t\t\tfor (const file of chunk.files) {\n\t\t\t\tfiles.add(file);\n\t\t\t}\n\t\t}\n\n\t\treturn Array.from(files);\n\t}\n\n\t/**\n\t * @param {string=} reason reason for removing ChunkGroup\n\t * @returns {void}\n\t */\n\tremove(reason) {\n\t\t// cleanup parents\n\t\tfor (const parentChunkGroup of this._parents) {\n\t\t\t// remove this chunk from its parents\n\t\t\tparentChunkGroup._children.delete(this);\n\n\t\t\t// cleanup \"sub chunks\"\n\t\t\tfor (const chunkGroup of this._children) {\n\t\t\t\t/**\n\t\t\t\t * remove this chunk as \"intermediary\" and connect\n\t\t\t\t * it \"sub chunks\" and parents directly\n\t\t\t\t */\n\t\t\t\t// add parent to each \"sub chunk\"\n\t\t\t\tchunkGroup.addParent(parentChunkGroup);\n\t\t\t\t// add \"sub chunk\" to parent\n\t\t\t\tparentChunkGroup.addChild(chunkGroup);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * we need to iterate again over the children\n\t\t * to remove this from the child's parents.\n\t\t * This can not be done in the above loop\n\t\t * as it is not guaranteed that `this._parents` contains anything.\n\t\t */\n\t\tfor (const chunkGroup of this._children) {\n\t\t\t// remove this as parent of every \"sub chunk\"\n\t\t\tchunkGroup._parents.delete(this);\n\t\t}\n\n\t\t// cleanup blocks\n\t\tfor (const block of this._blocks) {\n\t\t\tblock.chunkGroup = null;\n\t\t}\n\n\t\t// remove chunks\n\t\tfor (const chunk of this.chunks) {\n\t\t\tchunk.removeGroup(this);\n\t\t}\n\t}\n\n\tsortItems() {\n\t\tthis.origins.sort(sortOrigin);\n\t\tthis._parents.sort();\n\t\tthis._children.sort();\n\t}\n\n\t/**\n\t * Sorting predicate which allows current ChunkGroup to be compared against another.\n\t * Sorting values are based off of number of chunks in ChunkGroup.\n\t *\n\t * @param {ChunkGroup} otherGroup the chunkGroup to compare this against\n\t * @returns {-1|0|1} sort position for comparison\n\t */\n\tcompareTo(otherGroup) {\n\t\tif (this.chunks.length > otherGroup.chunks.length) return -1;\n\t\tif (this.chunks.length < otherGroup.chunks.length) return 1;\n\t\tconst a = this.chunks[Symbol.iterator]();\n\t\tconst b = otherGroup.chunks[Symbol.iterator]();\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tconst aItem = a.next();\n\t\t\tconst bItem = b.next();\n\t\t\tif (aItem.done) return 0;\n\t\t\tconst cmp = aItem.value.compareTo(bItem.value);\n\t\t\tif (cmp !== 0) return cmp;\n\t\t}\n\t}\n\n\tgetChildrenByOrders() {\n\t\tconst lists = new Map();\n\t\tfor (const childGroup of this._children) {\n\t\t\t// TODO webpack 5 remove this check for options\n\t\t\tif (typeof childGroup.options === \"object\") {\n\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\tif (list === undefined) {\n\t\t\t\t\t\t\tlists.set(name, (list = []));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\t// TODO webpack 5 remove this check of compareTo\n\t\t\t\tif (a.group.compareTo) {\n\t\t\t\t\treturn a.group.compareTo(b.group);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tresult[name] = list.map(i => i.group);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModuleIndex(module, index) {\n\t\tthis._moduleIndices.set(module, index);\n\t}\n\n\t/**\n\t * Gets the top-down index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModuleIndex(module) {\n\t\treturn this._moduleIndices.get(module);\n\t}\n\n\t/**\n\t * Sets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module module for which the index should be set\n\t * @param {number} index the index of the module\n\t * @returns {void}\n\t */\n\tsetModuleIndex2(module, index) {\n\t\tthis._moduleIndices2.set(module, index);\n\t}\n\n\t/**\n\t * Gets the bottom-up index of a module in this ChunkGroup\n\t * @param {Module} module the module\n\t * @returns {number} index\n\t */\n\tgetModuleIndex2(module) {\n\t\treturn this._moduleIndices2.get(module);\n\t}\n\n\tcheckConstraints() {\n\t\tconst chunk = this;\n\t\tfor (const child of chunk._children) {\n\t\t\tif (!child._parents.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: child missing parent ${chunk.debugId} -> ${child.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const parentChunk of chunk._parents) {\n\t\t\tif (!parentChunk._children.has(chunk)) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: parent missing child ${parentChunk.debugId} <- ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ChunkGroup;\n"]},"metadata":{},"sourceType":"script"}