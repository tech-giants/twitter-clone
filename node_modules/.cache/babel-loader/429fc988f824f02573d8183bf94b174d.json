{"ast":null,"code":"'use strict';\n\nvar typeOf = require('kind-of');\n\nvar utils = module.exports;\n/**\n * Returns true if the given value is a node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isNode(node)); //=> true\n * console.log(utils.isNode({})); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Boolean}\n * @api public\n */\n\nutils.isNode = function (node) {\n  return typeOf(node) === 'object' && node.isNode === true;\n};\n/**\n * Emit an empty string for the given `node`.\n *\n * ```js\n * // do nothing for beginning-of-string\n * snapdragon.compiler.set('bos', utils.noop);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\n\nutils.noop = function (node) {\n  append(this, '', node);\n};\n/**\n * Appdend `node.val` to `compiler.output`, exactly as it was created\n * by the parser.\n *\n * ```js\n * snapdragon.compiler.set('text', utils.identity);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\n\nutils.identity = function (node) {\n  append(this, node.val, node);\n};\n/**\n * Previously named `.emit`, this method appends the given `val`\n * to `compiler.output` for the given node. Useful when you know\n * what value should be appended advance, regardless of the actual\n * value of `node.val`.\n *\n * ```js\n * snapdragon.compiler\n *   .set('i', function(node) {\n *     this.mapVisit(node);\n *   })\n *   .set('i.open', utils.append('<i>'))\n *   .set('i.close', utils.append('</i>'))\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Function} Returns a compiler middleware function.\n * @api public\n */\n\n\nutils.append = function (val) {\n  return function (node) {\n    append(this, val, node);\n  };\n};\n/**\n * Used in compiler middleware, this onverts an AST node into\n * an empty `text` node and deletes `node.nodes` if it exists.\n * The advantage of this method is that, as opposed to completely\n * removing the node, indices will not need to be re-calculated\n * in sibling nodes, and nothing is appended to the output.\n *\n * ```js\n * utils.toNoop(node);\n * // convert `node.nodes` to the given value instead of deleting it\n * utils.toNoop(node, []);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.\n * @api public\n */\n\n\nutils.toNoop = function (node, nodes) {\n  if (nodes) {\n    node.nodes = nodes;\n  } else {\n    delete node.nodes;\n    node.type = 'text';\n    node.val = '';\n  }\n};\n/**\n * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon\n * automatically calls registered compilers, this allows you to pass a visitor\n * function.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.visit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Object} returns the node after recursively visiting all child nodes.\n * @api public\n */\n\n\nutils.visit = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(fn), 'expected a visitor function');\n  fn(node);\n  return node.nodes ? utils.mapVisit(node, fn) : node;\n};\n/**\n * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by\n * [visit](#visit), use this method if you do not want `fn` to be called on\n * the first node.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.mapVisit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Object} `options`\n * @param {Function} `fn`\n * @return {Object} returns the node\n * @api public\n */\n\n\nutils.mapVisit = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isArray(node.nodes), 'expected node.nodes to be an array');\n  assert(isFunction(fn), 'expected a visitor function');\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    utils.visit(node.nodes[i], fn);\n  }\n\n  return node;\n};\n/**\n * Unshift an `*.open` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^{/);\n *   if (match) {\n *     var parent = new Node({type: 'brace'});\n *     utils.addOpen(parent, Node);\n *     console.log(parent.nodes[0]):\n *     // { type: 'brace.open', val: '' };\n *\n *     // push the parent \"brace\" node onto the stack\n *     this.push(parent);\n *\n *     // return the parent node, so it's also added to the AST\n *     return brace;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created opening node.\n * @api public\n */\n\n\nutils.addOpen = function (node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var open = new Node({\n    type: node.type + '.open',\n    val: val\n  });\n  var unshift = node.unshift || node.unshiftNode;\n\n  if (typeof unshift === 'function') {\n    unshift.call(node, open);\n  } else {\n    utils.unshiftNode(node, open);\n  }\n\n  return open;\n};\n/**\n * Push a `*.close` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^}/);\n *   if (match) {\n *     var parent = this.parent();\n *     if (parent.type !== 'brace') {\n *       throw new Error('missing opening: ' + '}');\n *     }\n *\n *     utils.addClose(parent, Node);\n *     console.log(parent.nodes[parent.nodes.length - 1]):\n *     // { type: 'brace.close', val: '' };\n *\n *     // no need to return a node, since the parent\n *     // was already added to the AST\n *     return;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created closing node.\n * @api public\n */\n\n\nutils.addClose = function (node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var close = new Node({\n    type: node.type + '.close',\n    val: val\n  });\n  var push = node.push || node.pushNode;\n\n  if (typeof push === 'function') {\n    push.call(node, close);\n  } else {\n    utils.pushNode(node, close);\n  }\n\n  return close;\n};\n/**\n * Wraps the given `node` with `*.open` and `*.close` nodes.\n *\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the node\n * @api public\n */\n\n\nutils.wrapNodes = function (node, Node, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n  utils.addOpen(node, Node, filter);\n  utils.addClose(node, Node, filter);\n  return node;\n};\n/**\n * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.pushNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object} Returns the child node\n * @api public\n */\n\n\nutils.pushNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.push(node);\n  return node;\n};\n/**\n * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.unshiftNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {undefined}\n * @api public\n */\n\n\nutils.unshiftNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.unshift(node);\n};\n/**\n * Pop the last `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.popNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\n\nutils.popNode = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (typeof node.pop === 'function') {\n    return node.pop();\n  }\n\n  return node.nodes && node.nodes.pop();\n};\n/**\n * Shift the first `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.shiftNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\n\nutils.shiftNode = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (typeof node.shift === 'function') {\n    return node.shift();\n  }\n\n  return node.nodes && node.nodes.shift();\n};\n/**\n * Remove the specified `node` from `parent.nodes`.\n *\n * ```js\n * var parent = new Node({type: 'abc'});\n * var foo = new Node({type: 'foo'});\n * utils.pushNode(parent, foo);\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.removeNode(parent, foo);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.\n * @api public\n */\n\n\nutils.removeNode = function (parent, node) {\n  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!parent.nodes) {\n    return null;\n  }\n\n  if (typeof parent.remove === 'function') {\n    return parent.remove(node);\n  }\n\n  var idx = parent.nodes.indexOf(node);\n\n  if (idx !== -1) {\n    return parent.nodes.splice(idx, 1);\n  }\n};\n/**\n * Returns true if `node.type` matches the given `type`. Throws a\n * `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isType(node, 'foo')); // false\n * console.log(utils.isType(node, 'bar')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\n\nutils.isType = function (node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  switch (typeOf(type)) {\n    case 'array':\n      var types = type.slice();\n\n      for (var i = 0; i < types.length; i++) {\n        if (utils.isType(node, types[i])) {\n          return true;\n        }\n      }\n\n      return false;\n\n    case 'string':\n      return node.type === type;\n\n    case 'regexp':\n      return type.test(node.type);\n\n    default:\n      {\n        throw new TypeError('expected \"type\" to be an array, string or regexp');\n      }\n  }\n};\n/**\n * Returns true if the given `node` has the given `type` in `node.nodes`.\n * Throws a `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'bar'}),\n *     new Node({type: 'baz'})\n *   ]\n * });\n * console.log(utils.hasType(node, 'xyz')); // false\n * console.log(utils.hasType(node, 'baz')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\n\nutils.hasType = function (node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (!Array.isArray(node.nodes)) return false;\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    if (utils.isType(node.nodes[i], type)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Returns the first node from `node.nodes` of the given `type`\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var textNode = utils.firstOfType(node.nodes, 'text');\n * console.log(textNode.val);\n * //=> 'abc'\n * ```\n * @param {Array} `nodes`\n * @param {String} `type`\n * @return {Object|undefined} Returns the first matching node or undefined.\n * @api public\n */\n\n\nutils.firstOfType = function (nodes, type) {\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (utils.isType(node, type)) {\n      return node;\n    }\n  }\n};\n/**\n * Returns the node at the specified index, or the first node of the\n * given `type` from `node.nodes`.\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var nodeOne = utils.findNode(node.nodes, 'text');\n * console.log(nodeOne.val);\n * //=> 'abc'\n *\n * var nodeTwo = utils.findNode(node.nodes, 1);\n * console.log(nodeTwo.val);\n * //=> 'xyz'\n * ```\n *\n * @param {Array} `nodes`\n * @param {String|Number} `type` Node type or index.\n * @return {Object} Returns a node or undefined.\n * @api public\n */\n\n\nutils.findNode = function (nodes, type) {\n  if (!Array.isArray(nodes)) {\n    return null;\n  }\n\n  if (typeof type === 'number') {\n    return nodes[type];\n  }\n\n  return utils.firstOfType(nodes, type);\n};\n/**\n * Returns true if the given node is an \"*.open\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isOpen(brace)); // false\n * console.log(utils.isOpen(open)); // true\n * console.log(utils.isOpen(close)); // false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\n\nutils.isOpen = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-5) === '.open';\n};\n/**\n * Returns true if the given node is a \"*.close\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isClose(brace)); // false\n * console.log(utils.isClose(open)); // false\n * console.log(utils.isClose(close)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\n\nutils.isClose = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-6) === '.close';\n};\n/**\n * Returns true if `node.nodes` **has** an `.open` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.hasOpen(brace)); // false\n *\n * brace.pushNode(open);\n * console.log(utils.hasOpen(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\n\nutils.hasOpen = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var first = node.first || node.nodes ? node.nodes[0] : null;\n\n  if (utils.isNode(first)) {\n    return first.type === node.type + '.open';\n  }\n\n  return false;\n};\n/**\n * Returns true if `node.nodes` **has** a `.close` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(close);\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\n\nutils.hasClose = function (node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;\n\n  if (utils.isNode(last)) {\n    return last.type === node.type + '.close';\n  }\n\n  return false;\n};\n/**\n * Returns true if `node.nodes` has both `.open` and `.close` nodes\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasOpen(brace)); // false\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(open);\n * brace.pushNode(close);\n * console.log(utils.hasOpen(brace)); // true\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\n\nutils.hasOpenAndClose = function (node) {\n  return utils.hasOpen(node) && utils.hasClose(node);\n};\n/**\n * Push the given `node` onto the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\n\nutils.addType = function (state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n  var type = node.parent ? node.parent.type : node.type.replace(/\\.open$/, '');\n\n  if (!state.hasOwnProperty('inside')) {\n    state.inside = {};\n  }\n\n  if (!state.inside.hasOwnProperty(type)) {\n    state.inside[type] = [];\n  }\n\n  var arr = state.inside[type];\n  arr.push(node);\n  return arr;\n};\n/**\n * Remove the given `node` from the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * utils.removeType(state, node);\n * //=> { brace: [] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\n\nutils.removeType = function (state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n  var type = node.parent ? node.parent.type : node.type.replace(/\\.close$/, '');\n\n  if (state.inside.hasOwnProperty(type)) {\n    return state.inside[type].pop();\n  }\n};\n/**\n * Returns true if `node.val` is an empty string, or `node.nodes` does\n * not contain any non-empty text nodes.\n *\n * ```js\n * var node = new Node({type: 'text'});\n * utils.isEmpty(node); //=> true\n * node.val = 'foo';\n * utils.isEmpty(node); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Boolean}\n * @api public\n */\n\n\nutils.isEmpty = function (node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!Array.isArray(node.nodes)) {\n    if (node.type !== 'text') {\n      return true;\n    }\n\n    if (typeof fn === 'function') {\n      return fn(node, node.parent);\n    }\n\n    return !utils.trim(node.val);\n  }\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    var child = node.nodes[i];\n\n    if (utils.isOpen(child) || utils.isClose(child)) {\n      continue;\n    }\n\n    if (!utils.isEmpty(child, fn)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Returns true if the `state.inside` stack for the given type exists\n * and has one or more nodes on it.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * utils.addType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> true\n * utils.removeType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * ```\n * @param {Object} `state`\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\n\nutils.isInsideType = function (state, type) {\n  assert(isObject(state), 'expected state to be an object');\n  assert(isString(type), 'expected type to be a string');\n\n  if (!state.hasOwnProperty('inside')) {\n    return false;\n  }\n\n  if (!state.inside.hasOwnProperty(type)) {\n    return false;\n  }\n\n  return state.inside[type].length > 0;\n};\n/**\n * Returns true if `node` is either a child or grand-child of the given `type`,\n * or `state.inside[type]` is a non-empty array.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.isInside(state, open, 'brace')); //=> false\n * utils.pushNode(node, open);\n * console.log(utils.isInside(state, open, 'brace')); //=> true\n * ```\n * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type` The `node.type` to check for.\n * @return {Boolean}\n * @api public\n */\n\n\nutils.isInside = function (state, node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  if (Array.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      if (utils.isInside(state, node, type[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var parent = node.parent;\n\n  if (typeof type === 'string') {\n    return parent && parent.type === type || utils.isInsideType(state, type);\n  }\n\n  if (typeOf(type) === 'regexp') {\n    if (parent && parent.type && type.test(parent.type)) {\n      return true;\n    }\n\n    var keys = Object.keys(state.inside);\n    var len = keys.length;\n    var idx = -1;\n\n    while (++idx < len) {\n      var key = keys[idx];\n      var val = state.inside[key];\n\n      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Get the last `n` element from the given `array`. Used for getting\n * a node from `node.nodes.`\n *\n * @param {Array} `array`\n * @param {Number} `n`\n * @return {undefined}\n * @api public\n */\n\n\nutils.last = function (arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n/**\n * Cast the given `val` to an array.\n *\n * ```js\n * console.log(utils.arrayify(''));\n * //=> []\n * console.log(utils.arrayify('foo'));\n * //=> ['foo']\n * console.log(utils.arrayify(['foo']));\n * //=> ['foo']\n * ```\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\n\nutils.arrayify = function (val) {\n  if (typeof val === 'string' && val !== '') {\n    return [val];\n  }\n\n  if (!Array.isArray(val)) {\n    return [];\n  }\n\n  return val;\n};\n/**\n * Convert the given `val` to a string by joining with `,`. Useful\n * for creating a cheerio/CSS/DOM-style selector from a list of strings.\n *\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\n\nutils.stringify = function (val) {\n  return utils.arrayify(val).join(',');\n};\n/**\n * Ensure that the given value is a string and call `.trim()` on it,\n * or return an empty string.\n *\n * @param {String} `str`\n * @return {String}\n * @api public\n */\n\n\nutils.trim = function (str) {\n  return typeof str === 'string' ? str.trim() : '';\n};\n/**\n * Return true if val is an object\n */\n\n\nfunction isObject(val) {\n  return typeOf(val) === 'object';\n}\n/**\n * Return true if val is a string\n */\n\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n/**\n * Return true if val is a function\n */\n\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n/**\n * Return true if val is an array\n */\n\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n/**\n * Shim to ensure the `.append` methods work with any version of snapdragon\n */\n\n\nfunction append(compiler, val, node) {\n  if (typeof compiler.append !== 'function') {\n    return compiler.emit(val, node);\n  }\n\n  return compiler.append(val, node);\n}\n/**\n * Simplified assertion. Throws an error is `val` is falsey.\n */\n\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/snapdragon-util/index.js"],"names":["typeOf","require","utils","module","exports","isNode","node","noop","append","identity","val","toNoop","nodes","type","visit","fn","assert","isFunction","mapVisit","isArray","i","length","addOpen","Node","filter","open","unshift","unshiftNode","call","addClose","close","push","pushNode","wrapNodes","parent","define","popNode","pop","shiftNode","shift","removeNode","remove","idx","indexOf","splice","isType","types","slice","test","TypeError","hasType","Array","firstOfType","findNode","isOpen","isClose","hasOpen","first","hasClose","last","hasOpenAndClose","addType","state","isObject","replace","hasOwnProperty","inside","arr","removeType","isEmpty","trim","child","isInsideType","isString","isInside","keys","Object","len","key","n","arrayify","stringify","join","str","compiler","emit","message","Error"],"mappings":"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","sourcesContent":["'use strict';\n\nvar typeOf = require('kind-of');\nvar utils = module.exports;\n\n/**\n * Returns true if the given value is a node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isNode(node)); //=> true\n * console.log(utils.isNode({})); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Boolean}\n * @api public\n */\n\nutils.isNode = function(node) {\n  return typeOf(node) === 'object' && node.isNode === true;\n};\n\n/**\n * Emit an empty string for the given `node`.\n *\n * ```js\n * // do nothing for beginning-of-string\n * snapdragon.compiler.set('bos', utils.noop);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.noop = function(node) {\n  append(this, '', node);\n};\n\n/**\n * Appdend `node.val` to `compiler.output`, exactly as it was created\n * by the parser.\n *\n * ```js\n * snapdragon.compiler.set('text', utils.identity);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {undefined}\n * @api public\n */\n\nutils.identity = function(node) {\n  append(this, node.val, node);\n};\n\n/**\n * Previously named `.emit`, this method appends the given `val`\n * to `compiler.output` for the given node. Useful when you know\n * what value should be appended advance, regardless of the actual\n * value of `node.val`.\n *\n * ```js\n * snapdragon.compiler\n *   .set('i', function(node) {\n *     this.mapVisit(node);\n *   })\n *   .set('i.open', utils.append('<i>'))\n *   .set('i.close', utils.append('</i>'))\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @returns {Function} Returns a compiler middleware function.\n * @api public\n */\n\nutils.append = function(val) {\n  return function(node) {\n    append(this, val, node);\n  };\n};\n\n/**\n * Used in compiler middleware, this onverts an AST node into\n * an empty `text` node and deletes `node.nodes` if it exists.\n * The advantage of this method is that, as opposed to completely\n * removing the node, indices will not need to be re-calculated\n * in sibling nodes, and nothing is appended to the output.\n *\n * ```js\n * utils.toNoop(node);\n * // convert `node.nodes` to the given value instead of deleting it\n * utils.toNoop(node, []);\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Array} `nodes` Optionally pass a new `nodes` value, to replace the existing `node.nodes` array.\n * @api public\n */\n\nutils.toNoop = function(node, nodes) {\n  if (nodes) {\n    node.nodes = nodes;\n  } else {\n    delete node.nodes;\n    node.type = 'text';\n    node.val = '';\n  }\n};\n\n/**\n * Visit `node` with the given `fn`. The built-in `.visit` method in snapdragon\n * automatically calls registered compilers, this allows you to pass a visitor\n * function.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.visit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Object} returns the node after recursively visiting all child nodes.\n * @api public\n */\n\nutils.visit = function(node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(fn), 'expected a visitor function');\n  fn(node);\n  return node.nodes ? utils.mapVisit(node, fn) : node;\n};\n\n/**\n * Map [visit](#visit) the given `fn` over `node.nodes`. This is called by\n * [visit](#visit), use this method if you do not want `fn` to be called on\n * the first node.\n *\n * ```js\n * snapdragon.compiler.set('i', function(node) {\n *   utils.mapVisit(node, function(childNode) {\n *     // do stuff with \"childNode\"\n *     return childNode;\n *   });\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Object} `options`\n * @param {Function} `fn`\n * @return {Object} returns the node\n * @api public\n */\n\nutils.mapVisit = function(node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isArray(node.nodes), 'expected node.nodes to be an array');\n  assert(isFunction(fn), 'expected a visitor function');\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    utils.visit(node.nodes[i], fn);\n  }\n  return node;\n};\n\n/**\n * Unshift an `*.open` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^{/);\n *   if (match) {\n *     var parent = new Node({type: 'brace'});\n *     utils.addOpen(parent, Node);\n *     console.log(parent.nodes[0]):\n *     // { type: 'brace.open', val: '' };\n *\n *     // push the parent \"brace\" node onto the stack\n *     this.push(parent);\n *\n *     // return the parent node, so it's also added to the AST\n *     return brace;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created opening node.\n * @api public\n */\n\nutils.addOpen = function(node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var open = new Node({ type: node.type + '.open', val: val});\n  var unshift = node.unshift || node.unshiftNode;\n  if (typeof unshift === 'function') {\n    unshift.call(node, open);\n  } else {\n    utils.unshiftNode(node, open);\n  }\n  return open;\n};\n\n/**\n * Push a `*.close` node onto `node.nodes`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * snapdragon.parser.set('brace', function(node) {\n *   var match = this.match(/^}/);\n *   if (match) {\n *     var parent = this.parent();\n *     if (parent.type !== 'brace') {\n *       throw new Error('missing opening: ' + '}');\n *     }\n *\n *     utils.addClose(parent, Node);\n *     console.log(parent.nodes[parent.nodes.length - 1]):\n *     // { type: 'brace.close', val: '' };\n *\n *     // no need to return a node, since the parent\n *     // was already added to the AST\n *     return;\n *   }\n * });\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the created closing node.\n * @api public\n */\n\nutils.addClose = function(node, Node, val, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  if (typeof val === 'function') {\n    filter = val;\n    val = '';\n  }\n\n  if (typeof filter === 'function' && !filter(node)) return;\n  var close = new Node({ type: node.type + '.close', val: val});\n  var push = node.push || node.pushNode;\n  if (typeof push === 'function') {\n    push.call(node, close);\n  } else {\n    utils.pushNode(node, close);\n  }\n  return close;\n};\n\n/**\n * Wraps the given `node` with `*.open` and `*.close` nodes.\n *\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `Node` (required) Node constructor function from [snapdragon-node][].\n * @param {Function} `filter` Optionaly specify a filter function to exclude the node.\n * @return {Object} Returns the node\n * @api public\n */\n\nutils.wrapNodes = function(node, Node, filter) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isFunction(Node), 'expected Node to be a constructor function');\n\n  utils.addOpen(node, Node, filter);\n  utils.addClose(node, Node, filter);\n  return node;\n};\n\n/**\n * Push the given `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.pushNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object} Returns the child node\n * @api public\n */\n\nutils.pushNode = function(parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.push(node);\n  return node;\n};\n\n/**\n * Unshift `node` onto `parent.nodes`, and set `parent` as `node.parent.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * var node = new Node({type: 'bar'});\n * utils.unshiftNode(parent, node);\n * console.log(parent.nodes[0].type) // 'bar'\n * console.log(node.parent.type) // 'foo'\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {undefined}\n * @api public\n */\n\nutils.unshiftNode = function(parent, node) {\n  assert(utils.isNode(parent), 'expected parent node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  node.define('parent', parent);\n  parent.nodes = parent.nodes || [];\n  parent.nodes.unshift(node);\n};\n\n/**\n * Pop the last `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.popNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.popNode = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (typeof node.pop === 'function') {\n    return node.pop();\n  }\n  return node.nodes && node.nodes.pop();\n};\n\n/**\n * Shift the first `node` off of `parent.nodes`. The advantage of\n * using this method is that it checks for `node.nodes` and works\n * with any version of `snapdragon-node`.\n *\n * ```js\n * var parent = new Node({type: 'foo'});\n * utils.pushNode(parent, new Node({type: 'foo'}));\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.shiftNode(parent);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Number|Undefined} Returns the length of `node.nodes` or undefined.\n * @api public\n */\n\nutils.shiftNode = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (typeof node.shift === 'function') {\n    return node.shift();\n  }\n  return node.nodes && node.nodes.shift();\n};\n\n/**\n * Remove the specified `node` from `parent.nodes`.\n *\n * ```js\n * var parent = new Node({type: 'abc'});\n * var foo = new Node({type: 'foo'});\n * utils.pushNode(parent, foo);\n * utils.pushNode(parent, new Node({type: 'bar'}));\n * utils.pushNode(parent, new Node({type: 'baz'}));\n * console.log(parent.nodes.length); //=> 3\n * utils.removeNode(parent, foo);\n * console.log(parent.nodes.length); //=> 2\n * ```\n * @param {Object} `parent`\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Object|undefined} Returns the removed node, if successful, or undefined if it does not exist on `parent.nodes`.\n * @api public\n */\n\nutils.removeNode = function(parent, node) {\n  assert(utils.isNode(parent), 'expected parent.node to be an instance of Node');\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!parent.nodes) {\n    return null;\n  }\n\n  if (typeof parent.remove === 'function') {\n    return parent.remove(node);\n  }\n\n  var idx = parent.nodes.indexOf(node);\n  if (idx !== -1) {\n    return parent.nodes.splice(idx, 1);\n  }\n};\n\n/**\n * Returns true if `node.type` matches the given `type`. Throws a\n * `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({type: 'foo'});\n * console.log(utils.isType(node, 'foo')); // false\n * console.log(utils.isType(node, 'bar')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isType = function(node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  switch (typeOf(type)) {\n    case 'array':\n      var types = type.slice();\n      for (var i = 0; i < types.length; i++) {\n        if (utils.isType(node, types[i])) {\n          return true;\n        }\n      }\n      return false;\n    case 'string':\n      return node.type === type;\n    case 'regexp':\n      return type.test(node.type);\n    default: {\n      throw new TypeError('expected \"type\" to be an array, string or regexp');\n    }\n  }\n};\n\n/**\n * Returns true if the given `node` has the given `type` in `node.nodes`.\n * Throws a `TypeError` if `node` is not an instance of `Node`.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'bar'}),\n *     new Node({type: 'baz'})\n *   ]\n * });\n * console.log(utils.hasType(node, 'xyz')); // false\n * console.log(utils.hasType(node, 'baz')); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.hasType = function(node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  if (!Array.isArray(node.nodes)) return false;\n  for (var i = 0; i < node.nodes.length; i++) {\n    if (utils.isType(node.nodes[i], type)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns the first node from `node.nodes` of the given `type`\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var textNode = utils.firstOfType(node.nodes, 'text');\n * console.log(textNode.val);\n * //=> 'abc'\n * ```\n * @param {Array} `nodes`\n * @param {String} `type`\n * @return {Object|undefined} Returns the first matching node or undefined.\n * @api public\n */\n\nutils.firstOfType = function(nodes, type) {\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (utils.isType(node, type)) {\n      return node;\n    }\n  }\n};\n\n/**\n * Returns the node at the specified index, or the first node of the\n * given `type` from `node.nodes`.\n *\n * ```js\n * var node = new Node({\n *   type: 'foo',\n *   nodes: [\n *     new Node({type: 'text', val: 'abc'}),\n *     new Node({type: 'text', val: 'xyz'})\n *   ]\n * });\n *\n * var nodeOne = utils.findNode(node.nodes, 'text');\n * console.log(nodeOne.val);\n * //=> 'abc'\n *\n * var nodeTwo = utils.findNode(node.nodes, 1);\n * console.log(nodeTwo.val);\n * //=> 'xyz'\n * ```\n *\n * @param {Array} `nodes`\n * @param {String|Number} `type` Node type or index.\n * @return {Object} Returns a node or undefined.\n * @api public\n */\n\nutils.findNode = function(nodes, type) {\n  if (!Array.isArray(nodes)) {\n    return null;\n  }\n  if (typeof type === 'number') {\n    return nodes[type];\n  }\n  return utils.firstOfType(nodes, type);\n};\n\n/**\n * Returns true if the given node is an \"*.open\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isOpen(brace)); // false\n * console.log(utils.isOpen(open)); // true\n * console.log(utils.isOpen(close)); // false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isOpen = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-5) === '.open';\n};\n\n/**\n * Returns true if the given node is a \"*.close\" node.\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n *\n * console.log(utils.isClose(brace)); // false\n * console.log(utils.isClose(open)); // false\n * console.log(utils.isClose(close)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.isClose = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  return node.type.slice(-6) === '.close';\n};\n\n/**\n * Returns true if `node.nodes` **has** an `.open` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.hasOpen(brace)); // false\n *\n * brace.pushNode(open);\n * console.log(utils.hasOpen(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpen = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var first = node.first || node.nodes ? node.nodes[0] : null;\n  if (utils.isNode(first)) {\n    return first.type === node.type + '.open';\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` **has** a `.close` node\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(close);\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasClose = function(node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  var last = node.last || node.nodes ? node.nodes[node.nodes.length - 1] : null;\n  if (utils.isNode(last)) {\n    return last.type === node.type + '.close';\n  }\n  return false;\n};\n\n/**\n * Returns true if `node.nodes` has both `.open` and `.close` nodes\n *\n * ```js\n * var Node = require('snapdragon-node');\n * var brace = new Node({\n *   type: 'brace',\n *   nodes: []\n * });\n *\n * var open = new Node({type: 'brace.open'});\n * var close = new Node({type: 'brace.close'});\n * console.log(utils.hasOpen(brace)); // false\n * console.log(utils.hasClose(brace)); // false\n *\n * brace.pushNode(open);\n * brace.pushNode(close);\n * console.log(utils.hasOpen(brace)); // true\n * console.log(utils.hasClose(brace)); // true\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Boolean}\n * @api public\n */\n\nutils.hasOpenAndClose = function(node) {\n  return utils.hasOpen(node) && utils.hasClose(node);\n};\n\n/**\n * Push the given `node` onto the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.addType = function(state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  var type = node.parent\n    ? node.parent.type\n    : node.type.replace(/\\.open$/, '');\n\n  if (!state.hasOwnProperty('inside')) {\n    state.inside = {};\n  }\n  if (!state.inside.hasOwnProperty(type)) {\n    state.inside[type] = [];\n  }\n\n  var arr = state.inside[type];\n  arr.push(node);\n  return arr;\n};\n\n/**\n * Remove the given `node` from the `state.inside` array for the\n * given type. This array is used as a specialized \"stack\" for\n * only the given `node.type`.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * utils.addType(state, node);\n * console.log(state.inside);\n * //=> { brace: [{type: 'brace'}] }\n * utils.removeType(state, node);\n * //=> { brace: [] }\n * ```\n * @param {Object} `state` The `compiler.state` object or custom state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @return {Array} Returns the `state.inside` stack for the given type.\n * @api public\n */\n\nutils.removeType = function(state, node) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  var type = node.parent\n    ? node.parent.type\n    : node.type.replace(/\\.close$/, '');\n\n  if (state.inside.hasOwnProperty(type)) {\n    return state.inside[type].pop();\n  }\n};\n\n/**\n * Returns true if `node.val` is an empty string, or `node.nodes` does\n * not contain any non-empty text nodes.\n *\n * ```js\n * var node = new Node({type: 'text'});\n * utils.isEmpty(node); //=> true\n * node.val = 'foo';\n * utils.isEmpty(node); //=> false\n * ```\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {Function} `fn`\n * @return {Boolean}\n * @api public\n */\n\nutils.isEmpty = function(node, fn) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n\n  if (!Array.isArray(node.nodes)) {\n    if (node.type !== 'text') {\n      return true;\n    }\n    if (typeof fn === 'function') {\n      return fn(node, node.parent);\n    }\n    return !utils.trim(node.val);\n  }\n\n  for (var i = 0; i < node.nodes.length; i++) {\n    var child = node.nodes[i];\n    if (utils.isOpen(child) || utils.isClose(child)) {\n      continue;\n    }\n    if (!utils.isEmpty(child, fn)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Returns true if the `state.inside` stack for the given type exists\n * and has one or more nodes on it.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * utils.addType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> true\n * utils.removeType(state, node);\n * console.log(utils.isInsideType(state, 'brace')); //=> false\n * ```\n * @param {Object} `state`\n * @param {String} `type`\n * @return {Boolean}\n * @api public\n */\n\nutils.isInsideType = function(state, type) {\n  assert(isObject(state), 'expected state to be an object');\n  assert(isString(type), 'expected type to be a string');\n\n  if (!state.hasOwnProperty('inside')) {\n    return false;\n  }\n\n  if (!state.inside.hasOwnProperty(type)) {\n    return false;\n  }\n\n  return state.inside[type].length > 0;\n};\n\n/**\n * Returns true if `node` is either a child or grand-child of the given `type`,\n * or `state.inside[type]` is a non-empty array.\n *\n * ```js\n * var state = { inside: {}};\n * var node = new Node({type: 'brace'});\n * var open = new Node({type: 'brace.open'});\n * console.log(utils.isInside(state, open, 'brace')); //=> false\n * utils.pushNode(node, open);\n * console.log(utils.isInside(state, open, 'brace')); //=> true\n * ```\n * @param {Object} `state` Either the `compiler.state` object, if it exists, or a user-supplied state object.\n * @param {Object} `node` Instance of [snapdragon-node][]\n * @param {String} `type` The `node.type` to check for.\n * @return {Boolean}\n * @api public\n */\n\nutils.isInside = function(state, node, type) {\n  assert(utils.isNode(node), 'expected node to be an instance of Node');\n  assert(isObject(state), 'expected state to be an object');\n\n  if (Array.isArray(type)) {\n    for (var i = 0; i < type.length; i++) {\n      if (utils.isInside(state, node, type[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var parent = node.parent;\n  if (typeof type === 'string') {\n    return (parent && parent.type === type) || utils.isInsideType(state, type);\n  }\n\n  if (typeOf(type) === 'regexp') {\n    if (parent && parent.type && type.test(parent.type)) {\n      return true;\n    }\n\n    var keys = Object.keys(state.inside);\n    var len = keys.length;\n    var idx = -1;\n    while (++idx < len) {\n      var key = keys[idx];\n      var val = state.inside[key];\n\n      if (Array.isArray(val) && val.length !== 0 && type.test(key)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Get the last `n` element from the given `array`. Used for getting\n * a node from `node.nodes.`\n *\n * @param {Array} `array`\n * @param {Number} `n`\n * @return {undefined}\n * @api public\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Cast the given `val` to an array.\n *\n * ```js\n * console.log(utils.arrayify(''));\n * //=> []\n * console.log(utils.arrayify('foo'));\n * //=> ['foo']\n * console.log(utils.arrayify(['foo']));\n * //=> ['foo']\n * ```\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === 'string' && val !== '') {\n    return [val];\n  }\n  if (!Array.isArray(val)) {\n    return [];\n  }\n  return val;\n};\n\n/**\n * Convert the given `val` to a string by joining with `,`. Useful\n * for creating a cheerio/CSS/DOM-style selector from a list of strings.\n *\n * @param {any} `val`\n * @return {Array}\n * @api public\n */\n\nutils.stringify = function(val) {\n  return utils.arrayify(val).join(',');\n};\n\n/**\n * Ensure that the given value is a string and call `.trim()` on it,\n * or return an empty string.\n *\n * @param {String} `str`\n * @return {String}\n * @api public\n */\n\nutils.trim = function(str) {\n  return typeof str === 'string' ? str.trim() : '';\n};\n\n/**\n * Return true if val is an object\n */\n\nfunction isObject(val) {\n  return typeOf(val) === 'object';\n}\n\n/**\n * Return true if val is a string\n */\n\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Return true if val is a function\n */\n\nfunction isFunction(val) {\n  return typeof val === 'function';\n}\n\n/**\n * Return true if val is an array\n */\n\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Shim to ensure the `.append` methods work with any version of snapdragon\n */\n\nfunction append(compiler, val, node) {\n  if (typeof compiler.append !== 'function') {\n    return compiler.emit(val, node);\n  }\n  return compiler.append(val, node);\n}\n\n/**\n * Simplified assertion. Throws an error is `val` is falsey.\n */\n\nfunction assert(val, message) {\n  if (!val) throw new Error(message);\n}\n"]},"metadata":{},"sourceType":"script"}