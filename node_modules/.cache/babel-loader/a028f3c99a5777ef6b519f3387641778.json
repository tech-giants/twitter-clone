{"ast":null,"code":"'use strict';\n\nvar safe = require('safe-regex');\n\nvar define = require('define-property');\n\nvar extend = require('extend-shallow');\n\nvar not = require('regex-not');\n\nvar MAX_LENGTH = 1024 * 64;\n/**\n * Session cache\n */\n\nvar cache = {};\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nmodule.exports = function (patterns, options) {\n  if (!Array.isArray(patterns)) {\n    return makeRe(patterns, options);\n  }\n\n  return makeRe(patterns.join('|'), options);\n};\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\n\nfunction makeRe(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  var key = pattern; // do this before shallow cloning options, it's a lot faster\n\n  if (!options || options && options.cache !== false) {\n    key = createKey(pattern, options);\n\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n  }\n\n  var opts = extend({}, options);\n\n  if (opts.contains === true) {\n    if (opts.negate === true) {\n      opts.strictNegate = false;\n    } else {\n      opts.strict = false;\n    }\n  }\n\n  if (opts.strict === false) {\n    opts.strictOpen = false;\n    opts.strictClose = false;\n  }\n\n  var open = opts.strictOpen !== false ? '^' : '';\n  var close = opts.strictClose !== false ? '$' : '';\n  var flags = opts.flags || '';\n  var regex;\n\n  if (opts.nocase === true && !/i/.test(flags)) {\n    flags += 'i';\n  }\n\n  try {\n    if (opts.negate || typeof opts.strictNegate === 'boolean') {\n      pattern = not.create(pattern, opts);\n    }\n\n    var str = open + '(?:' + pattern + ')' + close;\n    regex = new RegExp(str, flags);\n\n    if (opts.safe === true && safe(regex) === false) {\n      throw new Error('potentially unsafe regular expression: ' + regex.source);\n    }\n  } catch (err) {\n    if (opts.strictErrors === true || opts.safe === true) {\n      err.key = key;\n      err.pattern = pattern;\n      err.originalOptions = options;\n      err.createdOptions = opts;\n      throw err;\n    }\n\n    try {\n      regex = new RegExp('^' + pattern.replace(/(\\W)/g, '\\\\$1') + '$');\n    } catch (err) {\n      regex = /.^/; //<= match nothing\n    }\n  }\n\n  if (opts.cache !== false) {\n    memoize(regex, key, pattern, opts);\n  }\n\n  return regex;\n}\n/**\n * Memoize generated regex. This can result in dramatic speed improvements\n * and simplify debugging by adding options and pattern to the regex. It can be\n * disabled by passing setting `options.cache` to false.\n */\n\n\nfunction memoize(regex, key, pattern, options) {\n  define(regex, 'cached', true);\n  define(regex, 'pattern', pattern);\n  define(regex, 'options', options);\n  define(regex, 'key', key);\n  cache[key] = regex;\n}\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\n\nfunction createKey(pattern, options) {\n  if (!options) return pattern;\n  var key = pattern;\n\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n\n  return key;\n}\n/**\n * Expose `makeRe`\n */\n\n\nmodule.exports.makeRe = makeRe;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/to-regex/index.js"],"names":["safe","require","define","extend","not","MAX_LENGTH","cache","module","exports","patterns","options","Array","isArray","makeRe","join","pattern","RegExp","TypeError","length","Error","key","createKey","hasOwnProperty","opts","contains","negate","strictNegate","strict","strictOpen","strictClose","open","close","flags","regex","nocase","test","create","str","source","err","strictErrors","originalOptions","createdOptions","replace","memoize","prop","String"],"mappings":"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","sourcesContent":["'use strict';\n\nvar safe = require('safe-regex');\nvar define = require('define-property');\nvar extend = require('extend-shallow');\nvar not = require('regex-not');\nvar MAX_LENGTH = 1024 * 64;\n\n/**\n * Session cache\n */\n\nvar cache = {};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nmodule.exports = function(patterns, options) {\n  if (!Array.isArray(patterns)) {\n    return makeRe(patterns, options);\n  }\n  return makeRe(patterns.join('|'), options);\n};\n\n/**\n * Create a regular expression from the given `pattern` string.\n *\n * @param {String|RegExp} `pattern` Pattern can be a string or regular expression.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\nfunction makeRe(pattern, options) {\n  if (pattern instanceof RegExp) {\n    return pattern;\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('expected a string');\n  }\n\n  if (pattern.length > MAX_LENGTH) {\n    throw new Error('expected pattern to be less than ' + MAX_LENGTH + ' characters');\n  }\n\n  var key = pattern;\n  // do this before shallow cloning options, it's a lot faster\n  if (!options || (options && options.cache !== false)) {\n    key = createKey(pattern, options);\n\n    if (cache.hasOwnProperty(key)) {\n      return cache[key];\n    }\n  }\n\n  var opts = extend({}, options);\n  if (opts.contains === true) {\n    if (opts.negate === true) {\n      opts.strictNegate = false;\n    } else {\n      opts.strict = false;\n    }\n  }\n\n  if (opts.strict === false) {\n    opts.strictOpen = false;\n    opts.strictClose = false;\n  }\n\n  var open = opts.strictOpen !== false ? '^' : '';\n  var close = opts.strictClose !== false ? '$' : '';\n  var flags = opts.flags || '';\n  var regex;\n\n  if (opts.nocase === true && !/i/.test(flags)) {\n    flags += 'i';\n  }\n\n  try {\n    if (opts.negate || typeof opts.strictNegate === 'boolean') {\n      pattern = not.create(pattern, opts);\n    }\n\n    var str = open + '(?:' + pattern + ')' + close;\n    regex = new RegExp(str, flags);\n\n    if (opts.safe === true && safe(regex) === false) {\n      throw new Error('potentially unsafe regular expression: ' + regex.source);\n    }\n\n  } catch (err) {\n    if (opts.strictErrors === true || opts.safe === true) {\n      err.key = key;\n      err.pattern = pattern;\n      err.originalOptions = options;\n      err.createdOptions = opts;\n      throw err;\n    }\n\n    try {\n      regex = new RegExp('^' + pattern.replace(/(\\W)/g, '\\\\$1') + '$');\n    } catch (err) {\n      regex = /.^/; //<= match nothing\n    }\n  }\n\n  if (opts.cache !== false) {\n    memoize(regex, key, pattern, opts);\n  }\n  return regex;\n}\n\n/**\n * Memoize generated regex. This can result in dramatic speed improvements\n * and simplify debugging by adding options and pattern to the regex. It can be\n * disabled by passing setting `options.cache` to false.\n */\n\nfunction memoize(regex, key, pattern, options) {\n  define(regex, 'cached', true);\n  define(regex, 'pattern', pattern);\n  define(regex, 'options', options);\n  define(regex, 'key', key);\n  cache[key] = regex;\n}\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nfunction createKey(pattern, options) {\n  if (!options) return pattern;\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n  return key;\n}\n\n/**\n * Expose `makeRe`\n */\n\nmodule.exports.makeRe = makeRe;\n"]},"metadata":{},"sourceType":"script"}