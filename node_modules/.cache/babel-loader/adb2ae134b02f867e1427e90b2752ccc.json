{"ast":null,"code":"import { parse32F, parse64F, parse32I, parse64I, parseU32, isNanLiteral, isInfLiteral } from \"@webassemblyjs/wast-parser\";\nimport { longNumberLiteral, floatLiteral, numberLiteral, instr } from \"./nodes\";\nexport function numberLiteralFromRaw(rawValue) {\n  var instructionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"i32\";\n  var original = rawValue; // Remove numeric separators _\n\n  if (typeof rawValue === \"string\") {\n    rawValue = rawValue.replace(/_/g, \"\");\n  }\n\n  if (typeof rawValue === \"number\") {\n    return numberLiteral(rawValue, String(original));\n  } else {\n    switch (instructionType) {\n      case \"i32\":\n        {\n          return numberLiteral(parse32I(rawValue), String(original));\n        }\n\n      case \"u32\":\n        {\n          return numberLiteral(parseU32(rawValue), String(original));\n        }\n\n      case \"i64\":\n        {\n          return longNumberLiteral(parse64I(rawValue), String(original));\n        }\n\n      case \"f32\":\n        {\n          return floatLiteral(parse32F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n      // f64\n\n      default:\n        {\n          return floatLiteral(parse64F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n    }\n  }\n}\nexport function instruction(id) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var namedArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return instr(id, undefined, args, namedArgs);\n}\nexport function objectInstruction(id, object) {\n  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var namedArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return instr(id, object, args, namedArgs);\n}\n/**\n * Decorators\n */\n\nexport function withLoc(n, end, start) {\n  var loc = {\n    start: start,\n    end: end\n  };\n  n.loc = loc;\n  return n;\n}\nexport function withRaw(n, raw) {\n  n.raw = raw;\n  return n;\n}\nexport function funcParam(valtype, id) {\n  return {\n    id: id,\n    valtype: valtype\n  };\n}\nexport function indexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, \"u32\");\n  return x;\n}\nexport function memIndexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, \"u32\");\n  return x;\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/ast/esm/node-helpers.js"],"names":["parse32F","parse64F","parse32I","parse64I","parseU32","isNanLiteral","isInfLiteral","longNumberLiteral","floatLiteral","numberLiteral","instr","numberLiteralFromRaw","rawValue","instructionType","arguments","length","undefined","original","replace","String","instruction","id","args","namedArgs","objectInstruction","object","withLoc","n","end","start","loc","withRaw","raw","funcParam","valtype","indexLiteral","value","x","memIndexLiteral"],"mappings":"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","sourcesContent":["import { parse32F, parse64F, parse32I, parse64I, parseU32, isNanLiteral, isInfLiteral } from \"@webassemblyjs/wast-parser\";\nimport { longNumberLiteral, floatLiteral, numberLiteral, instr } from \"./nodes\";\nexport function numberLiteralFromRaw(rawValue) {\n  var instructionType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"i32\";\n  var original = rawValue; // Remove numeric separators _\n\n  if (typeof rawValue === \"string\") {\n    rawValue = rawValue.replace(/_/g, \"\");\n  }\n\n  if (typeof rawValue === \"number\") {\n    return numberLiteral(rawValue, String(original));\n  } else {\n    switch (instructionType) {\n      case \"i32\":\n        {\n          return numberLiteral(parse32I(rawValue), String(original));\n        }\n\n      case \"u32\":\n        {\n          return numberLiteral(parseU32(rawValue), String(original));\n        }\n\n      case \"i64\":\n        {\n          return longNumberLiteral(parse64I(rawValue), String(original));\n        }\n\n      case \"f32\":\n        {\n          return floatLiteral(parse32F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n      // f64\n\n      default:\n        {\n          return floatLiteral(parse64F(rawValue), isNanLiteral(rawValue), isInfLiteral(rawValue), String(original));\n        }\n    }\n  }\n}\nexport function instruction(id) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var namedArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return instr(id, undefined, args, namedArgs);\n}\nexport function objectInstruction(id, object) {\n  var args = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var namedArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return instr(id, object, args, namedArgs);\n}\n/**\n * Decorators\n */\n\nexport function withLoc(n, end, start) {\n  var loc = {\n    start: start,\n    end: end\n  };\n  n.loc = loc;\n  return n;\n}\nexport function withRaw(n, raw) {\n  n.raw = raw;\n  return n;\n}\nexport function funcParam(valtype, id) {\n  return {\n    id: id,\n    valtype: valtype\n  };\n}\nexport function indexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, \"u32\");\n  return x;\n}\nexport function memIndexLiteral(value) {\n  // $FlowIgnore\n  var x = numberLiteralFromRaw(value, \"u32\");\n  return x;\n}"]},"metadata":{},"sourceType":"module"}