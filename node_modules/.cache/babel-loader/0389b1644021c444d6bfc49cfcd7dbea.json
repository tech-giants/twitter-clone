{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n\t*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\n\nconst util = require(\"util\");\n\nconst {\n  CachedSource\n} = require(\"webpack-sources\");\n\nconst {\n  Tapable,\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\n\nconst EntryModuleNotFoundError = require(\"./EntryModuleNotFoundError\");\n\nconst ModuleNotFoundError = require(\"./ModuleNotFoundError\");\n\nconst ModuleDependencyWarning = require(\"./ModuleDependencyWarning\");\n\nconst ModuleDependencyError = require(\"./ModuleDependencyError\");\n\nconst ChunkGroup = require(\"./ChunkGroup\");\n\nconst Chunk = require(\"./Chunk\");\n\nconst Entrypoint = require(\"./Entrypoint\");\n\nconst MainTemplate = require(\"./MainTemplate\");\n\nconst ChunkTemplate = require(\"./ChunkTemplate\");\n\nconst HotUpdateChunkTemplate = require(\"./HotUpdateChunkTemplate\");\n\nconst ModuleTemplate = require(\"./ModuleTemplate\");\n\nconst RuntimeTemplate = require(\"./RuntimeTemplate\");\n\nconst ChunkRenderError = require(\"./ChunkRenderError\");\n\nconst Stats = require(\"./Stats\");\n\nconst Semaphore = require(\"./util/Semaphore\");\n\nconst createHash = require(\"./util/createHash\");\n\nconst SortableSet = require(\"./util/SortableSet\");\n\nconst GraphHelpers = require(\"./GraphHelpers\");\n\nconst ModuleDependency = require(\"./dependencies/ModuleDependency\");\n\nconst compareLocations = require(\"./compareLocations\");\n\nconst {\n  Logger,\n  LogType\n} = require(\"./logging/Logger\");\n\nconst ErrorHelpers = require(\"./ErrorHelpers\");\n\nconst buildChunkGraph = require(\"./buildChunkGraph\");\n\nconst WebpackError = require(\"./WebpackError\");\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n\n/** @typedef {import(\"./dependencies/SingleEntryDependency\")} SingleEntryDependency */\n\n/** @typedef {import(\"./dependencies/MultiEntryDependency\")} MultiEntryDependency */\n\n/** @typedef {import(\"./dependencies/DllEntryDependency\")} DllEntryDependency */\n\n/** @typedef {import(\"./dependencies/DependencyReference\")} DependencyReference */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n// TODO use @callback\n\n/** @typedef {{[assetName: string]: Source}} CompilationAssets */\n\n/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */\n\n/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */\n\n/** @typedef {(module: Module) => void} OnModuleCallback */\n\n/** @typedef {(err?: Error|null) => void} Callback */\n\n/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */\n\n/** @typedef {new (...args: any[]) => Dependency} DepConstructor */\n\n/** @typedef {{apply: () => void}} Plugin */\n\n/**\n * @typedef {Object} ModuleFactoryCreateDataContextInfo\n * @property {string} issuer\n * @property {string} compiler\n */\n\n/**\n * @typedef {Object} ModuleFactoryCreateData\n * @property {ModuleFactoryCreateDataContextInfo} contextInfo\n * @property {any=} resolveOptions\n * @property {string} context\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} ModuleFactory\n * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create\n */\n\n/**\n * @typedef {Object} SortedDependency\n * @property {ModuleFactory} factory\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} DependenciesBlockLike\n * @property {Dependency[]} dependencies\n * @property {AsyncDependenciesBlock[]} blocks\n * @property {DependenciesBlockVariable[]} variables\n */\n\n/**\n * @typedef {Object} LogEntry\n * @property {string} type\n * @property {any[]} args\n * @property {number} time\n * @property {string[]=} trace\n */\n\n/**\n * @typedef {Object} AssetInfo\n * @property {boolean=} immutable true, if the asset can be long term cached forever (contains a hash)\n * @property {number=} size size in bytes, only set after asset has been emitted\n * @property {boolean=} development true, when asset is only used for development and doesn't count towards user-facing assets\n * @property {boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)\n */\n\n/**\n * @typedef {Object} Asset\n * @property {string} name the filename of the asset\n * @property {Source} source source of the asset\n * @property {AssetInfo} info info about the asset\n */\n\n/**\n * @param {Chunk} a first chunk to sort by id\n * @param {Chunk} b second chunk to sort by id\n * @returns {-1|0|1} sort value\n */\n\n\nconst byId = (a, b) => {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  return 0;\n};\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nconst byIdOrIdentifier = (a, b) => {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  const identA = a.identifier();\n  const identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nconst byIndexOrIdentifier = (a, b) => {\n  if (a.index < b.index) return -1;\n  if (a.index > b.index) return 1;\n  const identA = a.identifier();\n  const identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n/**\n * @param {Compilation} a first compilation to sort by\n * @param {Compilation} b second compilation to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nconst byNameOrHash = (a, b) => {\n  if (a.name < b.name) return -1;\n  if (a.name > b.name) return 1;\n  if (a.fullHash < b.fullHash) return -1;\n  if (a.fullHash > b.fullHash) return 1;\n  return 0;\n};\n/**\n * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over\n * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements\n * @returns {void}\n */\n\n\nconst iterationBlockVariable = (variables, fn) => {\n  for (let indexVariable = 0; indexVariable < variables.length; indexVariable++) {\n    const varDep = variables[indexVariable].dependencies;\n\n    for (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) {\n      fn(varDep[indexVDep]);\n    }\n  }\n};\n/**\n * @template T\n * @param {T[]} arr array of elements to iterate over\n * @param {function(T): void} fn callback applied to each element\n * @returns {void}\n */\n\n\nconst iterationOfArrayCallback = (arr, fn) => {\n  for (let index = 0; index < arr.length; index++) {\n    fn(arr[index]);\n  }\n};\n/**\n * @template T\n * @param {Set<T>} set set to add items to\n * @param {Set<T>} otherSet set to add items from\n * @returns {void}\n */\n\n\nconst addAllToSet = (set, otherSet) => {\n  for (const item of otherSet) {\n    set.add(item);\n  }\n};\n/**\n * @param {Source} a a source\n * @param {Source} b another source\n * @returns {boolean} true, when both sources are equal\n */\n\n\nconst isSourceEqual = (a, b) => {\n  if (a === b) return true; // TODO webpack 5: check .buffer() instead, it's called anyway during emit\n\n  /** @type {Buffer|string} */\n\n  let aSource = a.source();\n  /** @type {Buffer|string} */\n\n  let bSource = b.source();\n  if (aSource === bSource) return true;\n  if (typeof aSource === \"string\" && typeof bSource === \"string\") return false;\n  if (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, \"utf-8\");\n  if (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, \"utf-8\");\n  return aSource.equals(bSource);\n};\n\nclass Compilation extends Tapable {\n  /**\n   * Creates an instance of Compilation.\n   * @param {Compiler} compiler the compiler which created the compilation\n   */\n  constructor(compiler) {\n    super();\n    this.hooks = {\n      /** @type {SyncHook<Module>} */\n      buildModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Module>} */\n      rebuildModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Module, Error>} */\n      failedModule: new SyncHook([\"module\", \"error\"]),\n\n      /** @type {SyncHook<Module>} */\n      succeedModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Dependency, string>} */\n      addEntry: new SyncHook([\"entry\", \"name\"]),\n\n      /** @type {SyncHook<Dependency, string, Error>} */\n      failedEntry: new SyncHook([\"entry\", \"name\", \"error\"]),\n\n      /** @type {SyncHook<Dependency, string, Module>} */\n      succeedEntry: new SyncHook([\"entry\", \"name\", \"module\"]),\n\n      /** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */\n      dependencyReference: new SyncWaterfallHook([\"dependencyReference\", \"dependency\", \"module\"]),\n\n      /** @type {AsyncSeriesHook<Module[]>} */\n      finishModules: new AsyncSeriesHook([\"modules\"]),\n\n      /** @type {SyncHook<Module>} */\n      finishRebuildingModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook} */\n      unseal: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      seal: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      beforeChunks: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterChunks: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesBasic: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependencies: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesAdvanced: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      afterOptimizeDependencies: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook} */\n      optimize: new SyncHook([]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesBasic: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModules: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesAdvanced: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModules: new SyncHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksBasic: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunks: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksAdvanced: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncHook<Chunk[], ChunkGroup[]>} */\n      afterOptimizeChunks: new SyncHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {AsyncSeriesHook<Chunk[], Module[]>} */\n      optimizeTree: new AsyncSeriesHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeTree: new SyncHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesBasic: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModules: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesAdvanced: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeChunkModules: new SyncHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook} */\n      shouldRecord: new SyncBailHook([]),\n\n      /** @type {SyncHook<Module[], any>} */\n      reviveModules: new SyncHook([\"modules\", \"records\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleOrder: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      advancedOptimizeModuleOrder: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      beforeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      moduleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Chunk[], any>} */\n      reviveChunks: new SyncHook([\"chunks\", \"records\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkOrder: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      beforeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Module[], any>} */\n      recordModules: new SyncHook([\"modules\", \"records\"]),\n\n      /** @type {SyncHook<Chunk[], any>} */\n      recordChunks: new SyncHook([\"chunks\", \"records\"]),\n\n      /** @type {SyncHook} */\n      beforeHash: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk>} */\n      contentHash: new SyncHook([\"chunk\"]),\n\n      /** @type {SyncHook} */\n      afterHash: new SyncHook([]),\n\n      /** @type {SyncHook<any>} */\n      recordHash: new SyncHook([\"records\"]),\n\n      /** @type {SyncHook<Compilation, any>} */\n      record: new SyncHook([\"compilation\", \"records\"]),\n\n      /** @type {SyncHook} */\n      beforeModuleAssets: new SyncHook([]),\n\n      /** @type {SyncBailHook} */\n      shouldGenerateChunkAssets: new SyncBailHook([]),\n\n      /** @type {SyncHook} */\n      beforeChunkAssets: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      additionalChunkAssets: new SyncHook([\"chunks\"]),\n\n      /** @type {AsyncSeriesHook} */\n      additionalAssets: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<Chunk[]>} */\n      optimizeChunkAssets: new AsyncSeriesHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkAssets: new SyncHook([\"chunks\"]),\n\n      /** @type {AsyncSeriesHook<CompilationAssets>} */\n      optimizeAssets: new AsyncSeriesHook([\"assets\"]),\n\n      /** @type {SyncHook<CompilationAssets>} */\n      afterOptimizeAssets: new SyncHook([\"assets\"]),\n\n      /** @type {SyncBailHook} */\n      needAdditionalSeal: new SyncBailHook([]),\n\n      /** @type {AsyncSeriesHook} */\n      afterSeal: new AsyncSeriesHook([]),\n\n      /** @type {SyncHook<Chunk, Hash>} */\n      chunkHash: new SyncHook([\"chunk\", \"chunkHash\"]),\n\n      /** @type {SyncHook<Module, string>} */\n      moduleAsset: new SyncHook([\"module\", \"filename\"]),\n\n      /** @type {SyncHook<Chunk, string>} */\n      chunkAsset: new SyncHook([\"chunk\", \"filename\"]),\n\n      /** @type {SyncWaterfallHook<string, TODO>} */\n      assetPath: new SyncWaterfallHook([\"filename\", \"data\"]),\n      // TODO MainTemplate\n\n      /** @type {SyncBailHook} */\n      needAdditionalPass: new SyncBailHook([]),\n\n      /** @type {SyncHook<Compiler, string, number>} */\n      childCompiler: new SyncHook([\"childCompiler\", \"compilerName\", \"compilerIndex\"]),\n\n      /** @type {SyncBailHook<string, LogEntry>} */\n      log: new SyncBailHook([\"origin\", \"logEntry\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook<object, Module>} */\n      normalModuleLoader: new SyncHook([\"loaderContext\", \"module\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksBasic: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunks: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksAdvanced: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeExtractedChunks: new SyncHook([\"chunks\"])\n    };\n\n    this._pluginCompat.tap(\"Compilation\", options => {\n      switch (options.name) {\n        case \"optimize-tree\":\n        case \"additional-assets\":\n        case \"optimize-chunk-assets\":\n        case \"optimize-assets\":\n        case \"after-seal\":\n          options.async = true;\n          break;\n      }\n    });\n    /** @type {string=} */\n\n\n    this.name = undefined;\n    /** @type {Compiler} */\n\n    this.compiler = compiler;\n    this.resolverFactory = compiler.resolverFactory;\n    this.inputFileSystem = compiler.inputFileSystem;\n    this.requestShortener = compiler.requestShortener;\n    const options = compiler.options;\n    this.options = options;\n    this.outputOptions = options && options.output;\n    /** @type {boolean=} */\n\n    this.bail = options && options.bail;\n    this.profile = options && options.profile;\n    this.performance = options && options.performance;\n    this.mainTemplate = new MainTemplate(this.outputOptions);\n    this.chunkTemplate = new ChunkTemplate(this.outputOptions);\n    this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(this.outputOptions);\n    this.runtimeTemplate = new RuntimeTemplate(this.outputOptions, this.requestShortener);\n    this.moduleTemplates = {\n      javascript: new ModuleTemplate(this.runtimeTemplate, \"javascript\"),\n      webassembly: new ModuleTemplate(this.runtimeTemplate, \"webassembly\")\n    };\n    this.semaphore = new Semaphore(options.parallelism || 100);\n    this.entries = [];\n    /** @private @type {{name: string, request: string, module: Module}[]} */\n\n    this._preparedEntrypoints = [];\n    /** @type {Map<string, Entrypoint>} */\n\n    this.entrypoints = new Map();\n    /** @type {Chunk[]} */\n\n    this.chunks = [];\n    /** @type {ChunkGroup[]} */\n\n    this.chunkGroups = [];\n    /** @type {Map<string, ChunkGroup>} */\n\n    this.namedChunkGroups = new Map();\n    /** @type {Map<string, Chunk>} */\n\n    this.namedChunks = new Map();\n    /** @type {Module[]} */\n\n    this.modules = [];\n    /** @private @type {Map<string, Module>} */\n\n    this._modules = new Map();\n    this.cache = null;\n    this.records = null;\n    /** @type {string[]} */\n\n    this.additionalChunkAssets = [];\n    /** @type {CompilationAssets} */\n\n    this.assets = {};\n    /** @type {Map<string, AssetInfo>} */\n\n    this.assetsInfo = new Map();\n    /** @type {WebpackError[]} */\n\n    this.errors = [];\n    /** @type {WebpackError[]} */\n\n    this.warnings = [];\n    /** @type {Compilation[]} */\n\n    this.children = [];\n    /** @type {Map<string, LogEntry[]>} */\n\n    this.logging = new Map();\n    /** @type {Map<DepConstructor, ModuleFactory>} */\n\n    this.dependencyFactories = new Map();\n    /** @type {Map<DepConstructor, DependencyTemplate>} */\n\n    this.dependencyTemplates = new Map(); // TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property\n    // @ts-ignore\n\n    this.dependencyTemplates.set(\"hash\", \"\");\n    this.childrenCounters = {};\n    /** @type {Set<number|string>} */\n\n    this.usedChunkIds = null;\n    /** @type {Set<number>} */\n\n    this.usedModuleIds = null;\n    /** @type {Map<string, number>=} */\n\n    this.fileTimestamps = undefined;\n    /** @type {Map<string, number>=} */\n\n    this.contextTimestamps = undefined;\n    /** @type {Set<string>=} */\n\n    this.compilationDependencies = undefined;\n    /** @private @type {Map<Module, Callback[]>} */\n\n    this._buildingModules = new Map();\n    /** @private @type {Map<Module, Callback[]>} */\n\n    this._rebuildingModules = new Map();\n    /** @type {Set<string>} */\n\n    this.emittedAssets = new Set();\n  }\n\n  getStats() {\n    return new Stats(this);\n  }\n  /**\n   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n   * @returns {Logger} a logger with that name\n   */\n\n\n  getLogger(name) {\n    if (!name) {\n      throw new TypeError(\"Compilation.getLogger(name) called without a name\");\n    }\n    /** @type {LogEntry[] | undefined} */\n\n\n    let logEntries;\n    return new Logger((type, args) => {\n      if (typeof name === \"function\") {\n        name = name();\n\n        if (!name) {\n          throw new TypeError(\"Compilation.getLogger(name) called with a function not returning a name\");\n        }\n      }\n\n      let trace;\n\n      switch (type) {\n        case LogType.warn:\n        case LogType.error:\n        case LogType.trace:\n          trace = ErrorHelpers.cutOffLoaderExecution(new Error(\"Trace\").stack).split(\"\\n\").slice(3);\n          break;\n      }\n      /** @type {LogEntry} */\n\n\n      const logEntry = {\n        time: Date.now(),\n        type,\n        args,\n        trace\n      };\n\n      if (this.hooks.log.call(name, logEntry) === undefined) {\n        if (logEntry.type === LogType.profileEnd) {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          if (typeof console.profileEnd === \"function\") {\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            console.profileEnd(`[${name}] ${logEntry.args[0]}`);\n          }\n        }\n\n        if (logEntries === undefined) {\n          logEntries = this.logging.get(name);\n\n          if (logEntries === undefined) {\n            logEntries = [];\n            this.logging.set(name, logEntries);\n          }\n        }\n\n        logEntries.push(logEntry);\n\n        if (logEntry.type === LogType.profile) {\n          // eslint-disable-next-line node/no-unsupported-features/node-builtins\n          if (typeof console.profile === \"function\") {\n            // eslint-disable-next-line node/no-unsupported-features/node-builtins\n            console.profile(`[${name}] ${logEntry.args[0]}`);\n          }\n        }\n      }\n    });\n  }\n  /**\n   * @typedef {Object} AddModuleResult\n   * @property {Module} module the added or existing module\n   * @property {boolean} issuer was this the first request for this module\n   * @property {boolean} build should the module be build\n   * @property {boolean} dependencies should dependencies be walked\n   */\n\n  /**\n   * @param {Module} module module to be added that was created\n   * @param {any=} cacheGroup cacheGroup it is apart of\n   * @returns {AddModuleResult} returns meta about whether or not the module had built\n   * had an issuer, or any dependnecies\n   */\n\n\n  addModule(module, cacheGroup) {\n    const identifier = module.identifier();\n\n    const alreadyAddedModule = this._modules.get(identifier);\n\n    if (alreadyAddedModule) {\n      return {\n        module: alreadyAddedModule,\n        issuer: false,\n        build: false,\n        dependencies: false\n      };\n    }\n\n    const cacheName = (cacheGroup || \"m\") + identifier;\n\n    if (this.cache && this.cache[cacheName]) {\n      const cacheModule = this.cache[cacheName];\n\n      if (typeof cacheModule.updateCacheModule === \"function\") {\n        cacheModule.updateCacheModule(module);\n      }\n\n      let rebuild = true;\n\n      if (this.fileTimestamps && this.contextTimestamps) {\n        rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);\n      }\n\n      if (!rebuild) {\n        cacheModule.disconnect();\n\n        this._modules.set(identifier, cacheModule);\n\n        this.modules.push(cacheModule);\n\n        for (const err of cacheModule.errors) {\n          this.errors.push(err);\n        }\n\n        for (const err of cacheModule.warnings) {\n          this.warnings.push(err);\n        }\n\n        return {\n          module: cacheModule,\n          issuer: true,\n          build: false,\n          dependencies: true\n        };\n      }\n\n      cacheModule.unbuild();\n      module = cacheModule;\n    }\n\n    this._modules.set(identifier, module);\n\n    if (this.cache) {\n      this.cache[cacheName] = module;\n    }\n\n    this.modules.push(module);\n    return {\n      module: module,\n      issuer: true,\n      build: true,\n      dependencies: true\n    };\n  }\n  /**\n   * Fetches a module from a compilation by its identifier\n   * @param {Module} module the module provided\n   * @returns {Module} the module requested\n   */\n\n\n  getModule(module) {\n    const identifier = module.identifier();\n    return this._modules.get(identifier);\n  }\n  /**\n   * Attempts to search for a module by its identifier\n   * @param {string} identifier identifier (usually path) for module\n   * @returns {Module|undefined} attempt to search for module and return it, else undefined\n   */\n\n\n  findModule(identifier) {\n    return this._modules.get(identifier);\n  }\n  /**\n   * @param {Module} module module with its callback list\n   * @param {Callback} callback the callback function\n   * @returns {void}\n   */\n\n\n  waitForBuildingFinished(module, callback) {\n    let callbackList = this._buildingModules.get(module);\n\n    if (callbackList) {\n      callbackList.push(() => callback());\n    } else {\n      process.nextTick(callback);\n    }\n  }\n  /**\n   * Builds the module object\n   *\n   * @param {Module} module module to be built\n   * @param {boolean} optional optional flag\n   * @param {Module=} origin origin module this module build was requested from\n   * @param {Dependency[]=} dependencies optional dependencies from the module to be built\n   * @param {TODO} thisCallback the callback\n   * @returns {TODO} returns the callback function with results\n   */\n\n\n  buildModule(module, optional, origin, dependencies, thisCallback) {\n    let callbackList = this._buildingModules.get(module);\n\n    if (callbackList) {\n      callbackList.push(thisCallback);\n      return;\n    }\n\n    this._buildingModules.set(module, callbackList = [thisCallback]);\n\n    const callback = err => {\n      this._buildingModules.delete(module);\n\n      for (const cb of callbackList) {\n        cb(err);\n      }\n    };\n\n    this.hooks.buildModule.call(module);\n    module.build(this.options, this, this.resolverFactory.get(\"normal\", module.resolveOptions), this.inputFileSystem, error => {\n      const errors = module.errors;\n\n      for (let indexError = 0; indexError < errors.length; indexError++) {\n        const err = errors[indexError];\n        err.origin = origin;\n        err.dependencies = dependencies;\n\n        if (optional) {\n          this.warnings.push(err);\n        } else {\n          this.errors.push(err);\n        }\n      }\n\n      const warnings = module.warnings;\n\n      for (let indexWarning = 0; indexWarning < warnings.length; indexWarning++) {\n        const war = warnings[indexWarning];\n        war.origin = origin;\n        war.dependencies = dependencies;\n        this.warnings.push(war);\n      }\n\n      const originalMap = module.dependencies.reduce((map, v, i) => {\n        map.set(v, i);\n        return map;\n      }, new Map());\n      module.dependencies.sort((a, b) => {\n        const cmp = compareLocations(a.loc, b.loc);\n        if (cmp) return cmp;\n        return originalMap.get(a) - originalMap.get(b);\n      });\n\n      if (error) {\n        this.hooks.failedModule.call(module, error);\n        return callback(error);\n      }\n\n      this.hooks.succeedModule.call(module);\n      return callback();\n    });\n  }\n  /**\n   * @param {Module} module to be processed for deps\n   * @param {ModuleCallback} callback callback to be triggered\n   * @returns {void}\n   */\n\n\n  processModuleDependencies(module, callback) {\n    const dependencies = new Map();\n\n    const addDependency = dep => {\n      const resourceIdent = dep.getResourceIdentifier();\n\n      if (resourceIdent) {\n        const factory = this.dependencyFactories.get(dep.constructor);\n\n        if (factory === undefined) {\n          throw new Error(`No module factory available for dependency type: ${dep.constructor.name}`);\n        }\n\n        let innerMap = dependencies.get(factory);\n\n        if (innerMap === undefined) {\n          dependencies.set(factory, innerMap = new Map());\n        }\n\n        let list = innerMap.get(resourceIdent);\n        if (list === undefined) innerMap.set(resourceIdent, list = []);\n        list.push(dep);\n      }\n    };\n\n    const addDependenciesBlock = block => {\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, addDependency);\n      }\n\n      if (block.blocks) {\n        iterationOfArrayCallback(block.blocks, addDependenciesBlock);\n      }\n\n      if (block.variables) {\n        iterationBlockVariable(block.variables, addDependency);\n      }\n    };\n\n    try {\n      addDependenciesBlock(module);\n    } catch (e) {\n      callback(e);\n    }\n\n    const sortedDependencies = [];\n\n    for (const pair1 of dependencies) {\n      for (const pair2 of pair1[1]) {\n        sortedDependencies.push({\n          factory: pair1[0],\n          dependencies: pair2[1]\n        });\n      }\n    }\n\n    this.addModuleDependencies(module, sortedDependencies, this.bail, null, true, callback);\n  }\n  /**\n   * @param {Module} module module to add deps to\n   * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through\n   * @param {(boolean|null)=} bail whether to bail or not\n   * @param {TODO} cacheGroup optional cacheGroup\n   * @param {boolean} recursive whether it is recursive traversal\n   * @param {function} callback callback for when dependencies are finished being added\n   * @returns {void}\n   */\n\n\n  addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) {\n    const start = this.profile && Date.now();\n    const currentProfile = this.profile && {};\n    asyncLib.forEach(dependencies, (item, callback) => {\n      const dependencies = item.dependencies;\n\n      const errorAndCallback = err => {\n        err.origin = module;\n        err.dependencies = dependencies;\n        this.errors.push(err);\n\n        if (bail) {\n          callback(err);\n        } else {\n          callback();\n        }\n      };\n\n      const warningAndCallback = err => {\n        err.origin = module;\n        this.warnings.push(err);\n        callback();\n      };\n\n      const semaphore = this.semaphore;\n      semaphore.acquire(() => {\n        const factory = item.factory;\n        factory.create({\n          contextInfo: {\n            issuer: module.nameForCondition && module.nameForCondition(),\n            compiler: this.compiler.name\n          },\n          resolveOptions: module.resolveOptions,\n          context: module.context,\n          dependencies: dependencies\n        }, (err, dependentModule) => {\n          let afterFactory;\n\n          const isOptional = () => {\n            return dependencies.every(d => d.optional);\n          };\n\n          const errorOrWarningAndCallback = err => {\n            if (isOptional()) {\n              return warningAndCallback(err);\n            } else {\n              return errorAndCallback(err);\n            }\n          };\n\n          if (err) {\n            semaphore.release();\n            return errorOrWarningAndCallback(new ModuleNotFoundError(module, err));\n          }\n\n          if (!dependentModule) {\n            semaphore.release();\n            return process.nextTick(callback);\n          }\n\n          if (currentProfile) {\n            afterFactory = Date.now();\n            currentProfile.factory = afterFactory - start;\n          }\n\n          const iterationDependencies = depend => {\n            for (let index = 0; index < depend.length; index++) {\n              const dep = depend[index];\n              dep.module = dependentModule;\n              dependentModule.addReason(module, dep);\n            }\n          };\n\n          const addModuleResult = this.addModule(dependentModule, cacheGroup);\n          dependentModule = addModuleResult.module;\n          iterationDependencies(dependencies);\n\n          const afterBuild = () => {\n            if (recursive && addModuleResult.dependencies) {\n              this.processModuleDependencies(dependentModule, callback);\n            } else {\n              return callback();\n            }\n          };\n\n          if (addModuleResult.issuer) {\n            if (currentProfile) {\n              dependentModule.profile = currentProfile;\n            }\n\n            dependentModule.issuer = module;\n          } else {\n            if (this.profile) {\n              if (module.profile) {\n                const time = Date.now() - start;\n\n                if (!module.profile.dependencies || time > module.profile.dependencies) {\n                  module.profile.dependencies = time;\n                }\n              }\n            }\n          }\n\n          if (addModuleResult.build) {\n            this.buildModule(dependentModule, isOptional(), module, dependencies, err => {\n              if (err) {\n                semaphore.release();\n                return errorOrWarningAndCallback(err);\n              }\n\n              if (currentProfile) {\n                const afterBuilding = Date.now();\n                currentProfile.building = afterBuilding - afterFactory;\n              }\n\n              semaphore.release();\n              afterBuild();\n            });\n          } else {\n            semaphore.release();\n            this.waitForBuildingFinished(dependentModule, afterBuild);\n          }\n        });\n      });\n    }, err => {\n      // In V8, the Error objects keep a reference to the functions on the stack. These warnings &\n      // errors are created inside closures that keep a reference to the Compilation, so errors are\n      // leaking the Compilation object.\n      if (err) {\n        // eslint-disable-next-line no-self-assign\n        err.stack = err.stack;\n        return callback(err);\n      }\n\n      return process.nextTick(callback);\n    });\n  }\n  /**\n   *\n   * @param {string} context context string path\n   * @param {Dependency} dependency dependency used to create Module chain\n   * @param {OnModuleCallback} onModule function invoked on modules creation\n   * @param {ModuleChainCallback} callback callback for when module chain is complete\n   * @returns {void} will throw if dependency instance is not a valid Dependency\n   */\n\n\n  _addModuleChain(context, dependency, onModule, callback) {\n    const start = this.profile && Date.now();\n    const currentProfile = this.profile && {};\n    const errorAndCallback = this.bail ? err => {\n      callback(err);\n    } : err => {\n      err.dependencies = [dependency];\n      this.errors.push(err);\n      callback();\n    };\n\n    if (typeof dependency !== \"object\" || dependency === null || !dependency.constructor) {\n      throw new Error(\"Parameter 'dependency' must be a Dependency\");\n    }\n\n    const Dep = dependency.constructor;\n    const moduleFactory = this.dependencyFactories.get(Dep);\n\n    if (!moduleFactory) {\n      throw new Error(`No dependency factory available for this dependency type: ${dependency.constructor.name}`);\n    }\n\n    this.semaphore.acquire(() => {\n      moduleFactory.create({\n        contextInfo: {\n          issuer: \"\",\n          compiler: this.compiler.name\n        },\n        context: context,\n        dependencies: [dependency]\n      }, (err, module) => {\n        if (err) {\n          this.semaphore.release();\n          return errorAndCallback(new EntryModuleNotFoundError(err));\n        }\n\n        let afterFactory;\n\n        if (currentProfile) {\n          afterFactory = Date.now();\n          currentProfile.factory = afterFactory - start;\n        }\n\n        const addModuleResult = this.addModule(module);\n        module = addModuleResult.module;\n        onModule(module);\n        dependency.module = module;\n        module.addReason(null, dependency);\n\n        const afterBuild = () => {\n          if (addModuleResult.dependencies) {\n            this.processModuleDependencies(module, err => {\n              if (err) return callback(err);\n              callback(null, module);\n            });\n          } else {\n            return callback(null, module);\n          }\n        };\n\n        if (addModuleResult.issuer) {\n          if (currentProfile) {\n            module.profile = currentProfile;\n          }\n        }\n\n        if (addModuleResult.build) {\n          this.buildModule(module, false, null, null, err => {\n            if (err) {\n              this.semaphore.release();\n              return errorAndCallback(err);\n            }\n\n            if (currentProfile) {\n              const afterBuilding = Date.now();\n              currentProfile.building = afterBuilding - afterFactory;\n            }\n\n            this.semaphore.release();\n            afterBuild();\n          });\n        } else {\n          this.semaphore.release();\n          this.waitForBuildingFinished(module, afterBuild);\n        }\n      });\n    });\n  }\n  /**\n   *\n   * @param {string} context context path for entry\n   * @param {Dependency} entry entry dependency being created\n   * @param {string} name name of entry\n   * @param {ModuleCallback} callback callback function\n   * @returns {void} returns\n   */\n\n\n  addEntry(context, entry, name, callback) {\n    this.hooks.addEntry.call(entry, name);\n    const slot = {\n      name: name,\n      // TODO webpack 5 remove `request`\n      request: null,\n      module: null\n    };\n\n    if (entry instanceof ModuleDependency) {\n      slot.request = entry.request;\n    } // TODO webpack 5: merge modules instead when multiple entry modules are supported\n\n\n    const idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);\n\n    if (idx >= 0) {\n      // Overwrite existing entrypoint\n      this._preparedEntrypoints[idx] = slot;\n    } else {\n      this._preparedEntrypoints.push(slot);\n    }\n\n    this._addModuleChain(context, entry, module => {\n      this.entries.push(module);\n    }, (err, module) => {\n      if (err) {\n        this.hooks.failedEntry.call(entry, name, err);\n        return callback(err);\n      }\n\n      if (module) {\n        slot.module = module;\n      } else {\n        const idx = this._preparedEntrypoints.indexOf(slot);\n\n        if (idx >= 0) {\n          this._preparedEntrypoints.splice(idx, 1);\n        }\n      }\n\n      this.hooks.succeedEntry.call(entry, name, module);\n      return callback(null, module);\n    });\n  }\n  /**\n   * @param {string} context context path string\n   * @param {Dependency} dependency dep used to create module\n   * @param {ModuleCallback} callback module callback sending module up a level\n   * @returns {void}\n   */\n\n\n  prefetch(context, dependency, callback) {\n    this._addModuleChain(context, dependency, module => {\n      module.prefetched = true;\n    }, callback);\n  }\n  /**\n   * @param {Module} module module to be rebuilt\n   * @param {Callback} thisCallback callback when module finishes rebuilding\n   * @returns {void}\n   */\n\n\n  rebuildModule(module, thisCallback) {\n    let callbackList = this._rebuildingModules.get(module);\n\n    if (callbackList) {\n      callbackList.push(thisCallback);\n      return;\n    }\n\n    this._rebuildingModules.set(module, callbackList = [thisCallback]);\n\n    const callback = err => {\n      this._rebuildingModules.delete(module);\n\n      for (const cb of callbackList) {\n        cb(err);\n      }\n    };\n\n    this.hooks.rebuildModule.call(module);\n    const oldDependencies = module.dependencies.slice();\n    const oldVariables = module.variables.slice();\n    const oldBlocks = module.blocks.slice();\n    module.unbuild();\n    this.buildModule(module, false, module, null, err => {\n      if (err) {\n        this.hooks.finishRebuildingModule.call(module);\n        return callback(err);\n      }\n\n      this.processModuleDependencies(module, err => {\n        if (err) return callback(err);\n        this.removeReasonsOfDependencyBlock(module, {\n          dependencies: oldDependencies,\n          variables: oldVariables,\n          blocks: oldBlocks\n        });\n        this.hooks.finishRebuildingModule.call(module);\n        callback();\n      });\n    });\n  }\n\n  finish(callback) {\n    const modules = this.modules;\n    this.hooks.finishModules.callAsync(modules, err => {\n      if (err) return callback(err);\n\n      for (let index = 0; index < modules.length; index++) {\n        const module = modules[index];\n        this.reportDependencyErrorsAndWarnings(module, [module]);\n      }\n\n      callback();\n    });\n  }\n\n  unseal() {\n    this.hooks.unseal.call();\n    this.chunks.length = 0;\n    this.chunkGroups.length = 0;\n    this.namedChunks.clear();\n    this.namedChunkGroups.clear();\n    this.additionalChunkAssets.length = 0;\n    this.assets = {};\n    this.assetsInfo.clear();\n\n    for (const module of this.modules) {\n      module.unseal();\n    }\n  }\n  /**\n   * @param {Callback} callback signals when the seal method is finishes\n   * @returns {void}\n   */\n\n\n  seal(callback) {\n    this.hooks.seal.call();\n\n    while (this.hooks.optimizeDependenciesBasic.call(this.modules) || this.hooks.optimizeDependencies.call(this.modules) || this.hooks.optimizeDependenciesAdvanced.call(this.modules)) {\n      /* empty */\n    }\n\n    this.hooks.afterOptimizeDependencies.call(this.modules);\n    this.hooks.beforeChunks.call();\n\n    for (const preparedEntrypoint of this._preparedEntrypoints) {\n      const module = preparedEntrypoint.module;\n      const name = preparedEntrypoint.name;\n      const chunk = this.addChunk(name);\n      const entrypoint = new Entrypoint(name);\n      entrypoint.setRuntimeChunk(chunk);\n      entrypoint.addOrigin(null, name, preparedEntrypoint.request);\n      this.namedChunkGroups.set(name, entrypoint);\n      this.entrypoints.set(name, entrypoint);\n      this.chunkGroups.push(entrypoint);\n      GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);\n      GraphHelpers.connectChunkAndModule(chunk, module);\n      chunk.entryModule = module;\n      chunk.name = name;\n      this.assignDepth(module);\n    }\n\n    buildChunkGraph(this, this.chunkGroups.slice());\n    this.sortModules(this.modules);\n    this.hooks.afterChunks.call(this.chunks);\n    this.hooks.optimize.call();\n\n    while (this.hooks.optimizeModulesBasic.call(this.modules) || this.hooks.optimizeModules.call(this.modules) || this.hooks.optimizeModulesAdvanced.call(this.modules)) {\n      /* empty */\n    }\n\n    this.hooks.afterOptimizeModules.call(this.modules);\n\n    while (this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)) {\n      /* empty */\n    }\n\n    this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);\n    this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {\n      if (err) {\n        return callback(err);\n      }\n\n      this.hooks.afterOptimizeTree.call(this.chunks, this.modules);\n\n      while (this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) || this.hooks.optimizeChunkModules.call(this.chunks, this.modules) || this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)) {\n        /* empty */\n      }\n\n      this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);\n      const shouldRecord = this.hooks.shouldRecord.call() !== false;\n      this.hooks.reviveModules.call(this.modules, this.records);\n      this.hooks.optimizeModuleOrder.call(this.modules);\n      this.hooks.advancedOptimizeModuleOrder.call(this.modules);\n      this.hooks.beforeModuleIds.call(this.modules);\n      this.hooks.moduleIds.call(this.modules);\n      this.applyModuleIds();\n      this.hooks.optimizeModuleIds.call(this.modules);\n      this.hooks.afterOptimizeModuleIds.call(this.modules);\n      this.sortItemsWithModuleIds();\n      this.hooks.reviveChunks.call(this.chunks, this.records);\n      this.hooks.optimizeChunkOrder.call(this.chunks);\n      this.hooks.beforeChunkIds.call(this.chunks);\n      this.applyChunkIds();\n      this.hooks.optimizeChunkIds.call(this.chunks);\n      this.hooks.afterOptimizeChunkIds.call(this.chunks);\n      this.sortItemsWithChunkIds();\n\n      if (shouldRecord) {\n        this.hooks.recordModules.call(this.modules, this.records);\n        this.hooks.recordChunks.call(this.chunks, this.records);\n      }\n\n      this.hooks.beforeHash.call();\n      this.createHash();\n      this.hooks.afterHash.call();\n\n      if (shouldRecord) {\n        this.hooks.recordHash.call(this.records);\n      }\n\n      this.hooks.beforeModuleAssets.call();\n      this.createModuleAssets();\n\n      if (this.hooks.shouldGenerateChunkAssets.call() !== false) {\n        this.hooks.beforeChunkAssets.call();\n        this.createChunkAssets();\n      }\n\n      this.hooks.additionalChunkAssets.call(this.chunks);\n      this.summarizeDependencies();\n\n      if (shouldRecord) {\n        this.hooks.record.call(this, this.records);\n      }\n\n      this.hooks.additionalAssets.callAsync(err => {\n        if (err) {\n          return callback(err);\n        }\n\n        this.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {\n          if (err) {\n            return callback(err);\n          }\n\n          this.hooks.afterOptimizeChunkAssets.call(this.chunks);\n          this.hooks.optimizeAssets.callAsync(this.assets, err => {\n            if (err) {\n              return callback(err);\n            }\n\n            this.hooks.afterOptimizeAssets.call(this.assets);\n\n            if (this.hooks.needAdditionalSeal.call()) {\n              this.unseal();\n              return this.seal(callback);\n            }\n\n            return this.hooks.afterSeal.callAsync(callback);\n          });\n        });\n      });\n    });\n  }\n  /**\n   * @param {Module[]} modules the modules array on compilation to perform the sort for\n   * @returns {void}\n   */\n\n\n  sortModules(modules) {\n    // TODO webpack 5: this should only be enabled when `moduleIds: \"natural\"`\n    // TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply\n    // TODO remove this method\n    modules.sort(byIndexOrIdentifier);\n  }\n  /**\n   * @param {Module} module moulde to report from\n   * @param {DependenciesBlock[]} blocks blocks to report from\n   * @returns {void}\n   */\n\n\n  reportDependencyErrorsAndWarnings(module, blocks) {\n    for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n      const block = blocks[indexBlock];\n      const dependencies = block.dependencies;\n\n      for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {\n        const d = dependencies[indexDep];\n        const warnings = d.getWarnings();\n\n        if (warnings) {\n          for (let indexWar = 0; indexWar < warnings.length; indexWar++) {\n            const w = warnings[indexWar];\n            const warning = new ModuleDependencyWarning(module, w, d.loc);\n            this.warnings.push(warning);\n          }\n        }\n\n        const errors = d.getErrors();\n\n        if (errors) {\n          for (let indexErr = 0; indexErr < errors.length; indexErr++) {\n            const e = errors[indexErr];\n            const error = new ModuleDependencyError(module, e, d.loc);\n            this.errors.push(error);\n          }\n        }\n      }\n\n      this.reportDependencyErrorsAndWarnings(module, block.blocks);\n    }\n  }\n  /**\n   * @param {TODO} groupOptions options for the chunk group\n   * @param {Module} module the module the references the chunk group\n   * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)\n   * @param {string} request the request from which the the chunk group is referenced\n   * @returns {ChunkGroup} the new or existing chunk group\n   */\n\n\n  addChunkInGroup(groupOptions, module, loc, request) {\n    if (typeof groupOptions === \"string\") {\n      groupOptions = {\n        name: groupOptions\n      };\n    }\n\n    const name = groupOptions.name;\n\n    if (name) {\n      const chunkGroup = this.namedChunkGroups.get(name);\n\n      if (chunkGroup !== undefined) {\n        chunkGroup.addOptions(groupOptions);\n\n        if (module) {\n          chunkGroup.addOrigin(module, loc, request);\n        }\n\n        return chunkGroup;\n      }\n    }\n\n    const chunkGroup = new ChunkGroup(groupOptions);\n    if (module) chunkGroup.addOrigin(module, loc, request);\n    const chunk = this.addChunk(name);\n    GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);\n    this.chunkGroups.push(chunkGroup);\n\n    if (name) {\n      this.namedChunkGroups.set(name, chunkGroup);\n    }\n\n    return chunkGroup;\n  }\n  /**\n   * This method first looks to see if a name is provided for a new chunk,\n   * and first looks to see if any named chunks already exist and reuse that chunk instead.\n   *\n   * @param {string=} name optional chunk name to be provided\n   * @returns {Chunk} create a chunk (invoked during seal event)\n   */\n\n\n  addChunk(name) {\n    if (name) {\n      const chunk = this.namedChunks.get(name);\n\n      if (chunk !== undefined) {\n        return chunk;\n      }\n    }\n\n    const chunk = new Chunk(name);\n    this.chunks.push(chunk);\n\n    if (name) {\n      this.namedChunks.set(name, chunk);\n    }\n\n    return chunk;\n  }\n  /**\n   * @param {Module} module module to assign depth\n   * @returns {void}\n   */\n\n\n  assignDepth(module) {\n    const queue = new Set([module]);\n    let depth;\n    module.depth = 0;\n    /**\n     * @param {Module} module module for processeing\n     * @returns {void}\n     */\n\n    const enqueueJob = module => {\n      const d = module.depth;\n      if (typeof d === \"number\" && d <= depth) return;\n      queue.add(module);\n      module.depth = depth;\n    };\n    /**\n     * @param {Dependency} dependency dependency to assign depth to\n     * @returns {void}\n     */\n\n\n    const assignDepthToDependency = dependency => {\n      if (dependency.module) {\n        enqueueJob(dependency.module);\n      }\n    };\n    /**\n     * @param {DependenciesBlock} block block to assign depth to\n     * @returns {void}\n     */\n\n\n    const assignDepthToDependencyBlock = block => {\n      if (block.variables) {\n        iterationBlockVariable(block.variables, assignDepthToDependency);\n      }\n\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, assignDepthToDependency);\n      }\n\n      if (block.blocks) {\n        iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);\n      }\n    };\n\n    for (module of queue) {\n      queue.delete(module);\n      depth = module.depth;\n      depth++;\n      assignDepthToDependencyBlock(module);\n    }\n  }\n  /**\n   * @param {Module} module the module containing the dependency\n   * @param {Dependency} dependency the dependency\n   * @returns {DependencyReference} a reference for the dependency\n   */\n\n\n  getDependencyReference(module, dependency) {\n    // TODO remove dep.getReference existence check in webpack 5\n    if (typeof dependency.getReference !== \"function\") return null;\n    const ref = dependency.getReference();\n    if (!ref) return null;\n    return this.hooks.dependencyReference.call(ref, dependency, module);\n  }\n  /**\n   *\n   * @param {Module} module module relationship for removal\n   * @param {DependenciesBlockLike} block //TODO: good description\n   * @returns {void}\n   */\n\n\n  removeReasonsOfDependencyBlock(module, block) {\n    const iteratorDependency = d => {\n      if (!d.module) {\n        return;\n      }\n\n      if (d.module.removeReason(module, d)) {\n        for (const chunk of d.module.chunksIterable) {\n          this.patchChunksAfterReasonRemoval(d.module, chunk);\n        }\n      }\n    };\n\n    if (block.blocks) {\n      iterationOfArrayCallback(block.blocks, block => this.removeReasonsOfDependencyBlock(module, block));\n    }\n\n    if (block.dependencies) {\n      iterationOfArrayCallback(block.dependencies, iteratorDependency);\n    }\n\n    if (block.variables) {\n      iterationBlockVariable(block.variables, iteratorDependency);\n    }\n  }\n  /**\n   * @param {Module} module module to patch tie\n   * @param {Chunk} chunk chunk to patch tie\n   * @returns {void}\n   */\n\n\n  patchChunksAfterReasonRemoval(module, chunk) {\n    if (!module.hasReasons()) {\n      this.removeReasonsOfDependencyBlock(module, module);\n    }\n\n    if (!module.hasReasonForChunk(chunk)) {\n      if (module.removeChunk(chunk)) {\n        this.removeChunkFromDependencies(module, chunk);\n      }\n    }\n  }\n  /**\n   *\n   * @param {DependenciesBlock} block block tie for Chunk\n   * @param {Chunk} chunk chunk to remove from dep\n   * @returns {void}\n   */\n\n\n  removeChunkFromDependencies(block, chunk) {\n    const iteratorDependency = d => {\n      if (!d.module) {\n        return;\n      }\n\n      this.patchChunksAfterReasonRemoval(d.module, chunk);\n    };\n\n    const blocks = block.blocks;\n\n    for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n      const asyncBlock = blocks[indexBlock]; // Grab all chunks from the first Block's AsyncDepBlock\n\n      const chunks = asyncBlock.chunkGroup.chunks; // For each chunk in chunkGroup\n\n      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n        const iteratedChunk = chunks[indexChunk];\n        asyncBlock.chunkGroup.removeChunk(iteratedChunk);\n        asyncBlock.chunkGroup.removeParent(iteratedChunk); // Recurse\n\n        this.removeChunkFromDependencies(block, iteratedChunk);\n      }\n    }\n\n    if (block.dependencies) {\n      iterationOfArrayCallback(block.dependencies, iteratorDependency);\n    }\n\n    if (block.variables) {\n      iterationBlockVariable(block.variables, iteratorDependency);\n    }\n  }\n\n  applyModuleIds() {\n    const unusedIds = [];\n    let nextFreeModuleId = 0;\n    const usedIds = new Set();\n\n    if (this.usedModuleIds) {\n      for (const id of this.usedModuleIds) {\n        usedIds.add(id);\n      }\n    }\n\n    const modules1 = this.modules;\n\n    for (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {\n      const module1 = modules1[indexModule1];\n\n      if (module1.id !== null) {\n        usedIds.add(module1.id);\n      }\n    }\n\n    if (usedIds.size > 0) {\n      let usedIdMax = -1;\n\n      for (const usedIdKey of usedIds) {\n        if (typeof usedIdKey !== \"number\") {\n          continue;\n        }\n\n        usedIdMax = Math.max(usedIdMax, usedIdKey);\n      }\n\n      let lengthFreeModules = nextFreeModuleId = usedIdMax + 1;\n\n      while (lengthFreeModules--) {\n        if (!usedIds.has(lengthFreeModules)) {\n          unusedIds.push(lengthFreeModules);\n        }\n      }\n    }\n\n    const modules2 = this.modules;\n\n    for (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {\n      const module2 = modules2[indexModule2];\n\n      if (module2.id === null) {\n        if (unusedIds.length > 0) {\n          module2.id = unusedIds.pop();\n        } else {\n          module2.id = nextFreeModuleId++;\n        }\n      }\n    }\n  }\n\n  applyChunkIds() {\n    /** @type {Set<number>} */\n    const usedIds = new Set(); // Get used ids from usedChunkIds property (i. e. from records)\n\n    if (this.usedChunkIds) {\n      for (const id of this.usedChunkIds) {\n        if (typeof id !== \"number\") {\n          continue;\n        }\n\n        usedIds.add(id);\n      }\n    } // Get used ids from existing chunks\n\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n      const usedIdValue = chunk.id;\n\n      if (typeof usedIdValue !== \"number\") {\n        continue;\n      }\n\n      usedIds.add(usedIdValue);\n    } // Calculate maximum assigned chunk id\n\n\n    let nextFreeChunkId = -1;\n\n    for (const id of usedIds) {\n      nextFreeChunkId = Math.max(nextFreeChunkId, id);\n    }\n\n    nextFreeChunkId++; // Determine free chunk ids from 0 to maximum\n\n    /** @type {number[]} */\n\n    const unusedIds = [];\n\n    if (nextFreeChunkId > 0) {\n      let index = nextFreeChunkId;\n\n      while (index--) {\n        if (!usedIds.has(index)) {\n          unusedIds.push(index);\n        }\n      }\n    } // Assign ids to chunk which has no id\n\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n\n      if (chunk.id === null) {\n        if (unusedIds.length > 0) {\n          chunk.id = unusedIds.pop();\n        } else {\n          chunk.id = nextFreeChunkId++;\n        }\n      }\n\n      if (!chunk.ids) {\n        chunk.ids = [chunk.id];\n      }\n    }\n  }\n\n  sortItemsWithModuleIds() {\n    this.modules.sort(byIdOrIdentifier);\n    const modules = this.modules;\n\n    for (let indexModule = 0; indexModule < modules.length; indexModule++) {\n      modules[indexModule].sortItems(false);\n    }\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      chunks[indexChunk].sortItems();\n    }\n\n    chunks.sort((a, b) => a.compareTo(b));\n  }\n\n  sortItemsWithChunkIds() {\n    for (const chunkGroup of this.chunkGroups) {\n      chunkGroup.sortItems();\n    }\n\n    this.chunks.sort(byId);\n\n    for (let indexModule = 0; indexModule < this.modules.length; indexModule++) {\n      this.modules[indexModule].sortItems(true);\n    }\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      chunks[indexChunk].sortItems();\n    }\n    /**\n     * Used to sort errors and warnings in compilation. this.warnings, and\n     * this.errors contribute to the compilation hash and therefore should be\n     * updated whenever other references (having a chunk id) are sorted. This preserves the hash\n     * integrity\n     *\n     * @param {WebpackError} a first WebpackError instance (including subclasses)\n     * @param {WebpackError} b second WebpackError instance (including subclasses)\n     * @returns {-1|0|1} sort order index\n     */\n\n\n    const byMessage = (a, b) => {\n      const ma = `${a.message}`;\n      const mb = `${b.message}`;\n      if (ma < mb) return -1;\n      if (mb < ma) return 1;\n      return 0;\n    };\n\n    this.errors.sort(byMessage);\n    this.warnings.sort(byMessage);\n    this.children.sort(byNameOrHash);\n  }\n\n  summarizeDependencies() {\n    this.fileDependencies = new SortableSet(this.compilationDependencies);\n    this.contextDependencies = new SortableSet();\n    this.missingDependencies = new SortableSet();\n\n    for (let indexChildren = 0; indexChildren < this.children.length; indexChildren++) {\n      const child = this.children[indexChildren];\n      addAllToSet(this.fileDependencies, child.fileDependencies);\n      addAllToSet(this.contextDependencies, child.contextDependencies);\n      addAllToSet(this.missingDependencies, child.missingDependencies);\n    }\n\n    for (let indexModule = 0; indexModule < this.modules.length; indexModule++) {\n      const module = this.modules[indexModule];\n\n      if (module.buildInfo.fileDependencies) {\n        addAllToSet(this.fileDependencies, module.buildInfo.fileDependencies);\n      }\n\n      if (module.buildInfo.contextDependencies) {\n        addAllToSet(this.contextDependencies, module.buildInfo.contextDependencies);\n      }\n    }\n\n    for (const error of this.errors) {\n      if (typeof error.missing === \"object\" && error.missing && error.missing[Symbol.iterator]) {\n        addAllToSet(this.missingDependencies, error.missing);\n      }\n    }\n\n    this.fileDependencies.sort();\n    this.contextDependencies.sort();\n    this.missingDependencies.sort();\n  }\n\n  createHash() {\n    const outputOptions = this.outputOptions;\n    const hashFunction = outputOptions.hashFunction;\n    const hashDigest = outputOptions.hashDigest;\n    const hashDigestLength = outputOptions.hashDigestLength;\n    const hash = createHash(hashFunction);\n\n    if (outputOptions.hashSalt) {\n      hash.update(outputOptions.hashSalt);\n    }\n\n    this.mainTemplate.updateHash(hash);\n    this.chunkTemplate.updateHash(hash);\n\n    for (const key of Object.keys(this.moduleTemplates).sort()) {\n      this.moduleTemplates[key].updateHash(hash);\n    }\n\n    for (const child of this.children) {\n      hash.update(child.hash);\n    }\n\n    for (const warning of this.warnings) {\n      hash.update(`${warning.message}`);\n    }\n\n    for (const error of this.errors) {\n      hash.update(`${error.message}`);\n    }\n\n    const modules = this.modules;\n\n    for (let i = 0; i < modules.length; i++) {\n      const module = modules[i];\n      const moduleHash = createHash(hashFunction);\n      module.updateHash(moduleHash);\n      module.hash = moduleHash.digest(hashDigest);\n      module.renderedHash = module.hash.substr(0, hashDigestLength);\n    } // clone needed as sort below is inplace mutation\n\n\n    const chunks = this.chunks.slice();\n    /**\n     * sort here will bring all \"falsy\" values to the beginning\n     * this is needed as the \"hasRuntime()\" chunks are dependent on the\n     * hashes of the non-runtime chunks.\n     */\n\n    chunks.sort((a, b) => {\n      const aEntry = a.hasRuntime();\n      const bEntry = b.hasRuntime();\n      if (aEntry && !bEntry) return 1;\n      if (!aEntry && bEntry) return -1;\n      return byId(a, b);\n    });\n\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const chunkHash = createHash(hashFunction);\n\n      try {\n        if (outputOptions.hashSalt) {\n          chunkHash.update(outputOptions.hashSalt);\n        }\n\n        chunk.updateHash(chunkHash);\n        const template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n        template.updateHashForChunk(chunkHash, chunk, this.moduleTemplates.javascript, this.dependencyTemplates);\n        this.hooks.chunkHash.call(chunk, chunkHash);\n        chunk.hash = chunkHash.digest(hashDigest);\n        hash.update(chunk.hash);\n        chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);\n        this.hooks.contentHash.call(chunk);\n      } catch (err) {\n        this.errors.push(new ChunkRenderError(chunk, \"\", err));\n      }\n    }\n\n    this.fullHash = hash.digest(hashDigest);\n    this.hash = this.fullHash.substr(0, hashDigestLength);\n  }\n  /**\n   * @param {string} update extra information\n   * @returns {void}\n   */\n\n\n  modifyHash(update) {\n    const outputOptions = this.outputOptions;\n    const hashFunction = outputOptions.hashFunction;\n    const hashDigest = outputOptions.hashDigest;\n    const hashDigestLength = outputOptions.hashDigestLength;\n    const hash = createHash(hashFunction);\n    hash.update(this.fullHash);\n    hash.update(update);\n    this.fullHash = hash.digest(hashDigest);\n    this.hash = this.fullHash.substr(0, hashDigestLength);\n  }\n  /**\n   * @param {string} file file name\n   * @param {Source} source asset source\n   * @param {AssetInfo} assetInfo extra asset information\n   * @returns {void}\n   */\n\n\n  emitAsset(file, source, assetInfo = {}) {\n    if (this.assets[file]) {\n      if (!isSourceEqual(this.assets[file], source)) {\n        // TODO webpack 5: make this an error instead\n        this.warnings.push(new WebpackError(`Conflict: Multiple assets emit different content to the same filename ${file}`));\n        this.assets[file] = source;\n        this.assetsInfo.set(file, assetInfo);\n        return;\n      }\n\n      const oldInfo = this.assetsInfo.get(file);\n      this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfo));\n      return;\n    }\n\n    this.assets[file] = source;\n    this.assetsInfo.set(file, assetInfo);\n  }\n  /**\n   * @param {string} file file name\n   * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new\n   * @param {AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new\n   */\n\n\n  updateAsset(file, newSourceOrFunction, assetInfoUpdateOrFunction = undefined) {\n    if (!this.assets[file]) {\n      throw new Error(`Called Compilation.updateAsset for not existing filename ${file}`);\n    }\n\n    if (typeof newSourceOrFunction === \"function\") {\n      this.assets[file] = newSourceOrFunction(this.assets[file]);\n    } else {\n      this.assets[file] = newSourceOrFunction;\n    }\n\n    if (assetInfoUpdateOrFunction !== undefined) {\n      const oldInfo = this.assetsInfo.get(file);\n\n      if (typeof assetInfoUpdateOrFunction === \"function\") {\n        this.assetsInfo.set(file, assetInfoUpdateOrFunction(oldInfo || {}));\n      } else {\n        this.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfoUpdateOrFunction));\n      }\n    }\n  }\n\n  getAssets() {\n    /** @type {Asset[]} */\n    const array = [];\n\n    for (const assetName of Object.keys(this.assets)) {\n      if (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {\n        array.push({\n          name: assetName,\n          source: this.assets[assetName],\n          info: this.assetsInfo.get(assetName) || {}\n        });\n      }\n    }\n\n    return array;\n  }\n  /**\n   * @param {string} name the name of the asset\n   * @returns {Asset | undefined} the asset or undefined when not found\n   */\n\n\n  getAsset(name) {\n    if (!Object.prototype.hasOwnProperty.call(this.assets, name)) return undefined;\n    return {\n      name,\n      source: this.assets[name],\n      info: this.assetsInfo.get(name) || {}\n    };\n  }\n\n  createModuleAssets() {\n    for (let i = 0; i < this.modules.length; i++) {\n      const module = this.modules[i];\n\n      if (module.buildInfo.assets) {\n        const assetsInfo = module.buildInfo.assetsInfo;\n\n        for (const assetName of Object.keys(module.buildInfo.assets)) {\n          const fileName = this.getPath(assetName);\n          this.emitAsset(fileName, module.buildInfo.assets[assetName], assetsInfo ? assetsInfo.get(assetName) : undefined);\n          this.hooks.moduleAsset.call(module, fileName);\n        }\n      }\n    }\n  }\n\n  createChunkAssets() {\n    const outputOptions = this.outputOptions;\n    const cachedSourceMap = new Map();\n    /** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */\n\n    const alreadyWrittenFiles = new Map();\n\n    for (let i = 0; i < this.chunks.length; i++) {\n      const chunk = this.chunks[i];\n      chunk.files = [];\n      let source;\n      let file;\n      let filenameTemplate;\n\n      try {\n        const template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n        const manifest = template.getRenderManifest({\n          chunk,\n          hash: this.hash,\n          fullHash: this.fullHash,\n          outputOptions,\n          moduleTemplates: this.moduleTemplates,\n          dependencyTemplates: this.dependencyTemplates\n        }); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]\n\n        for (const fileManifest of manifest) {\n          const cacheName = fileManifest.identifier;\n          const usedHash = fileManifest.hash;\n          filenameTemplate = fileManifest.filenameTemplate;\n          const pathAndInfo = this.getPathWithInfo(filenameTemplate, fileManifest.pathOptions);\n          file = pathAndInfo.path;\n          const assetInfo = pathAndInfo.info; // check if the same filename was already written by another chunk\n\n          const alreadyWritten = alreadyWrittenFiles.get(file);\n\n          if (alreadyWritten !== undefined) {\n            if (alreadyWritten.hash === usedHash) {\n              if (this.cache) {\n                this.cache[cacheName] = {\n                  hash: usedHash,\n                  source: alreadyWritten.source\n                };\n              }\n\n              chunk.files.push(file);\n              this.hooks.chunkAsset.call(chunk, file);\n              continue;\n            } else {\n              throw new Error(`Conflict: Multiple chunks emit assets to the same filename ${file}` + ` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`);\n            }\n          }\n\n          if (this.cache && this.cache[cacheName] && this.cache[cacheName].hash === usedHash) {\n            source = this.cache[cacheName].source;\n          } else {\n            source = fileManifest.render(); // Ensure that source is a cached source to avoid additional cost because of repeated access\n\n            if (!(source instanceof CachedSource)) {\n              const cacheEntry = cachedSourceMap.get(source);\n\n              if (cacheEntry) {\n                source = cacheEntry;\n              } else {\n                const cachedSource = new CachedSource(source);\n                cachedSourceMap.set(source, cachedSource);\n                source = cachedSource;\n              }\n            }\n\n            if (this.cache) {\n              this.cache[cacheName] = {\n                hash: usedHash,\n                source\n              };\n            }\n          }\n\n          this.emitAsset(file, source, assetInfo);\n          chunk.files.push(file);\n          this.hooks.chunkAsset.call(chunk, file);\n          alreadyWrittenFiles.set(file, {\n            hash: usedHash,\n            source,\n            chunk\n          });\n        }\n      } catch (err) {\n        this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));\n      }\n    }\n  }\n  /**\n   * @param {string} filename used to get asset path with hash\n   * @param {TODO=} data // TODO: figure out this param type\n   * @returns {string} interpolated path\n   */\n\n\n  getPath(filename, data) {\n    data = data || {};\n    data.hash = data.hash || this.hash;\n    return this.mainTemplate.getAssetPath(filename, data);\n  }\n  /**\n   * @param {string} filename used to get asset path with hash\n   * @param {TODO=} data // TODO: figure out this param type\n   * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info\n   */\n\n\n  getPathWithInfo(filename, data) {\n    data = data || {};\n    data.hash = data.hash || this.hash;\n    return this.mainTemplate.getAssetPathWithInfo(filename, data);\n  }\n  /**\n   * This function allows you to run another instance of webpack inside of webpack however as\n   * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins\n   * from parent (or top level compiler) and creates a child Compilation\n   *\n   * @param {string} name name of the child compiler\n   * @param {TODO} outputOptions // Need to convert config schema to types for this\n   * @param {Plugin[]} plugins webpack plugins that will be applied\n   * @returns {Compiler} creates a child Compiler instance\n   */\n\n\n  createChildCompiler(name, outputOptions, plugins) {\n    const idx = this.childrenCounters[name] || 0;\n    this.childrenCounters[name] = idx + 1;\n    return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);\n  }\n\n  checkConstraints() {\n    /** @type {Set<number|string>} */\n    const usedIds = new Set();\n    const modules = this.modules;\n\n    for (let indexModule = 0; indexModule < modules.length; indexModule++) {\n      const moduleId = modules[indexModule].id;\n      if (moduleId === null) continue;\n\n      if (usedIds.has(moduleId)) {\n        throw new Error(`checkConstraints: duplicate module id ${moduleId}`);\n      }\n\n      usedIds.add(moduleId);\n    }\n\n    const chunks = this.chunks;\n\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n\n      if (chunks.indexOf(chunk) !== indexChunk) {\n        throw new Error(`checkConstraints: duplicate chunk in compilation ${chunk.debugId}`);\n      }\n    }\n\n    for (const chunkGroup of this.chunkGroups) {\n      chunkGroup.checkConstraints();\n    }\n  }\n\n} // TODO remove in webpack 5\n\n\nCompilation.prototype.applyPlugins = util.deprecate(\n/**\n * @deprecated\n * @param {string} name Name\n * @param {any[]} args Other arguments\n * @returns {void}\n * @this {Compilation}\n */\nfunction (name, ...args) {\n  this.hooks[name.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())].call(...args);\n}, \"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead\"); // TODO remove in webpack 5\n\nObject.defineProperty(Compilation.prototype, \"moduleTemplate\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Compilation}\n   * @returns {TODO} module template\n   */\n  function () {\n    return this.moduleTemplates.javascript;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {ModuleTemplate} value Template value\n   * @this {Compilation}\n   * @returns {void}\n   */\n  function (value) {\n    this.moduleTemplates.javascript = value;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.\")\n});\nmodule.exports = Compilation;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/Compilation.js"],"names":["asyncLib","require","util","CachedSource","Tapable","SyncHook","SyncBailHook","SyncWaterfallHook","AsyncSeriesHook","EntryModuleNotFoundError","ModuleNotFoundError","ModuleDependencyWarning","ModuleDependencyError","ChunkGroup","Chunk","Entrypoint","MainTemplate","ChunkTemplate","HotUpdateChunkTemplate","ModuleTemplate","RuntimeTemplate","ChunkRenderError","Stats","Semaphore","createHash","SortableSet","GraphHelpers","ModuleDependency","compareLocations","Logger","LogType","ErrorHelpers","buildChunkGraph","WebpackError","byId","a","b","id","byIdOrIdentifier","identA","identifier","identB","byIndexOrIdentifier","index","byNameOrHash","name","fullHash","iterationBlockVariable","variables","fn","indexVariable","length","varDep","dependencies","indexVDep","iterationOfArrayCallback","arr","addAllToSet","set","otherSet","item","add","isSourceEqual","aSource","source","bSource","Buffer","isBuffer","from","equals","Compilation","constructor","compiler","hooks","buildModule","rebuildModule","failedModule","succeedModule","addEntry","failedEntry","succeedEntry","dependencyReference","finishModules","finishRebuildingModule","unseal","seal","beforeChunks","afterChunks","optimizeDependenciesBasic","optimizeDependencies","optimizeDependenciesAdvanced","afterOptimizeDependencies","optimize","optimizeModulesBasic","optimizeModules","optimizeModulesAdvanced","afterOptimizeModules","optimizeChunksBasic","optimizeChunks","optimizeChunksAdvanced","afterOptimizeChunks","optimizeTree","afterOptimizeTree","optimizeChunkModulesBasic","optimizeChunkModules","optimizeChunkModulesAdvanced","afterOptimizeChunkModules","shouldRecord","reviveModules","optimizeModuleOrder","advancedOptimizeModuleOrder","beforeModuleIds","moduleIds","optimizeModuleIds","afterOptimizeModuleIds","reviveChunks","optimizeChunkOrder","beforeChunkIds","optimizeChunkIds","afterOptimizeChunkIds","recordModules","recordChunks","beforeHash","contentHash","afterHash","recordHash","record","beforeModuleAssets","shouldGenerateChunkAssets","beforeChunkAssets","additionalChunkAssets","additionalAssets","optimizeChunkAssets","afterOptimizeChunkAssets","optimizeAssets","afterOptimizeAssets","needAdditionalSeal","afterSeal","chunkHash","moduleAsset","chunkAsset","assetPath","needAdditionalPass","childCompiler","log","normalModuleLoader","optimizeExtractedChunksBasic","optimizeExtractedChunks","optimizeExtractedChunksAdvanced","afterOptimizeExtractedChunks","_pluginCompat","tap","options","async","undefined","resolverFactory","inputFileSystem","requestShortener","outputOptions","output","bail","profile","performance","mainTemplate","chunkTemplate","hotUpdateChunkTemplate","runtimeTemplate","moduleTemplates","javascript","webassembly","semaphore","parallelism","entries","_preparedEntrypoints","entrypoints","Map","chunks","chunkGroups","namedChunkGroups","namedChunks","modules","_modules","cache","records","assets","assetsInfo","errors","warnings","children","logging","dependencyFactories","dependencyTemplates","childrenCounters","usedChunkIds","usedModuleIds","fileTimestamps","contextTimestamps","compilationDependencies","_buildingModules","_rebuildingModules","emittedAssets","Set","getStats","getLogger","TypeError","logEntries","type","args","trace","warn","error","cutOffLoaderExecution","Error","stack","split","slice","logEntry","time","Date","now","call","profileEnd","console","get","push","addModule","module","cacheGroup","alreadyAddedModule","issuer","build","cacheName","cacheModule","updateCacheModule","rebuild","needRebuild","disconnect","err","unbuild","getModule","findModule","waitForBuildingFinished","callback","callbackList","process","nextTick","optional","origin","thisCallback","delete","cb","resolveOptions","indexError","indexWarning","war","originalMap","reduce","map","v","i","sort","cmp","loc","processModuleDependencies","addDependency","dep","resourceIdent","getResourceIdentifier","factory","innerMap","list","addDependenciesBlock","block","blocks","e","sortedDependencies","pair1","pair2","addModuleDependencies","recursive","start","currentProfile","forEach","errorAndCallback","warningAndCallback","acquire","create","contextInfo","nameForCondition","context","dependentModule","afterFactory","isOptional","every","d","errorOrWarningAndCallback","release","iterationDependencies","depend","addReason","addModuleResult","afterBuild","afterBuilding","building","_addModuleChain","dependency","onModule","Dep","moduleFactory","entry","slot","request","idx","findIndex","indexOf","splice","prefetch","prefetched","oldDependencies","oldVariables","oldBlocks","removeReasonsOfDependencyBlock","finish","callAsync","reportDependencyErrorsAndWarnings","clear","preparedEntrypoint","chunk","addChunk","entrypoint","setRuntimeChunk","addOrigin","connectChunkGroupAndChunk","connectChunkAndModule","entryModule","assignDepth","sortModules","applyModuleIds","sortItemsWithModuleIds","applyChunkIds","sortItemsWithChunkIds","createModuleAssets","createChunkAssets","summarizeDependencies","indexBlock","indexDep","getWarnings","indexWar","w","warning","getErrors","indexErr","addChunkInGroup","groupOptions","chunkGroup","addOptions","queue","depth","enqueueJob","assignDepthToDependency","assignDepthToDependencyBlock","getDependencyReference","getReference","ref","iteratorDependency","removeReason","chunksIterable","patchChunksAfterReasonRemoval","hasReasons","hasReasonForChunk","removeChunk","removeChunkFromDependencies","asyncBlock","indexChunk","iteratedChunk","removeParent","unusedIds","nextFreeModuleId","usedIds","modules1","indexModule1","module1","size","usedIdMax","usedIdKey","Math","max","lengthFreeModules","has","modules2","indexModule2","module2","pop","usedIdValue","nextFreeChunkId","ids","indexModule","sortItems","compareTo","byMessage","ma","message","mb","fileDependencies","contextDependencies","missingDependencies","indexChildren","child","buildInfo","missing","Symbol","iterator","hashFunction","hashDigest","hashDigestLength","hash","hashSalt","update","updateHash","key","Object","keys","moduleHash","digest","renderedHash","substr","aEntry","hasRuntime","bEntry","template","updateHashForChunk","modifyHash","emitAsset","file","assetInfo","oldInfo","assign","updateAsset","newSourceOrFunction","assetInfoUpdateOrFunction","getAssets","array","assetName","prototype","hasOwnProperty","info","getAsset","fileName","getPath","cachedSourceMap","alreadyWrittenFiles","files","filenameTemplate","manifest","getRenderManifest","fileManifest","usedHash","pathAndInfo","getPathWithInfo","pathOptions","path","alreadyWritten","render","cacheEntry","cachedSource","filename","data","getAssetPath","getAssetPathWithInfo","createChildCompiler","plugins","checkConstraints","moduleId","debugId","applyPlugins","deprecate","replace","match","toUpperCase","defineProperty","configurable","value","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n\t*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst util = require(\"util\");\nconst { CachedSource } = require(\"webpack-sources\");\nconst {\n\tTapable,\n\tSyncHook,\n\tSyncBailHook,\n\tSyncWaterfallHook,\n\tAsyncSeriesHook\n} = require(\"tapable\");\nconst EntryModuleNotFoundError = require(\"./EntryModuleNotFoundError\");\nconst ModuleNotFoundError = require(\"./ModuleNotFoundError\");\nconst ModuleDependencyWarning = require(\"./ModuleDependencyWarning\");\nconst ModuleDependencyError = require(\"./ModuleDependencyError\");\nconst ChunkGroup = require(\"./ChunkGroup\");\nconst Chunk = require(\"./Chunk\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst MainTemplate = require(\"./MainTemplate\");\nconst ChunkTemplate = require(\"./ChunkTemplate\");\nconst HotUpdateChunkTemplate = require(\"./HotUpdateChunkTemplate\");\nconst ModuleTemplate = require(\"./ModuleTemplate\");\nconst RuntimeTemplate = require(\"./RuntimeTemplate\");\nconst ChunkRenderError = require(\"./ChunkRenderError\");\nconst Stats = require(\"./Stats\");\nconst Semaphore = require(\"./util/Semaphore\");\nconst createHash = require(\"./util/createHash\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst ModuleDependency = require(\"./dependencies/ModuleDependency\");\nconst compareLocations = require(\"./compareLocations\");\nconst { Logger, LogType } = require(\"./logging/Logger\");\nconst ErrorHelpers = require(\"./ErrorHelpers\");\nconst buildChunkGraph = require(\"./buildChunkGraph\");\nconst WebpackError = require(\"./WebpackError\");\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n/** @typedef {import(\"./dependencies/SingleEntryDependency\")} SingleEntryDependency */\n/** @typedef {import(\"./dependencies/MultiEntryDependency\")} MultiEntryDependency */\n/** @typedef {import(\"./dependencies/DllEntryDependency\")} DllEntryDependency */\n/** @typedef {import(\"./dependencies/DependencyReference\")} DependencyReference */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n// TODO use @callback\n/** @typedef {{[assetName: string]: Source}} CompilationAssets */\n/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */\n/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */\n/** @typedef {(module: Module) => void} OnModuleCallback */\n/** @typedef {(err?: Error|null) => void} Callback */\n/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */\n/** @typedef {new (...args: any[]) => Dependency} DepConstructor */\n/** @typedef {{apply: () => void}} Plugin */\n\n/**\n * @typedef {Object} ModuleFactoryCreateDataContextInfo\n * @property {string} issuer\n * @property {string} compiler\n */\n\n/**\n * @typedef {Object} ModuleFactoryCreateData\n * @property {ModuleFactoryCreateDataContextInfo} contextInfo\n * @property {any=} resolveOptions\n * @property {string} context\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} ModuleFactory\n * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create\n */\n\n/**\n * @typedef {Object} SortedDependency\n * @property {ModuleFactory} factory\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} DependenciesBlockLike\n * @property {Dependency[]} dependencies\n * @property {AsyncDependenciesBlock[]} blocks\n * @property {DependenciesBlockVariable[]} variables\n */\n\n/**\n * @typedef {Object} LogEntry\n * @property {string} type\n * @property {any[]} args\n * @property {number} time\n * @property {string[]=} trace\n */\n\n/**\n * @typedef {Object} AssetInfo\n * @property {boolean=} immutable true, if the asset can be long term cached forever (contains a hash)\n * @property {number=} size size in bytes, only set after asset has been emitted\n * @property {boolean=} development true, when asset is only used for development and doesn't count towards user-facing assets\n * @property {boolean=} hotModuleReplacement true, when asset ships data for updating an existing application (HMR)\n */\n\n/**\n * @typedef {Object} Asset\n * @property {string} name the filename of the asset\n * @property {Source} source source of the asset\n * @property {AssetInfo} info info about the asset\n */\n\n/**\n * @param {Chunk} a first chunk to sort by id\n * @param {Chunk} b second chunk to sort by id\n * @returns {-1|0|1} sort value\n */\nconst byId = (a, b) => {\n\tif (typeof a.id !== typeof b.id) {\n\t\treturn typeof a.id < typeof b.id ? -1 : 1;\n\t}\n\tif (a.id < b.id) return -1;\n\tif (a.id > b.id) return 1;\n\treturn 0;\n};\n\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\nconst byIdOrIdentifier = (a, b) => {\n\tif (typeof a.id !== typeof b.id) {\n\t\treturn typeof a.id < typeof b.id ? -1 : 1;\n\t}\n\tif (a.id < b.id) return -1;\n\tif (a.id > b.id) return 1;\n\tconst identA = a.identifier();\n\tconst identB = b.identifier();\n\tif (identA < identB) return -1;\n\tif (identA > identB) return 1;\n\treturn 0;\n};\n\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\nconst byIndexOrIdentifier = (a, b) => {\n\tif (a.index < b.index) return -1;\n\tif (a.index > b.index) return 1;\n\tconst identA = a.identifier();\n\tconst identB = b.identifier();\n\tif (identA < identB) return -1;\n\tif (identA > identB) return 1;\n\treturn 0;\n};\n\n/**\n * @param {Compilation} a first compilation to sort by\n * @param {Compilation} b second compilation to sort by\n * @returns {-1|0|1} sort value\n */\nconst byNameOrHash = (a, b) => {\n\tif (a.name < b.name) return -1;\n\tif (a.name > b.name) return 1;\n\tif (a.fullHash < b.fullHash) return -1;\n\tif (a.fullHash > b.fullHash) return 1;\n\treturn 0;\n};\n\n/**\n * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over\n * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements\n * @returns {void}\n */\nconst iterationBlockVariable = (variables, fn) => {\n\tfor (\n\t\tlet indexVariable = 0;\n\t\tindexVariable < variables.length;\n\t\tindexVariable++\n\t) {\n\t\tconst varDep = variables[indexVariable].dependencies;\n\t\tfor (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) {\n\t\t\tfn(varDep[indexVDep]);\n\t\t}\n\t}\n};\n\n/**\n * @template T\n * @param {T[]} arr array of elements to iterate over\n * @param {function(T): void} fn callback applied to each element\n * @returns {void}\n */\nconst iterationOfArrayCallback = (arr, fn) => {\n\tfor (let index = 0; index < arr.length; index++) {\n\t\tfn(arr[index]);\n\t}\n};\n\n/**\n * @template T\n * @param {Set<T>} set set to add items to\n * @param {Set<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n\tfor (const item of otherSet) {\n\t\tset.add(item);\n\t}\n};\n\n/**\n * @param {Source} a a source\n * @param {Source} b another source\n * @returns {boolean} true, when both sources are equal\n */\nconst isSourceEqual = (a, b) => {\n\tif (a === b) return true;\n\t// TODO webpack 5: check .buffer() instead, it's called anyway during emit\n\t/** @type {Buffer|string} */\n\tlet aSource = a.source();\n\t/** @type {Buffer|string} */\n\tlet bSource = b.source();\n\tif (aSource === bSource) return true;\n\tif (typeof aSource === \"string\" && typeof bSource === \"string\") return false;\n\tif (!Buffer.isBuffer(aSource)) aSource = Buffer.from(aSource, \"utf-8\");\n\tif (!Buffer.isBuffer(bSource)) bSource = Buffer.from(bSource, \"utf-8\");\n\treturn aSource.equals(bSource);\n};\n\nclass Compilation extends Tapable {\n\t/**\n\t * Creates an instance of Compilation.\n\t * @param {Compiler} compiler the compiler which created the compilation\n\t */\n\tconstructor(compiler) {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\tbuildModule: new SyncHook([\"module\"]),\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\trebuildModule: new SyncHook([\"module\"]),\n\t\t\t/** @type {SyncHook<Module, Error>} */\n\t\t\tfailedModule: new SyncHook([\"module\", \"error\"]),\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\tsucceedModule: new SyncHook([\"module\"]),\n\n\t\t\t/** @type {SyncHook<Dependency, string>} */\n\t\t\taddEntry: new SyncHook([\"entry\", \"name\"]),\n\t\t\t/** @type {SyncHook<Dependency, string, Error>} */\n\t\t\tfailedEntry: new SyncHook([\"entry\", \"name\", \"error\"]),\n\t\t\t/** @type {SyncHook<Dependency, string, Module>} */\n\t\t\tsucceedEntry: new SyncHook([\"entry\", \"name\", \"module\"]),\n\n\t\t\t/** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */\n\t\t\tdependencyReference: new SyncWaterfallHook([\n\t\t\t\t\"dependencyReference\",\n\t\t\t\t\"dependency\",\n\t\t\t\t\"module\"\n\t\t\t]),\n\n\t\t\t/** @type {AsyncSeriesHook<Module[]>} */\n\t\t\tfinishModules: new AsyncSeriesHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module>} */\n\t\t\tfinishRebuildingModule: new SyncHook([\"module\"]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tunseal: new SyncHook([]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tseal: new SyncHook([]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeChunks: new SyncHook([]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterChunks: new SyncHook([\"chunks\"]),\n\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeDependenciesBasic: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeDependencies: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeDependenciesAdvanced: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\tafterOptimizeDependencies: new SyncHook([\"modules\"]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\toptimize: new SyncHook([]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeModulesBasic: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeModules: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncBailHook<Module[]>} */\n\t\t\toptimizeModulesAdvanced: new SyncBailHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tafterOptimizeModules: new SyncHook([\"modules\"]),\n\n\t\t\t/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n\t\t\toptimizeChunksBasic: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n\t\t\toptimizeChunks: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n\t\t\toptimizeChunksAdvanced: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\t\t\t/** @type {SyncHook<Chunk[], ChunkGroup[]>} */\n\t\t\tafterOptimizeChunks: new SyncHook([\"chunks\", \"chunkGroups\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<Chunk[], Module[]>} */\n\t\t\toptimizeTree: new AsyncSeriesHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncHook<Chunk[], Module[]>} */\n\t\t\tafterOptimizeTree: new SyncHook([\"chunks\", \"modules\"]),\n\n\t\t\t/** @type {SyncBailHook<Chunk[], Module[]>} */\n\t\t\toptimizeChunkModulesBasic: new SyncBailHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], Module[]>} */\n\t\t\toptimizeChunkModules: new SyncBailHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[], Module[]>} */\n\t\t\toptimizeChunkModulesAdvanced: new SyncBailHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncHook<Chunk[], Module[]>} */\n\t\t\tafterOptimizeChunkModules: new SyncHook([\"chunks\", \"modules\"]),\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tshouldRecord: new SyncBailHook([]),\n\n\t\t\t/** @type {SyncHook<Module[], any>} */\n\t\t\treviveModules: new SyncHook([\"modules\", \"records\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\toptimizeModuleOrder: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tadvancedOptimizeModuleOrder: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tbeforeModuleIds: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tmoduleIds: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\toptimizeModuleIds: new SyncHook([\"modules\"]),\n\t\t\t/** @type {SyncHook<Module[]>} */\n\t\t\tafterOptimizeModuleIds: new SyncHook([\"modules\"]),\n\n\t\t\t/** @type {SyncHook<Chunk[], any>} */\n\t\t\treviveChunks: new SyncHook([\"chunks\", \"records\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\toptimizeChunkOrder: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tbeforeChunkIds: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\toptimizeChunkIds: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterOptimizeChunkIds: new SyncHook([\"chunks\"]),\n\n\t\t\t/** @type {SyncHook<Module[], any>} */\n\t\t\trecordModules: new SyncHook([\"modules\", \"records\"]),\n\t\t\t/** @type {SyncHook<Chunk[], any>} */\n\t\t\trecordChunks: new SyncHook([\"chunks\", \"records\"]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeHash: new SyncHook([]),\n\t\t\t/** @type {SyncHook<Chunk>} */\n\t\t\tcontentHash: new SyncHook([\"chunk\"]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tafterHash: new SyncHook([]),\n\t\t\t/** @type {SyncHook<any>} */\n\t\t\trecordHash: new SyncHook([\"records\"]),\n\t\t\t/** @type {SyncHook<Compilation, any>} */\n\t\t\trecord: new SyncHook([\"compilation\", \"records\"]),\n\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeModuleAssets: new SyncHook([]),\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tshouldGenerateChunkAssets: new SyncBailHook([]),\n\t\t\t/** @type {SyncHook} */\n\t\t\tbeforeChunkAssets: new SyncHook([]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tadditionalChunkAssets: new SyncHook([\"chunks\"]),\n\n\t\t\t/** @type {AsyncSeriesHook} */\n\t\t\tadditionalAssets: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<Chunk[]>} */\n\t\t\toptimizeChunkAssets: new AsyncSeriesHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterOptimizeChunkAssets: new SyncHook([\"chunks\"]),\n\t\t\t/** @type {AsyncSeriesHook<CompilationAssets>} */\n\t\t\toptimizeAssets: new AsyncSeriesHook([\"assets\"]),\n\t\t\t/** @type {SyncHook<CompilationAssets>} */\n\t\t\tafterOptimizeAssets: new SyncHook([\"assets\"]),\n\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tneedAdditionalSeal: new SyncBailHook([]),\n\t\t\t/** @type {AsyncSeriesHook} */\n\t\t\tafterSeal: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {SyncHook<Chunk, Hash>} */\n\t\t\tchunkHash: new SyncHook([\"chunk\", \"chunkHash\"]),\n\t\t\t/** @type {SyncHook<Module, string>} */\n\t\t\tmoduleAsset: new SyncHook([\"module\", \"filename\"]),\n\t\t\t/** @type {SyncHook<Chunk, string>} */\n\t\t\tchunkAsset: new SyncHook([\"chunk\", \"filename\"]),\n\n\t\t\t/** @type {SyncWaterfallHook<string, TODO>} */\n\t\t\tassetPath: new SyncWaterfallHook([\"filename\", \"data\"]), // TODO MainTemplate\n\n\t\t\t/** @type {SyncBailHook} */\n\t\t\tneedAdditionalPass: new SyncBailHook([]),\n\n\t\t\t/** @type {SyncHook<Compiler, string, number>} */\n\t\t\tchildCompiler: new SyncHook([\n\t\t\t\t\"childCompiler\",\n\t\t\t\t\"compilerName\",\n\t\t\t\t\"compilerIndex\"\n\t\t\t]),\n\n\t\t\t/** @type {SyncBailHook<string, LogEntry>} */\n\t\t\tlog: new SyncBailHook([\"origin\", \"logEntry\"]),\n\n\t\t\t// TODO the following hooks are weirdly located here\n\t\t\t// TODO move them for webpack 5\n\t\t\t/** @type {SyncHook<object, Module>} */\n\t\t\tnormalModuleLoader: new SyncHook([\"loaderContext\", \"module\"]),\n\n\t\t\t/** @type {SyncBailHook<Chunk[]>} */\n\t\t\toptimizeExtractedChunksBasic: new SyncBailHook([\"chunks\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[]>} */\n\t\t\toptimizeExtractedChunks: new SyncBailHook([\"chunks\"]),\n\t\t\t/** @type {SyncBailHook<Chunk[]>} */\n\t\t\toptimizeExtractedChunksAdvanced: new SyncBailHook([\"chunks\"]),\n\t\t\t/** @type {SyncHook<Chunk[]>} */\n\t\t\tafterOptimizeExtractedChunks: new SyncHook([\"chunks\"])\n\t\t};\n\t\tthis._pluginCompat.tap(\"Compilation\", options => {\n\t\t\tswitch (options.name) {\n\t\t\t\tcase \"optimize-tree\":\n\t\t\t\tcase \"additional-assets\":\n\t\t\t\tcase \"optimize-chunk-assets\":\n\t\t\t\tcase \"optimize-assets\":\n\t\t\t\tcase \"after-seal\":\n\t\t\t\t\toptions.async = true;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\t\t/** @type {string=} */\n\t\tthis.name = undefined;\n\t\t/** @type {Compiler} */\n\t\tthis.compiler = compiler;\n\t\tthis.resolverFactory = compiler.resolverFactory;\n\t\tthis.inputFileSystem = compiler.inputFileSystem;\n\t\tthis.requestShortener = compiler.requestShortener;\n\n\t\tconst options = compiler.options;\n\t\tthis.options = options;\n\t\tthis.outputOptions = options && options.output;\n\t\t/** @type {boolean=} */\n\t\tthis.bail = options && options.bail;\n\t\tthis.profile = options && options.profile;\n\t\tthis.performance = options && options.performance;\n\n\t\tthis.mainTemplate = new MainTemplate(this.outputOptions);\n\t\tthis.chunkTemplate = new ChunkTemplate(this.outputOptions);\n\t\tthis.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(\n\t\t\tthis.outputOptions\n\t\t);\n\t\tthis.runtimeTemplate = new RuntimeTemplate(\n\t\t\tthis.outputOptions,\n\t\t\tthis.requestShortener\n\t\t);\n\t\tthis.moduleTemplates = {\n\t\t\tjavascript: new ModuleTemplate(this.runtimeTemplate, \"javascript\"),\n\t\t\twebassembly: new ModuleTemplate(this.runtimeTemplate, \"webassembly\")\n\t\t};\n\n\t\tthis.semaphore = new Semaphore(options.parallelism || 100);\n\n\t\tthis.entries = [];\n\t\t/** @private @type {{name: string, request: string, module: Module}[]} */\n\t\tthis._preparedEntrypoints = [];\n\t\t/** @type {Map<string, Entrypoint>} */\n\t\tthis.entrypoints = new Map();\n\t\t/** @type {Chunk[]} */\n\t\tthis.chunks = [];\n\t\t/** @type {ChunkGroup[]} */\n\t\tthis.chunkGroups = [];\n\t\t/** @type {Map<string, ChunkGroup>} */\n\t\tthis.namedChunkGroups = new Map();\n\t\t/** @type {Map<string, Chunk>} */\n\t\tthis.namedChunks = new Map();\n\t\t/** @type {Module[]} */\n\t\tthis.modules = [];\n\t\t/** @private @type {Map<string, Module>} */\n\t\tthis._modules = new Map();\n\t\tthis.cache = null;\n\t\tthis.records = null;\n\t\t/** @type {string[]} */\n\t\tthis.additionalChunkAssets = [];\n\t\t/** @type {CompilationAssets} */\n\t\tthis.assets = {};\n\t\t/** @type {Map<string, AssetInfo>} */\n\t\tthis.assetsInfo = new Map();\n\t\t/** @type {WebpackError[]} */\n\t\tthis.errors = [];\n\t\t/** @type {WebpackError[]} */\n\t\tthis.warnings = [];\n\t\t/** @type {Compilation[]} */\n\t\tthis.children = [];\n\t\t/** @type {Map<string, LogEntry[]>} */\n\t\tthis.logging = new Map();\n\t\t/** @type {Map<DepConstructor, ModuleFactory>} */\n\t\tthis.dependencyFactories = new Map();\n\t\t/** @type {Map<DepConstructor, DependencyTemplate>} */\n\t\tthis.dependencyTemplates = new Map();\n\t\t// TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property\n\t\t// @ts-ignore\n\t\tthis.dependencyTemplates.set(\"hash\", \"\");\n\t\tthis.childrenCounters = {};\n\t\t/** @type {Set<number|string>} */\n\t\tthis.usedChunkIds = null;\n\t\t/** @type {Set<number>} */\n\t\tthis.usedModuleIds = null;\n\t\t/** @type {Map<string, number>=} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {Map<string, number>=} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {Set<string>=} */\n\t\tthis.compilationDependencies = undefined;\n\t\t/** @private @type {Map<Module, Callback[]>} */\n\t\tthis._buildingModules = new Map();\n\t\t/** @private @type {Map<Module, Callback[]>} */\n\t\tthis._rebuildingModules = new Map();\n\t\t/** @type {Set<string>} */\n\t\tthis.emittedAssets = new Set();\n\t}\n\n\tgetStats() {\n\t\treturn new Stats(this);\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetLogger(name) {\n\t\tif (!name) {\n\t\t\tthrow new TypeError(\"Compilation.getLogger(name) called without a name\");\n\t\t}\n\t\t/** @type {LogEntry[] | undefined} */\n\t\tlet logEntries;\n\t\treturn new Logger((type, args) => {\n\t\t\tif (typeof name === \"function\") {\n\t\t\t\tname = name();\n\t\t\t\tif (!name) {\n\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\"Compilation.getLogger(name) called with a function not returning a name\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet trace;\n\t\t\tswitch (type) {\n\t\t\t\tcase LogType.warn:\n\t\t\t\tcase LogType.error:\n\t\t\t\tcase LogType.trace:\n\t\t\t\t\ttrace = ErrorHelpers.cutOffLoaderExecution(new Error(\"Trace\").stack)\n\t\t\t\t\t\t.split(\"\\n\")\n\t\t\t\t\t\t.slice(3);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/** @type {LogEntry} */\n\t\t\tconst logEntry = {\n\t\t\t\ttime: Date.now(),\n\t\t\t\ttype,\n\t\t\t\targs,\n\t\t\t\ttrace\n\t\t\t};\n\t\t\tif (this.hooks.log.call(name, logEntry) === undefined) {\n\t\t\t\tif (logEntry.type === LogType.profileEnd) {\n\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\tif (typeof console.profileEnd === \"function\") {\n\t\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\t\tconsole.profileEnd(`[${name}] ${logEntry.args[0]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (logEntries === undefined) {\n\t\t\t\t\tlogEntries = this.logging.get(name);\n\t\t\t\t\tif (logEntries === undefined) {\n\t\t\t\t\t\tlogEntries = [];\n\t\t\t\t\t\tthis.logging.set(name, logEntries);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlogEntries.push(logEntry);\n\t\t\t\tif (logEntry.type === LogType.profile) {\n\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\tif (typeof console.profile === \"function\") {\n\t\t\t\t\t\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\t\t\t\t\t\tconsole.profile(`[${name}] ${logEntry.args[0]}`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @typedef {Object} AddModuleResult\n\t * @property {Module} module the added or existing module\n\t * @property {boolean} issuer was this the first request for this module\n\t * @property {boolean} build should the module be build\n\t * @property {boolean} dependencies should dependencies be walked\n\t */\n\n\t/**\n\t * @param {Module} module module to be added that was created\n\t * @param {any=} cacheGroup cacheGroup it is apart of\n\t * @returns {AddModuleResult} returns meta about whether or not the module had built\n\t * had an issuer, or any dependnecies\n\t */\n\taddModule(module, cacheGroup) {\n\t\tconst identifier = module.identifier();\n\t\tconst alreadyAddedModule = this._modules.get(identifier);\n\t\tif (alreadyAddedModule) {\n\t\t\treturn {\n\t\t\t\tmodule: alreadyAddedModule,\n\t\t\t\tissuer: false,\n\t\t\t\tbuild: false,\n\t\t\t\tdependencies: false\n\t\t\t};\n\t\t}\n\t\tconst cacheName = (cacheGroup || \"m\") + identifier;\n\t\tif (this.cache && this.cache[cacheName]) {\n\t\t\tconst cacheModule = this.cache[cacheName];\n\n\t\t\tif (typeof cacheModule.updateCacheModule === \"function\") {\n\t\t\t\tcacheModule.updateCacheModule(module);\n\t\t\t}\n\n\t\t\tlet rebuild = true;\n\t\t\tif (this.fileTimestamps && this.contextTimestamps) {\n\t\t\t\trebuild = cacheModule.needRebuild(\n\t\t\t\t\tthis.fileTimestamps,\n\t\t\t\t\tthis.contextTimestamps\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!rebuild) {\n\t\t\t\tcacheModule.disconnect();\n\t\t\t\tthis._modules.set(identifier, cacheModule);\n\t\t\t\tthis.modules.push(cacheModule);\n\t\t\t\tfor (const err of cacheModule.errors) {\n\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t}\n\t\t\t\tfor (const err of cacheModule.warnings) {\n\t\t\t\t\tthis.warnings.push(err);\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tmodule: cacheModule,\n\t\t\t\t\tissuer: true,\n\t\t\t\t\tbuild: false,\n\t\t\t\t\tdependencies: true\n\t\t\t\t};\n\t\t\t}\n\t\t\tcacheModule.unbuild();\n\t\t\tmodule = cacheModule;\n\t\t}\n\t\tthis._modules.set(identifier, module);\n\t\tif (this.cache) {\n\t\t\tthis.cache[cacheName] = module;\n\t\t}\n\t\tthis.modules.push(module);\n\t\treturn {\n\t\t\tmodule: module,\n\t\t\tissuer: true,\n\t\t\tbuild: true,\n\t\t\tdependencies: true\n\t\t};\n\t}\n\n\t/**\n\t * Fetches a module from a compilation by its identifier\n\t * @param {Module} module the module provided\n\t * @returns {Module} the module requested\n\t */\n\tgetModule(module) {\n\t\tconst identifier = module.identifier();\n\t\treturn this._modules.get(identifier);\n\t}\n\n\t/**\n\t * Attempts to search for a module by its identifier\n\t * @param {string} identifier identifier (usually path) for module\n\t * @returns {Module|undefined} attempt to search for module and return it, else undefined\n\t */\n\tfindModule(identifier) {\n\t\treturn this._modules.get(identifier);\n\t}\n\n\t/**\n\t * @param {Module} module module with its callback list\n\t * @param {Callback} callback the callback function\n\t * @returns {void}\n\t */\n\twaitForBuildingFinished(module, callback) {\n\t\tlet callbackList = this._buildingModules.get(module);\n\t\tif (callbackList) {\n\t\t\tcallbackList.push(() => callback());\n\t\t} else {\n\t\t\tprocess.nextTick(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Builds the module object\n\t *\n\t * @param {Module} module module to be built\n\t * @param {boolean} optional optional flag\n\t * @param {Module=} origin origin module this module build was requested from\n\t * @param {Dependency[]=} dependencies optional dependencies from the module to be built\n\t * @param {TODO} thisCallback the callback\n\t * @returns {TODO} returns the callback function with results\n\t */\n\tbuildModule(module, optional, origin, dependencies, thisCallback) {\n\t\tlet callbackList = this._buildingModules.get(module);\n\t\tif (callbackList) {\n\t\t\tcallbackList.push(thisCallback);\n\t\t\treturn;\n\t\t}\n\t\tthis._buildingModules.set(module, (callbackList = [thisCallback]));\n\n\t\tconst callback = err => {\n\t\t\tthis._buildingModules.delete(module);\n\t\t\tfor (const cb of callbackList) {\n\t\t\t\tcb(err);\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.buildModule.call(module);\n\t\tmodule.build(\n\t\t\tthis.options,\n\t\t\tthis,\n\t\t\tthis.resolverFactory.get(\"normal\", module.resolveOptions),\n\t\t\tthis.inputFileSystem,\n\t\t\terror => {\n\t\t\t\tconst errors = module.errors;\n\t\t\t\tfor (let indexError = 0; indexError < errors.length; indexError++) {\n\t\t\t\t\tconst err = errors[indexError];\n\t\t\t\t\terr.origin = origin;\n\t\t\t\t\terr.dependencies = dependencies;\n\t\t\t\t\tif (optional) {\n\t\t\t\t\t\tthis.warnings.push(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst warnings = module.warnings;\n\t\t\t\tfor (\n\t\t\t\t\tlet indexWarning = 0;\n\t\t\t\t\tindexWarning < warnings.length;\n\t\t\t\t\tindexWarning++\n\t\t\t\t) {\n\t\t\t\t\tconst war = warnings[indexWarning];\n\t\t\t\t\twar.origin = origin;\n\t\t\t\t\twar.dependencies = dependencies;\n\t\t\t\t\tthis.warnings.push(war);\n\t\t\t\t}\n\t\t\t\tconst originalMap = module.dependencies.reduce((map, v, i) => {\n\t\t\t\t\tmap.set(v, i);\n\t\t\t\t\treturn map;\n\t\t\t\t}, new Map());\n\t\t\t\tmodule.dependencies.sort((a, b) => {\n\t\t\t\t\tconst cmp = compareLocations(a.loc, b.loc);\n\t\t\t\t\tif (cmp) return cmp;\n\t\t\t\t\treturn originalMap.get(a) - originalMap.get(b);\n\t\t\t\t});\n\t\t\t\tif (error) {\n\t\t\t\t\tthis.hooks.failedModule.call(module, error);\n\t\t\t\t\treturn callback(error);\n\t\t\t\t}\n\t\t\t\tthis.hooks.succeedModule.call(module);\n\t\t\t\treturn callback();\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module to be processed for deps\n\t * @param {ModuleCallback} callback callback to be triggered\n\t * @returns {void}\n\t */\n\tprocessModuleDependencies(module, callback) {\n\t\tconst dependencies = new Map();\n\n\t\tconst addDependency = dep => {\n\t\t\tconst resourceIdent = dep.getResourceIdentifier();\n\t\t\tif (resourceIdent) {\n\t\t\t\tconst factory = this.dependencyFactories.get(dep.constructor);\n\t\t\t\tif (factory === undefined) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`No module factory available for dependency type: ${dep.constructor.name}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet innerMap = dependencies.get(factory);\n\t\t\t\tif (innerMap === undefined) {\n\t\t\t\t\tdependencies.set(factory, (innerMap = new Map()));\n\t\t\t\t}\n\t\t\t\tlet list = innerMap.get(resourceIdent);\n\t\t\t\tif (list === undefined) innerMap.set(resourceIdent, (list = []));\n\t\t\t\tlist.push(dep);\n\t\t\t}\n\t\t};\n\n\t\tconst addDependenciesBlock = block => {\n\t\t\tif (block.dependencies) {\n\t\t\t\titerationOfArrayCallback(block.dependencies, addDependency);\n\t\t\t}\n\t\t\tif (block.blocks) {\n\t\t\t\titerationOfArrayCallback(block.blocks, addDependenciesBlock);\n\t\t\t}\n\t\t\tif (block.variables) {\n\t\t\t\titerationBlockVariable(block.variables, addDependency);\n\t\t\t}\n\t\t};\n\n\t\ttry {\n\t\t\taddDependenciesBlock(module);\n\t\t} catch (e) {\n\t\t\tcallback(e);\n\t\t}\n\n\t\tconst sortedDependencies = [];\n\n\t\tfor (const pair1 of dependencies) {\n\t\t\tfor (const pair2 of pair1[1]) {\n\t\t\t\tsortedDependencies.push({\n\t\t\t\t\tfactory: pair1[0],\n\t\t\t\t\tdependencies: pair2[1]\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis.addModuleDependencies(\n\t\t\tmodule,\n\t\t\tsortedDependencies,\n\t\t\tthis.bail,\n\t\t\tnull,\n\t\t\ttrue,\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module to add deps to\n\t * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through\n\t * @param {(boolean|null)=} bail whether to bail or not\n\t * @param {TODO} cacheGroup optional cacheGroup\n\t * @param {boolean} recursive whether it is recursive traversal\n\t * @param {function} callback callback for when dependencies are finished being added\n\t * @returns {void}\n\t */\n\taddModuleDependencies(\n\t\tmodule,\n\t\tdependencies,\n\t\tbail,\n\t\tcacheGroup,\n\t\trecursive,\n\t\tcallback\n\t) {\n\t\tconst start = this.profile && Date.now();\n\t\tconst currentProfile = this.profile && {};\n\n\t\tasyncLib.forEach(\n\t\t\tdependencies,\n\t\t\t(item, callback) => {\n\t\t\t\tconst dependencies = item.dependencies;\n\n\t\t\t\tconst errorAndCallback = err => {\n\t\t\t\t\terr.origin = module;\n\t\t\t\t\terr.dependencies = dependencies;\n\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t\tif (bail) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst warningAndCallback = err => {\n\t\t\t\t\terr.origin = module;\n\t\t\t\t\tthis.warnings.push(err);\n\t\t\t\t\tcallback();\n\t\t\t\t};\n\n\t\t\t\tconst semaphore = this.semaphore;\n\t\t\t\tsemaphore.acquire(() => {\n\t\t\t\t\tconst factory = item.factory;\n\t\t\t\t\tfactory.create(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\t\t\tissuer: module.nameForCondition && module.nameForCondition(),\n\t\t\t\t\t\t\t\tcompiler: this.compiler.name\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tresolveOptions: module.resolveOptions,\n\t\t\t\t\t\t\tcontext: module.context,\n\t\t\t\t\t\t\tdependencies: dependencies\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(err, dependentModule) => {\n\t\t\t\t\t\t\tlet afterFactory;\n\n\t\t\t\t\t\t\tconst isOptional = () => {\n\t\t\t\t\t\t\t\treturn dependencies.every(d => d.optional);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst errorOrWarningAndCallback = err => {\n\t\t\t\t\t\t\t\tif (isOptional()) {\n\t\t\t\t\t\t\t\t\treturn warningAndCallback(err);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn errorAndCallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\treturn errorOrWarningAndCallback(\n\t\t\t\t\t\t\t\t\tnew ModuleNotFoundError(module, err)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!dependentModule) {\n\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\treturn process.nextTick(callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\tafterFactory = Date.now();\n\t\t\t\t\t\t\t\tcurrentProfile.factory = afterFactory - start;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst iterationDependencies = depend => {\n\t\t\t\t\t\t\t\tfor (let index = 0; index < depend.length; index++) {\n\t\t\t\t\t\t\t\t\tconst dep = depend[index];\n\t\t\t\t\t\t\t\t\tdep.module = dependentModule;\n\t\t\t\t\t\t\t\t\tdependentModule.addReason(module, dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst addModuleResult = this.addModule(\n\t\t\t\t\t\t\t\tdependentModule,\n\t\t\t\t\t\t\t\tcacheGroup\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdependentModule = addModuleResult.module;\n\t\t\t\t\t\t\titerationDependencies(dependencies);\n\n\t\t\t\t\t\t\tconst afterBuild = () => {\n\t\t\t\t\t\t\t\tif (recursive && addModuleResult.dependencies) {\n\t\t\t\t\t\t\t\t\tthis.processModuleDependencies(dependentModule, callback);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tif (addModuleResult.issuer) {\n\t\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\t\tdependentModule.profile = currentProfile;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdependentModule.issuer = module;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (this.profile) {\n\t\t\t\t\t\t\t\t\tif (module.profile) {\n\t\t\t\t\t\t\t\t\t\tconst time = Date.now() - start;\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\t!module.profile.dependencies ||\n\t\t\t\t\t\t\t\t\t\t\ttime > module.profile.dependencies\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tmodule.profile.dependencies = time;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (addModuleResult.build) {\n\t\t\t\t\t\t\t\tthis.buildModule(\n\t\t\t\t\t\t\t\t\tdependentModule,\n\t\t\t\t\t\t\t\t\tisOptional(),\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tdependencies,\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\t\t\t\treturn errorOrWarningAndCallback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\t\t\t\tconst afterBuilding = Date.now();\n\t\t\t\t\t\t\t\t\t\t\tcurrentProfile.building = afterBuilding - afterFactory;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\t\t\tafterBuild();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsemaphore.release();\n\t\t\t\t\t\t\t\tthis.waitForBuildingFinished(dependentModule, afterBuild);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\t// In V8, the Error objects keep a reference to the functions on the stack. These warnings &\n\t\t\t\t// errors are created inside closures that keep a reference to the Compilation, so errors are\n\t\t\t\t// leaking the Compilation object.\n\n\t\t\t\tif (err) {\n\t\t\t\t\t// eslint-disable-next-line no-self-assign\n\t\t\t\t\terr.stack = err.stack;\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\treturn process.nextTick(callback);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t *\n\t * @param {string} context context string path\n\t * @param {Dependency} dependency dependency used to create Module chain\n\t * @param {OnModuleCallback} onModule function invoked on modules creation\n\t * @param {ModuleChainCallback} callback callback for when module chain is complete\n\t * @returns {void} will throw if dependency instance is not a valid Dependency\n\t */\n\t_addModuleChain(context, dependency, onModule, callback) {\n\t\tconst start = this.profile && Date.now();\n\t\tconst currentProfile = this.profile && {};\n\n\t\tconst errorAndCallback = this.bail\n\t\t\t? err => {\n\t\t\t\t\tcallback(err);\n\t\t\t  }\n\t\t\t: err => {\n\t\t\t\t\terr.dependencies = [dependency];\n\t\t\t\t\tthis.errors.push(err);\n\t\t\t\t\tcallback();\n\t\t\t  };\n\n\t\tif (\n\t\t\ttypeof dependency !== \"object\" ||\n\t\t\tdependency === null ||\n\t\t\t!dependency.constructor\n\t\t) {\n\t\t\tthrow new Error(\"Parameter 'dependency' must be a Dependency\");\n\t\t}\n\t\tconst Dep = /** @type {DepConstructor} */ (dependency.constructor);\n\t\tconst moduleFactory = this.dependencyFactories.get(Dep);\n\t\tif (!moduleFactory) {\n\t\t\tthrow new Error(\n\t\t\t\t`No dependency factory available for this dependency type: ${dependency.constructor.name}`\n\t\t\t);\n\t\t}\n\n\t\tthis.semaphore.acquire(() => {\n\t\t\tmoduleFactory.create(\n\t\t\t\t{\n\t\t\t\t\tcontextInfo: {\n\t\t\t\t\t\tissuer: \"\",\n\t\t\t\t\t\tcompiler: this.compiler.name\n\t\t\t\t\t},\n\t\t\t\t\tcontext: context,\n\t\t\t\t\tdependencies: [dependency]\n\t\t\t\t},\n\t\t\t\t(err, module) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\treturn errorAndCallback(new EntryModuleNotFoundError(err));\n\t\t\t\t\t}\n\n\t\t\t\t\tlet afterFactory;\n\n\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\tafterFactory = Date.now();\n\t\t\t\t\t\tcurrentProfile.factory = afterFactory - start;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst addModuleResult = this.addModule(module);\n\t\t\t\t\tmodule = addModuleResult.module;\n\n\t\t\t\t\tonModule(module);\n\n\t\t\t\t\tdependency.module = module;\n\t\t\t\t\tmodule.addReason(null, dependency);\n\n\t\t\t\t\tconst afterBuild = () => {\n\t\t\t\t\t\tif (addModuleResult.dependencies) {\n\t\t\t\t\t\t\tthis.processModuleDependencies(module, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tcallback(null, module);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn callback(null, module);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (addModuleResult.issuer) {\n\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\tmodule.profile = currentProfile;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (addModuleResult.build) {\n\t\t\t\t\t\tthis.buildModule(module, false, null, null, err => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\t\t\treturn errorAndCallback(err);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (currentProfile) {\n\t\t\t\t\t\t\t\tconst afterBuilding = Date.now();\n\t\t\t\t\t\t\t\tcurrentProfile.building = afterBuilding - afterFactory;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\t\tafterBuild();\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.semaphore.release();\n\t\t\t\t\t\tthis.waitForBuildingFinished(module, afterBuild);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t *\n\t * @param {string} context context path for entry\n\t * @param {Dependency} entry entry dependency being created\n\t * @param {string} name name of entry\n\t * @param {ModuleCallback} callback callback function\n\t * @returns {void} returns\n\t */\n\taddEntry(context, entry, name, callback) {\n\t\tthis.hooks.addEntry.call(entry, name);\n\n\t\tconst slot = {\n\t\t\tname: name,\n\t\t\t// TODO webpack 5 remove `request`\n\t\t\trequest: null,\n\t\t\tmodule: null\n\t\t};\n\n\t\tif (entry instanceof ModuleDependency) {\n\t\t\tslot.request = entry.request;\n\t\t}\n\n\t\t// TODO webpack 5: merge modules instead when multiple entry modules are supported\n\t\tconst idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);\n\t\tif (idx >= 0) {\n\t\t\t// Overwrite existing entrypoint\n\t\t\tthis._preparedEntrypoints[idx] = slot;\n\t\t} else {\n\t\t\tthis._preparedEntrypoints.push(slot);\n\t\t}\n\t\tthis._addModuleChain(\n\t\t\tcontext,\n\t\t\tentry,\n\t\t\tmodule => {\n\t\t\t\tthis.entries.push(module);\n\t\t\t},\n\t\t\t(err, module) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tthis.hooks.failedEntry.call(entry, name, err);\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tif (module) {\n\t\t\t\t\tslot.module = module;\n\t\t\t\t} else {\n\t\t\t\t\tconst idx = this._preparedEntrypoints.indexOf(slot);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tthis._preparedEntrypoints.splice(idx, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.hooks.succeedEntry.call(entry, name, module);\n\t\t\t\treturn callback(null, module);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} context context path string\n\t * @param {Dependency} dependency dep used to create module\n\t * @param {ModuleCallback} callback module callback sending module up a level\n\t * @returns {void}\n\t */\n\tprefetch(context, dependency, callback) {\n\t\tthis._addModuleChain(\n\t\t\tcontext,\n\t\t\tdependency,\n\t\t\tmodule => {\n\t\t\t\tmodule.prefetched = true;\n\t\t\t},\n\t\t\tcallback\n\t\t);\n\t}\n\n\t/**\n\t * @param {Module} module module to be rebuilt\n\t * @param {Callback} thisCallback callback when module finishes rebuilding\n\t * @returns {void}\n\t */\n\trebuildModule(module, thisCallback) {\n\t\tlet callbackList = this._rebuildingModules.get(module);\n\t\tif (callbackList) {\n\t\t\tcallbackList.push(thisCallback);\n\t\t\treturn;\n\t\t}\n\t\tthis._rebuildingModules.set(module, (callbackList = [thisCallback]));\n\n\t\tconst callback = err => {\n\t\t\tthis._rebuildingModules.delete(module);\n\t\t\tfor (const cb of callbackList) {\n\t\t\t\tcb(err);\n\t\t\t}\n\t\t};\n\n\t\tthis.hooks.rebuildModule.call(module);\n\t\tconst oldDependencies = module.dependencies.slice();\n\t\tconst oldVariables = module.variables.slice();\n\t\tconst oldBlocks = module.blocks.slice();\n\t\tmodule.unbuild();\n\t\tthis.buildModule(module, false, module, null, err => {\n\t\t\tif (err) {\n\t\t\t\tthis.hooks.finishRebuildingModule.call(module);\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tthis.processModuleDependencies(module, err => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tthis.removeReasonsOfDependencyBlock(module, {\n\t\t\t\t\tdependencies: oldDependencies,\n\t\t\t\t\tvariables: oldVariables,\n\t\t\t\t\tblocks: oldBlocks\n\t\t\t\t});\n\t\t\t\tthis.hooks.finishRebuildingModule.call(module);\n\t\t\t\tcallback();\n\t\t\t});\n\t\t});\n\t}\n\n\tfinish(callback) {\n\t\tconst modules = this.modules;\n\t\tthis.hooks.finishModules.callAsync(modules, err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tfor (let index = 0; index < modules.length; index++) {\n\t\t\t\tconst module = modules[index];\n\t\t\t\tthis.reportDependencyErrorsAndWarnings(module, [module]);\n\t\t\t}\n\n\t\t\tcallback();\n\t\t});\n\t}\n\n\tunseal() {\n\t\tthis.hooks.unseal.call();\n\t\tthis.chunks.length = 0;\n\t\tthis.chunkGroups.length = 0;\n\t\tthis.namedChunks.clear();\n\t\tthis.namedChunkGroups.clear();\n\t\tthis.additionalChunkAssets.length = 0;\n\t\tthis.assets = {};\n\t\tthis.assetsInfo.clear();\n\t\tfor (const module of this.modules) {\n\t\t\tmodule.unseal();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback} callback signals when the seal method is finishes\n\t * @returns {void}\n\t */\n\tseal(callback) {\n\t\tthis.hooks.seal.call();\n\n\t\twhile (\n\t\t\tthis.hooks.optimizeDependenciesBasic.call(this.modules) ||\n\t\t\tthis.hooks.optimizeDependencies.call(this.modules) ||\n\t\t\tthis.hooks.optimizeDependenciesAdvanced.call(this.modules)\n\t\t) {\n\t\t\t/* empty */\n\t\t}\n\t\tthis.hooks.afterOptimizeDependencies.call(this.modules);\n\n\t\tthis.hooks.beforeChunks.call();\n\t\tfor (const preparedEntrypoint of this._preparedEntrypoints) {\n\t\t\tconst module = preparedEntrypoint.module;\n\t\t\tconst name = preparedEntrypoint.name;\n\t\t\tconst chunk = this.addChunk(name);\n\t\t\tconst entrypoint = new Entrypoint(name);\n\t\t\tentrypoint.setRuntimeChunk(chunk);\n\t\t\tentrypoint.addOrigin(null, name, preparedEntrypoint.request);\n\t\t\tthis.namedChunkGroups.set(name, entrypoint);\n\t\t\tthis.entrypoints.set(name, entrypoint);\n\t\t\tthis.chunkGroups.push(entrypoint);\n\n\t\t\tGraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);\n\t\t\tGraphHelpers.connectChunkAndModule(chunk, module);\n\n\t\t\tchunk.entryModule = module;\n\t\t\tchunk.name = name;\n\n\t\t\tthis.assignDepth(module);\n\t\t}\n\t\tbuildChunkGraph(\n\t\t\tthis,\n\t\t\t/** @type {Entrypoint[]} */ (this.chunkGroups.slice())\n\t\t);\n\t\tthis.sortModules(this.modules);\n\t\tthis.hooks.afterChunks.call(this.chunks);\n\n\t\tthis.hooks.optimize.call();\n\n\t\twhile (\n\t\t\tthis.hooks.optimizeModulesBasic.call(this.modules) ||\n\t\t\tthis.hooks.optimizeModules.call(this.modules) ||\n\t\t\tthis.hooks.optimizeModulesAdvanced.call(this.modules)\n\t\t) {\n\t\t\t/* empty */\n\t\t}\n\t\tthis.hooks.afterOptimizeModules.call(this.modules);\n\n\t\twhile (\n\t\t\tthis.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) ||\n\t\t\tthis.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) ||\n\t\t\tthis.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)\n\t\t) {\n\t\t\t/* empty */\n\t\t}\n\t\tthis.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);\n\n\t\tthis.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {\n\t\t\tif (err) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\n\t\t\tthis.hooks.afterOptimizeTree.call(this.chunks, this.modules);\n\n\t\t\twhile (\n\t\t\t\tthis.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) ||\n\t\t\t\tthis.hooks.optimizeChunkModules.call(this.chunks, this.modules) ||\n\t\t\t\tthis.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)\n\t\t\t) {\n\t\t\t\t/* empty */\n\t\t\t}\n\t\t\tthis.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);\n\n\t\t\tconst shouldRecord = this.hooks.shouldRecord.call() !== false;\n\n\t\t\tthis.hooks.reviveModules.call(this.modules, this.records);\n\t\t\tthis.hooks.optimizeModuleOrder.call(this.modules);\n\t\t\tthis.hooks.advancedOptimizeModuleOrder.call(this.modules);\n\t\t\tthis.hooks.beforeModuleIds.call(this.modules);\n\t\t\tthis.hooks.moduleIds.call(this.modules);\n\t\t\tthis.applyModuleIds();\n\t\t\tthis.hooks.optimizeModuleIds.call(this.modules);\n\t\t\tthis.hooks.afterOptimizeModuleIds.call(this.modules);\n\n\t\t\tthis.sortItemsWithModuleIds();\n\n\t\t\tthis.hooks.reviveChunks.call(this.chunks, this.records);\n\t\t\tthis.hooks.optimizeChunkOrder.call(this.chunks);\n\t\t\tthis.hooks.beforeChunkIds.call(this.chunks);\n\t\t\tthis.applyChunkIds();\n\t\t\tthis.hooks.optimizeChunkIds.call(this.chunks);\n\t\t\tthis.hooks.afterOptimizeChunkIds.call(this.chunks);\n\n\t\t\tthis.sortItemsWithChunkIds();\n\n\t\t\tif (shouldRecord) {\n\t\t\t\tthis.hooks.recordModules.call(this.modules, this.records);\n\t\t\t\tthis.hooks.recordChunks.call(this.chunks, this.records);\n\t\t\t}\n\n\t\t\tthis.hooks.beforeHash.call();\n\t\t\tthis.createHash();\n\t\t\tthis.hooks.afterHash.call();\n\n\t\t\tif (shouldRecord) {\n\t\t\t\tthis.hooks.recordHash.call(this.records);\n\t\t\t}\n\n\t\t\tthis.hooks.beforeModuleAssets.call();\n\t\t\tthis.createModuleAssets();\n\t\t\tif (this.hooks.shouldGenerateChunkAssets.call() !== false) {\n\t\t\t\tthis.hooks.beforeChunkAssets.call();\n\t\t\t\tthis.createChunkAssets();\n\t\t\t}\n\t\t\tthis.hooks.additionalChunkAssets.call(this.chunks);\n\t\t\tthis.summarizeDependencies();\n\t\t\tif (shouldRecord) {\n\t\t\t\tthis.hooks.record.call(this, this.records);\n\t\t\t}\n\n\t\t\tthis.hooks.additionalAssets.callAsync(err => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tthis.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\t\t\t\t\tthis.hooks.afterOptimizeChunkAssets.call(this.chunks);\n\t\t\t\t\tthis.hooks.optimizeAssets.callAsync(this.assets, err => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.hooks.afterOptimizeAssets.call(this.assets);\n\t\t\t\t\t\tif (this.hooks.needAdditionalSeal.call()) {\n\t\t\t\t\t\t\tthis.unseal();\n\t\t\t\t\t\t\treturn this.seal(callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.hooks.afterSeal.callAsync(callback);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {Module[]} modules the modules array on compilation to perform the sort for\n\t * @returns {void}\n\t */\n\tsortModules(modules) {\n\t\t// TODO webpack 5: this should only be enabled when `moduleIds: \"natural\"`\n\t\t// TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply\n\t\t// TODO remove this method\n\t\tmodules.sort(byIndexOrIdentifier);\n\t}\n\n\t/**\n\t * @param {Module} module moulde to report from\n\t * @param {DependenciesBlock[]} blocks blocks to report from\n\t * @returns {void}\n\t */\n\treportDependencyErrorsAndWarnings(module, blocks) {\n\t\tfor (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n\t\t\tconst block = blocks[indexBlock];\n\t\t\tconst dependencies = block.dependencies;\n\n\t\t\tfor (let indexDep = 0; indexDep < dependencies.length; indexDep++) {\n\t\t\t\tconst d = dependencies[indexDep];\n\n\t\t\t\tconst warnings = d.getWarnings();\n\t\t\t\tif (warnings) {\n\t\t\t\t\tfor (let indexWar = 0; indexWar < warnings.length; indexWar++) {\n\t\t\t\t\t\tconst w = warnings[indexWar];\n\n\t\t\t\t\t\tconst warning = new ModuleDependencyWarning(module, w, d.loc);\n\t\t\t\t\t\tthis.warnings.push(warning);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst errors = d.getErrors();\n\t\t\t\tif (errors) {\n\t\t\t\t\tfor (let indexErr = 0; indexErr < errors.length; indexErr++) {\n\t\t\t\t\t\tconst e = errors[indexErr];\n\n\t\t\t\t\t\tconst error = new ModuleDependencyError(module, e, d.loc);\n\t\t\t\t\t\tthis.errors.push(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.reportDependencyErrorsAndWarnings(module, block.blocks);\n\t\t}\n\t}\n\n\t/**\n\t * @param {TODO} groupOptions options for the chunk group\n\t * @param {Module} module the module the references the chunk group\n\t * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)\n\t * @param {string} request the request from which the the chunk group is referenced\n\t * @returns {ChunkGroup} the new or existing chunk group\n\t */\n\taddChunkInGroup(groupOptions, module, loc, request) {\n\t\tif (typeof groupOptions === \"string\") {\n\t\t\tgroupOptions = { name: groupOptions };\n\t\t}\n\t\tconst name = groupOptions.name;\n\t\tif (name) {\n\t\t\tconst chunkGroup = this.namedChunkGroups.get(name);\n\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\tchunkGroup.addOptions(groupOptions);\n\t\t\t\tif (module) {\n\t\t\t\t\tchunkGroup.addOrigin(module, loc, request);\n\t\t\t\t}\n\t\t\t\treturn chunkGroup;\n\t\t\t}\n\t\t}\n\t\tconst chunkGroup = new ChunkGroup(groupOptions);\n\t\tif (module) chunkGroup.addOrigin(module, loc, request);\n\t\tconst chunk = this.addChunk(name);\n\n\t\tGraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);\n\n\t\tthis.chunkGroups.push(chunkGroup);\n\t\tif (name) {\n\t\t\tthis.namedChunkGroups.set(name, chunkGroup);\n\t\t}\n\t\treturn chunkGroup;\n\t}\n\n\t/**\n\t * This method first looks to see if a name is provided for a new chunk,\n\t * and first looks to see if any named chunks already exist and reuse that chunk instead.\n\t *\n\t * @param {string=} name optional chunk name to be provided\n\t * @returns {Chunk} create a chunk (invoked during seal event)\n\t */\n\taddChunk(name) {\n\t\tif (name) {\n\t\t\tconst chunk = this.namedChunks.get(name);\n\t\t\tif (chunk !== undefined) {\n\t\t\t\treturn chunk;\n\t\t\t}\n\t\t}\n\t\tconst chunk = new Chunk(name);\n\t\tthis.chunks.push(chunk);\n\t\tif (name) {\n\t\t\tthis.namedChunks.set(name, chunk);\n\t\t}\n\t\treturn chunk;\n\t}\n\n\t/**\n\t * @param {Module} module module to assign depth\n\t * @returns {void}\n\t */\n\tassignDepth(module) {\n\t\tconst queue = new Set([module]);\n\t\tlet depth;\n\n\t\tmodule.depth = 0;\n\n\t\t/**\n\t\t * @param {Module} module module for processeing\n\t\t * @returns {void}\n\t\t */\n\t\tconst enqueueJob = module => {\n\t\t\tconst d = module.depth;\n\t\t\tif (typeof d === \"number\" && d <= depth) return;\n\t\t\tqueue.add(module);\n\t\t\tmodule.depth = depth;\n\t\t};\n\n\t\t/**\n\t\t * @param {Dependency} dependency dependency to assign depth to\n\t\t * @returns {void}\n\t\t */\n\t\tconst assignDepthToDependency = dependency => {\n\t\t\tif (dependency.module) {\n\t\t\t\tenqueueJob(dependency.module);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @param {DependenciesBlock} block block to assign depth to\n\t\t * @returns {void}\n\t\t */\n\t\tconst assignDepthToDependencyBlock = block => {\n\t\t\tif (block.variables) {\n\t\t\t\titerationBlockVariable(block.variables, assignDepthToDependency);\n\t\t\t}\n\n\t\t\tif (block.dependencies) {\n\t\t\t\titerationOfArrayCallback(block.dependencies, assignDepthToDependency);\n\t\t\t}\n\n\t\t\tif (block.blocks) {\n\t\t\t\titerationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);\n\t\t\t}\n\t\t};\n\n\t\tfor (module of queue) {\n\t\t\tqueue.delete(module);\n\t\t\tdepth = module.depth;\n\n\t\t\tdepth++;\n\t\t\tassignDepthToDependencyBlock(module);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module the module containing the dependency\n\t * @param {Dependency} dependency the dependency\n\t * @returns {DependencyReference} a reference for the dependency\n\t */\n\tgetDependencyReference(module, dependency) {\n\t\t// TODO remove dep.getReference existence check in webpack 5\n\t\tif (typeof dependency.getReference !== \"function\") return null;\n\t\tconst ref = dependency.getReference();\n\t\tif (!ref) return null;\n\t\treturn this.hooks.dependencyReference.call(ref, dependency, module);\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module module relationship for removal\n\t * @param {DependenciesBlockLike} block //TODO: good description\n\t * @returns {void}\n\t */\n\tremoveReasonsOfDependencyBlock(module, block) {\n\t\tconst iteratorDependency = d => {\n\t\t\tif (!d.module) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (d.module.removeReason(module, d)) {\n\t\t\t\tfor (const chunk of d.module.chunksIterable) {\n\t\t\t\t\tthis.patchChunksAfterReasonRemoval(d.module, chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tif (block.blocks) {\n\t\t\titerationOfArrayCallback(block.blocks, block =>\n\t\t\t\tthis.removeReasonsOfDependencyBlock(module, block)\n\t\t\t);\n\t\t}\n\n\t\tif (block.dependencies) {\n\t\t\titerationOfArrayCallback(block.dependencies, iteratorDependency);\n\t\t}\n\n\t\tif (block.variables) {\n\t\t\titerationBlockVariable(block.variables, iteratorDependency);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module module to patch tie\n\t * @param {Chunk} chunk chunk to patch tie\n\t * @returns {void}\n\t */\n\tpatchChunksAfterReasonRemoval(module, chunk) {\n\t\tif (!module.hasReasons()) {\n\t\t\tthis.removeReasonsOfDependencyBlock(module, module);\n\t\t}\n\t\tif (!module.hasReasonForChunk(chunk)) {\n\t\t\tif (module.removeChunk(chunk)) {\n\t\t\t\tthis.removeChunkFromDependencies(module, chunk);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {DependenciesBlock} block block tie for Chunk\n\t * @param {Chunk} chunk chunk to remove from dep\n\t * @returns {void}\n\t */\n\tremoveChunkFromDependencies(block, chunk) {\n\t\tconst iteratorDependency = d => {\n\t\t\tif (!d.module) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.patchChunksAfterReasonRemoval(d.module, chunk);\n\t\t};\n\n\t\tconst blocks = block.blocks;\n\t\tfor (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n\t\t\tconst asyncBlock = blocks[indexBlock];\n\t\t\t// Grab all chunks from the first Block's AsyncDepBlock\n\t\t\tconst chunks = asyncBlock.chunkGroup.chunks;\n\t\t\t// For each chunk in chunkGroup\n\t\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\t\tconst iteratedChunk = chunks[indexChunk];\n\t\t\t\tasyncBlock.chunkGroup.removeChunk(iteratedChunk);\n\t\t\t\tasyncBlock.chunkGroup.removeParent(iteratedChunk);\n\t\t\t\t// Recurse\n\t\t\t\tthis.removeChunkFromDependencies(block, iteratedChunk);\n\t\t\t}\n\t\t}\n\n\t\tif (block.dependencies) {\n\t\t\titerationOfArrayCallback(block.dependencies, iteratorDependency);\n\t\t}\n\n\t\tif (block.variables) {\n\t\t\titerationBlockVariable(block.variables, iteratorDependency);\n\t\t}\n\t}\n\n\tapplyModuleIds() {\n\t\tconst unusedIds = [];\n\t\tlet nextFreeModuleId = 0;\n\t\tconst usedIds = new Set();\n\t\tif (this.usedModuleIds) {\n\t\t\tfor (const id of this.usedModuleIds) {\n\t\t\t\tusedIds.add(id);\n\t\t\t}\n\t\t}\n\n\t\tconst modules1 = this.modules;\n\t\tfor (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {\n\t\t\tconst module1 = modules1[indexModule1];\n\t\t\tif (module1.id !== null) {\n\t\t\t\tusedIds.add(module1.id);\n\t\t\t}\n\t\t}\n\n\t\tif (usedIds.size > 0) {\n\t\t\tlet usedIdMax = -1;\n\t\t\tfor (const usedIdKey of usedIds) {\n\t\t\t\tif (typeof usedIdKey !== \"number\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tusedIdMax = Math.max(usedIdMax, usedIdKey);\n\t\t\t}\n\n\t\t\tlet lengthFreeModules = (nextFreeModuleId = usedIdMax + 1);\n\n\t\t\twhile (lengthFreeModules--) {\n\t\t\t\tif (!usedIds.has(lengthFreeModules)) {\n\t\t\t\t\tunusedIds.push(lengthFreeModules);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst modules2 = this.modules;\n\t\tfor (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {\n\t\t\tconst module2 = modules2[indexModule2];\n\t\t\tif (module2.id === null) {\n\t\t\t\tif (unusedIds.length > 0) {\n\t\t\t\t\tmodule2.id = unusedIds.pop();\n\t\t\t\t} else {\n\t\t\t\t\tmodule2.id = nextFreeModuleId++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tapplyChunkIds() {\n\t\t/** @type {Set<number>} */\n\t\tconst usedIds = new Set();\n\n\t\t// Get used ids from usedChunkIds property (i. e. from records)\n\t\tif (this.usedChunkIds) {\n\t\t\tfor (const id of this.usedChunkIds) {\n\t\t\t\tif (typeof id !== \"number\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tusedIds.add(id);\n\t\t\t}\n\t\t}\n\n\t\t// Get used ids from existing chunks\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tconst chunk = chunks[indexChunk];\n\t\t\tconst usedIdValue = chunk.id;\n\n\t\t\tif (typeof usedIdValue !== \"number\") {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tusedIds.add(usedIdValue);\n\t\t}\n\n\t\t// Calculate maximum assigned chunk id\n\t\tlet nextFreeChunkId = -1;\n\t\tfor (const id of usedIds) {\n\t\t\tnextFreeChunkId = Math.max(nextFreeChunkId, id);\n\t\t}\n\t\tnextFreeChunkId++;\n\n\t\t// Determine free chunk ids from 0 to maximum\n\t\t/** @type {number[]} */\n\t\tconst unusedIds = [];\n\t\tif (nextFreeChunkId > 0) {\n\t\t\tlet index = nextFreeChunkId;\n\t\t\twhile (index--) {\n\t\t\t\tif (!usedIds.has(index)) {\n\t\t\t\t\tunusedIds.push(index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Assign ids to chunk which has no id\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tconst chunk = chunks[indexChunk];\n\t\t\tif (chunk.id === null) {\n\t\t\t\tif (unusedIds.length > 0) {\n\t\t\t\t\tchunk.id = unusedIds.pop();\n\t\t\t\t} else {\n\t\t\t\t\tchunk.id = nextFreeChunkId++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!chunk.ids) {\n\t\t\t\tchunk.ids = [chunk.id];\n\t\t\t}\n\t\t}\n\t}\n\n\tsortItemsWithModuleIds() {\n\t\tthis.modules.sort(byIdOrIdentifier);\n\n\t\tconst modules = this.modules;\n\t\tfor (let indexModule = 0; indexModule < modules.length; indexModule++) {\n\t\t\tmodules[indexModule].sortItems(false);\n\t\t}\n\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tchunks[indexChunk].sortItems();\n\t\t}\n\n\t\tchunks.sort((a, b) => a.compareTo(b));\n\t}\n\n\tsortItemsWithChunkIds() {\n\t\tfor (const chunkGroup of this.chunkGroups) {\n\t\t\tchunkGroup.sortItems();\n\t\t}\n\n\t\tthis.chunks.sort(byId);\n\n\t\tfor (\n\t\t\tlet indexModule = 0;\n\t\t\tindexModule < this.modules.length;\n\t\t\tindexModule++\n\t\t) {\n\t\t\tthis.modules[indexModule].sortItems(true);\n\t\t}\n\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tchunks[indexChunk].sortItems();\n\t\t}\n\n\t\t/**\n\t\t * Used to sort errors and warnings in compilation. this.warnings, and\n\t\t * this.errors contribute to the compilation hash and therefore should be\n\t\t * updated whenever other references (having a chunk id) are sorted. This preserves the hash\n\t\t * integrity\n\t\t *\n\t\t * @param {WebpackError} a first WebpackError instance (including subclasses)\n\t\t * @param {WebpackError} b second WebpackError instance (including subclasses)\n\t\t * @returns {-1|0|1} sort order index\n\t\t */\n\t\tconst byMessage = (a, b) => {\n\t\t\tconst ma = `${a.message}`;\n\t\t\tconst mb = `${b.message}`;\n\t\t\tif (ma < mb) return -1;\n\t\t\tif (mb < ma) return 1;\n\t\t\treturn 0;\n\t\t};\n\n\t\tthis.errors.sort(byMessage);\n\t\tthis.warnings.sort(byMessage);\n\t\tthis.children.sort(byNameOrHash);\n\t}\n\n\tsummarizeDependencies() {\n\t\tthis.fileDependencies = new SortableSet(this.compilationDependencies);\n\t\tthis.contextDependencies = new SortableSet();\n\t\tthis.missingDependencies = new SortableSet();\n\n\t\tfor (\n\t\t\tlet indexChildren = 0;\n\t\t\tindexChildren < this.children.length;\n\t\t\tindexChildren++\n\t\t) {\n\t\t\tconst child = this.children[indexChildren];\n\n\t\t\taddAllToSet(this.fileDependencies, child.fileDependencies);\n\t\t\taddAllToSet(this.contextDependencies, child.contextDependencies);\n\t\t\taddAllToSet(this.missingDependencies, child.missingDependencies);\n\t\t}\n\n\t\tfor (\n\t\t\tlet indexModule = 0;\n\t\t\tindexModule < this.modules.length;\n\t\t\tindexModule++\n\t\t) {\n\t\t\tconst module = this.modules[indexModule];\n\n\t\t\tif (module.buildInfo.fileDependencies) {\n\t\t\t\taddAllToSet(this.fileDependencies, module.buildInfo.fileDependencies);\n\t\t\t}\n\t\t\tif (module.buildInfo.contextDependencies) {\n\t\t\t\taddAllToSet(\n\t\t\t\t\tthis.contextDependencies,\n\t\t\t\t\tmodule.buildInfo.contextDependencies\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tfor (const error of this.errors) {\n\t\t\tif (\n\t\t\t\ttypeof error.missing === \"object\" &&\n\t\t\t\terror.missing &&\n\t\t\t\terror.missing[Symbol.iterator]\n\t\t\t) {\n\t\t\t\taddAllToSet(this.missingDependencies, error.missing);\n\t\t\t}\n\t\t}\n\t\tthis.fileDependencies.sort();\n\t\tthis.contextDependencies.sort();\n\t\tthis.missingDependencies.sort();\n\t}\n\n\tcreateHash() {\n\t\tconst outputOptions = this.outputOptions;\n\t\tconst hashFunction = outputOptions.hashFunction;\n\t\tconst hashDigest = outputOptions.hashDigest;\n\t\tconst hashDigestLength = outputOptions.hashDigestLength;\n\t\tconst hash = createHash(hashFunction);\n\t\tif (outputOptions.hashSalt) {\n\t\t\thash.update(outputOptions.hashSalt);\n\t\t}\n\t\tthis.mainTemplate.updateHash(hash);\n\t\tthis.chunkTemplate.updateHash(hash);\n\t\tfor (const key of Object.keys(this.moduleTemplates).sort()) {\n\t\t\tthis.moduleTemplates[key].updateHash(hash);\n\t\t}\n\t\tfor (const child of this.children) {\n\t\t\thash.update(child.hash);\n\t\t}\n\t\tfor (const warning of this.warnings) {\n\t\t\thash.update(`${warning.message}`);\n\t\t}\n\t\tfor (const error of this.errors) {\n\t\t\thash.update(`${error.message}`);\n\t\t}\n\t\tconst modules = this.modules;\n\t\tfor (let i = 0; i < modules.length; i++) {\n\t\t\tconst module = modules[i];\n\t\t\tconst moduleHash = createHash(hashFunction);\n\t\t\tmodule.updateHash(moduleHash);\n\t\t\tmodule.hash = /** @type {string} */ (moduleHash.digest(hashDigest));\n\t\t\tmodule.renderedHash = module.hash.substr(0, hashDigestLength);\n\t\t}\n\t\t// clone needed as sort below is inplace mutation\n\t\tconst chunks = this.chunks.slice();\n\t\t/**\n\t\t * sort here will bring all \"falsy\" values to the beginning\n\t\t * this is needed as the \"hasRuntime()\" chunks are dependent on the\n\t\t * hashes of the non-runtime chunks.\n\t\t */\n\t\tchunks.sort((a, b) => {\n\t\t\tconst aEntry = a.hasRuntime();\n\t\t\tconst bEntry = b.hasRuntime();\n\t\t\tif (aEntry && !bEntry) return 1;\n\t\t\tif (!aEntry && bEntry) return -1;\n\t\t\treturn byId(a, b);\n\t\t});\n\t\tfor (let i = 0; i < chunks.length; i++) {\n\t\t\tconst chunk = chunks[i];\n\t\t\tconst chunkHash = createHash(hashFunction);\n\t\t\ttry {\n\t\t\t\tif (outputOptions.hashSalt) {\n\t\t\t\t\tchunkHash.update(outputOptions.hashSalt);\n\t\t\t\t}\n\t\t\t\tchunk.updateHash(chunkHash);\n\t\t\t\tconst template = chunk.hasRuntime()\n\t\t\t\t\t? this.mainTemplate\n\t\t\t\t\t: this.chunkTemplate;\n\t\t\t\ttemplate.updateHashForChunk(\n\t\t\t\t\tchunkHash,\n\t\t\t\t\tchunk,\n\t\t\t\t\tthis.moduleTemplates.javascript,\n\t\t\t\t\tthis.dependencyTemplates\n\t\t\t\t);\n\t\t\t\tthis.hooks.chunkHash.call(chunk, chunkHash);\n\t\t\t\tchunk.hash = /** @type {string} */ (chunkHash.digest(hashDigest));\n\t\t\t\thash.update(chunk.hash);\n\t\t\t\tchunk.renderedHash = chunk.hash.substr(0, hashDigestLength);\n\t\t\t\tthis.hooks.contentHash.call(chunk);\n\t\t\t} catch (err) {\n\t\t\t\tthis.errors.push(new ChunkRenderError(chunk, \"\", err));\n\t\t\t}\n\t\t}\n\t\tthis.fullHash = /** @type {string} */ (hash.digest(hashDigest));\n\t\tthis.hash = this.fullHash.substr(0, hashDigestLength);\n\t}\n\n\t/**\n\t * @param {string} update extra information\n\t * @returns {void}\n\t */\n\tmodifyHash(update) {\n\t\tconst outputOptions = this.outputOptions;\n\t\tconst hashFunction = outputOptions.hashFunction;\n\t\tconst hashDigest = outputOptions.hashDigest;\n\t\tconst hashDigestLength = outputOptions.hashDigestLength;\n\t\tconst hash = createHash(hashFunction);\n\t\thash.update(this.fullHash);\n\t\thash.update(update);\n\t\tthis.fullHash = /** @type {string} */ (hash.digest(hashDigest));\n\t\tthis.hash = this.fullHash.substr(0, hashDigestLength);\n\t}\n\n\t/**\n\t * @param {string} file file name\n\t * @param {Source} source asset source\n\t * @param {AssetInfo} assetInfo extra asset information\n\t * @returns {void}\n\t */\n\temitAsset(file, source, assetInfo = {}) {\n\t\tif (this.assets[file]) {\n\t\t\tif (!isSourceEqual(this.assets[file], source)) {\n\t\t\t\t// TODO webpack 5: make this an error instead\n\t\t\t\tthis.warnings.push(\n\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t`Conflict: Multiple assets emit different content to the same filename ${file}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t\tthis.assets[file] = source;\n\t\t\t\tthis.assetsInfo.set(file, assetInfo);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst oldInfo = this.assetsInfo.get(file);\n\t\t\tthis.assetsInfo.set(file, Object.assign({}, oldInfo, assetInfo));\n\t\t\treturn;\n\t\t}\n\t\tthis.assets[file] = source;\n\t\tthis.assetsInfo.set(file, assetInfo);\n\t}\n\n\t/**\n\t * @param {string} file file name\n\t * @param {Source | function(Source): Source} newSourceOrFunction new asset source or function converting old to new\n\t * @param {AssetInfo | function(AssetInfo | undefined): AssetInfo} assetInfoUpdateOrFunction new asset info or function converting old to new\n\t */\n\tupdateAsset(\n\t\tfile,\n\t\tnewSourceOrFunction,\n\t\tassetInfoUpdateOrFunction = undefined\n\t) {\n\t\tif (!this.assets[file]) {\n\t\t\tthrow new Error(\n\t\t\t\t`Called Compilation.updateAsset for not existing filename ${file}`\n\t\t\t);\n\t\t}\n\t\tif (typeof newSourceOrFunction === \"function\") {\n\t\t\tthis.assets[file] = newSourceOrFunction(this.assets[file]);\n\t\t} else {\n\t\t\tthis.assets[file] = newSourceOrFunction;\n\t\t}\n\t\tif (assetInfoUpdateOrFunction !== undefined) {\n\t\t\tconst oldInfo = this.assetsInfo.get(file);\n\t\t\tif (typeof assetInfoUpdateOrFunction === \"function\") {\n\t\t\t\tthis.assetsInfo.set(file, assetInfoUpdateOrFunction(oldInfo || {}));\n\t\t\t} else {\n\t\t\t\tthis.assetsInfo.set(\n\t\t\t\t\tfile,\n\t\t\t\t\tObject.assign({}, oldInfo, assetInfoUpdateOrFunction)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetAssets() {\n\t\t/** @type {Asset[]} */\n\t\tconst array = [];\n\t\tfor (const assetName of Object.keys(this.assets)) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(this.assets, assetName)) {\n\t\t\t\tarray.push({\n\t\t\t\t\tname: assetName,\n\t\t\t\t\tsource: this.assets[assetName],\n\t\t\t\t\tinfo: this.assetsInfo.get(assetName) || {}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn array;\n\t}\n\n\t/**\n\t * @param {string} name the name of the asset\n\t * @returns {Asset | undefined} the asset or undefined when not found\n\t */\n\tgetAsset(name) {\n\t\tif (!Object.prototype.hasOwnProperty.call(this.assets, name))\n\t\t\treturn undefined;\n\t\treturn {\n\t\t\tname,\n\t\t\tsource: this.assets[name],\n\t\t\tinfo: this.assetsInfo.get(name) || {}\n\t\t};\n\t}\n\n\tcreateModuleAssets() {\n\t\tfor (let i = 0; i < this.modules.length; i++) {\n\t\t\tconst module = this.modules[i];\n\t\t\tif (module.buildInfo.assets) {\n\t\t\t\tconst assetsInfo = module.buildInfo.assetsInfo;\n\t\t\t\tfor (const assetName of Object.keys(module.buildInfo.assets)) {\n\t\t\t\t\tconst fileName = this.getPath(assetName);\n\t\t\t\t\tthis.emitAsset(\n\t\t\t\t\t\tfileName,\n\t\t\t\t\t\tmodule.buildInfo.assets[assetName],\n\t\t\t\t\t\tassetsInfo ? assetsInfo.get(assetName) : undefined\n\t\t\t\t\t);\n\t\t\t\t\tthis.hooks.moduleAsset.call(module, fileName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateChunkAssets() {\n\t\tconst outputOptions = this.outputOptions;\n\t\tconst cachedSourceMap = new Map();\n\t\t/** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */\n\t\tconst alreadyWrittenFiles = new Map();\n\t\tfor (let i = 0; i < this.chunks.length; i++) {\n\t\t\tconst chunk = this.chunks[i];\n\t\t\tchunk.files = [];\n\t\t\tlet source;\n\t\t\tlet file;\n\t\t\tlet filenameTemplate;\n\t\t\ttry {\n\t\t\t\tconst template = chunk.hasRuntime()\n\t\t\t\t\t? this.mainTemplate\n\t\t\t\t\t: this.chunkTemplate;\n\t\t\t\tconst manifest = template.getRenderManifest({\n\t\t\t\t\tchunk,\n\t\t\t\t\thash: this.hash,\n\t\t\t\t\tfullHash: this.fullHash,\n\t\t\t\t\toutputOptions,\n\t\t\t\t\tmoduleTemplates: this.moduleTemplates,\n\t\t\t\t\tdependencyTemplates: this.dependencyTemplates\n\t\t\t\t}); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]\n\t\t\t\tfor (const fileManifest of manifest) {\n\t\t\t\t\tconst cacheName = fileManifest.identifier;\n\t\t\t\t\tconst usedHash = fileManifest.hash;\n\t\t\t\t\tfilenameTemplate = fileManifest.filenameTemplate;\n\t\t\t\t\tconst pathAndInfo = this.getPathWithInfo(\n\t\t\t\t\t\tfilenameTemplate,\n\t\t\t\t\t\tfileManifest.pathOptions\n\t\t\t\t\t);\n\t\t\t\t\tfile = pathAndInfo.path;\n\t\t\t\t\tconst assetInfo = pathAndInfo.info;\n\n\t\t\t\t\t// check if the same filename was already written by another chunk\n\t\t\t\t\tconst alreadyWritten = alreadyWrittenFiles.get(file);\n\t\t\t\t\tif (alreadyWritten !== undefined) {\n\t\t\t\t\t\tif (alreadyWritten.hash === usedHash) {\n\t\t\t\t\t\t\tif (this.cache) {\n\t\t\t\t\t\t\t\tthis.cache[cacheName] = {\n\t\t\t\t\t\t\t\t\thash: usedHash,\n\t\t\t\t\t\t\t\t\tsource: alreadyWritten.source\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunk.files.push(file);\n\t\t\t\t\t\t\tthis.hooks.chunkAsset.call(chunk, file);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Conflict: Multiple chunks emit assets to the same filename ${file}` +\n\t\t\t\t\t\t\t\t\t` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.cache &&\n\t\t\t\t\t\tthis.cache[cacheName] &&\n\t\t\t\t\t\tthis.cache[cacheName].hash === usedHash\n\t\t\t\t\t) {\n\t\t\t\t\t\tsource = this.cache[cacheName].source;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsource = fileManifest.render();\n\t\t\t\t\t\t// Ensure that source is a cached source to avoid additional cost because of repeated access\n\t\t\t\t\t\tif (!(source instanceof CachedSource)) {\n\t\t\t\t\t\t\tconst cacheEntry = cachedSourceMap.get(source);\n\t\t\t\t\t\t\tif (cacheEntry) {\n\t\t\t\t\t\t\t\tsource = cacheEntry;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst cachedSource = new CachedSource(source);\n\t\t\t\t\t\t\t\tcachedSourceMap.set(source, cachedSource);\n\t\t\t\t\t\t\t\tsource = cachedSource;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (this.cache) {\n\t\t\t\t\t\t\tthis.cache[cacheName] = {\n\t\t\t\t\t\t\t\thash: usedHash,\n\t\t\t\t\t\t\t\tsource\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.emitAsset(file, source, assetInfo);\n\t\t\t\t\tchunk.files.push(file);\n\t\t\t\t\tthis.hooks.chunkAsset.call(chunk, file);\n\t\t\t\t\talreadyWrittenFiles.set(file, {\n\t\t\t\t\t\thash: usedHash,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tchunk\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tthis.errors.push(\n\t\t\t\t\tnew ChunkRenderError(chunk, file || filenameTemplate, err)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} filename used to get asset path with hash\n\t * @param {TODO=} data // TODO: figure out this param type\n\t * @returns {string} interpolated path\n\t */\n\tgetPath(filename, data) {\n\t\tdata = data || {};\n\t\tdata.hash = data.hash || this.hash;\n\t\treturn this.mainTemplate.getAssetPath(filename, data);\n\t}\n\n\t/**\n\t * @param {string} filename used to get asset path with hash\n\t * @param {TODO=} data // TODO: figure out this param type\n\t * @returns {{ path: string, info: AssetInfo }} interpolated path and asset info\n\t */\n\tgetPathWithInfo(filename, data) {\n\t\tdata = data || {};\n\t\tdata.hash = data.hash || this.hash;\n\t\treturn this.mainTemplate.getAssetPathWithInfo(filename, data);\n\t}\n\n\t/**\n\t * This function allows you to run another instance of webpack inside of webpack however as\n\t * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins\n\t * from parent (or top level compiler) and creates a child Compilation\n\t *\n\t * @param {string} name name of the child compiler\n\t * @param {TODO} outputOptions // Need to convert config schema to types for this\n\t * @param {Plugin[]} plugins webpack plugins that will be applied\n\t * @returns {Compiler} creates a child Compiler instance\n\t */\n\tcreateChildCompiler(name, outputOptions, plugins) {\n\t\tconst idx = this.childrenCounters[name] || 0;\n\t\tthis.childrenCounters[name] = idx + 1;\n\t\treturn this.compiler.createChildCompiler(\n\t\t\tthis,\n\t\t\tname,\n\t\t\tidx,\n\t\t\toutputOptions,\n\t\t\tplugins\n\t\t);\n\t}\n\n\tcheckConstraints() {\n\t\t/** @type {Set<number|string>} */\n\t\tconst usedIds = new Set();\n\n\t\tconst modules = this.modules;\n\t\tfor (let indexModule = 0; indexModule < modules.length; indexModule++) {\n\t\t\tconst moduleId = modules[indexModule].id;\n\t\t\tif (moduleId === null) continue;\n\t\t\tif (usedIds.has(moduleId)) {\n\t\t\t\tthrow new Error(`checkConstraints: duplicate module id ${moduleId}`);\n\t\t\t}\n\t\t\tusedIds.add(moduleId);\n\t\t}\n\n\t\tconst chunks = this.chunks;\n\t\tfor (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n\t\t\tconst chunk = chunks[indexChunk];\n\t\t\tif (chunks.indexOf(chunk) !== indexChunk) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`checkConstraints: duplicate chunk in compilation ${chunk.debugId}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of this.chunkGroups) {\n\t\t\tchunkGroup.checkConstraints();\n\t\t}\n\t}\n}\n\n// TODO remove in webpack 5\nCompilation.prototype.applyPlugins = util.deprecate(\n\t/**\n\t * @deprecated\n\t * @param {string} name Name\n\t * @param {any[]} args Other arguments\n\t * @returns {void}\n\t * @this {Compilation}\n\t */\n\tfunction(name, ...args) {\n\t\tthis.hooks[\n\t\t\tname.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())\n\t\t].call(...args);\n\t},\n\t\"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead\"\n);\n\n// TODO remove in webpack 5\nObject.defineProperty(Compilation.prototype, \"moduleTemplate\", {\n\tconfigurable: false,\n\tget: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Compilation}\n\t\t * @returns {TODO} module template\n\t\t */\n\t\tfunction() {\n\t\t\treturn this.moduleTemplates.javascript;\n\t\t},\n\t\t\"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead\"\n\t),\n\tset: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @param {ModuleTemplate} value Template value\n\t\t * @this {Compilation}\n\t\t * @returns {void}\n\t\t */\n\t\tfunction(value) {\n\t\t\tthis.moduleTemplates.javascript = value;\n\t\t},\n\t\t\"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.\"\n\t)\n});\n\nmodule.exports = Compilation;\n"]},"metadata":{},"sourceType":"script"}