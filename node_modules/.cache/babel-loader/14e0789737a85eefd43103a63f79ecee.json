{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nimport Long from \"@xtuc/long\";\nimport * as bits from \"./bits\";\nimport * as bufs from \"./bufs\";\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\n\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, false);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, true);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nexport default {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/leb128/esm/leb.js"],"names":["Long","bits","bufs","MIN_INT32","MAX_INT32","MAX_UINT32","signedBitCount","buffer","highOrder","getSign","unsignedBitCount","result","encodeBufferCommon","signed","signBit","bitCount","byteCount","Math","ceil","alloc","i","payload","extract","encodedLength","encodedBuffer","index","length","decodeBufferCommon","undefined","bitLength","byteLength","outIndex","inject","signByte","lastByte","endBit","shift","resize","value","nextIndex","encodeIntBuffer","decodeIntBuffer","encodeInt32","num","buf","writeInt32LE","free","decodeInt32","parsed","readInt","Error","encodeInt64","writeInt64","decodeInt64","fromBytesLE","lossy","encodeUIntBuffer","decodeUIntBuffer","encodeUInt32","writeUInt32LE","decodeUInt32","readUInt","encodeUInt64","writeUInt64","decodeUInt64"],"mappings":"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","sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * leb: LEB128 utilities.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n\nimport Long from \"@xtuc/long\";\nimport * as bits from \"./bits\";\nimport * as bufs from \"./bufs\";\n/*\n * Module variables\n */\n\n/** The minimum possible 32-bit signed int. */\n\nvar MIN_INT32 = -0x80000000;\n/** The maximum possible 32-bit signed int. */\n\nvar MAX_INT32 = 0x7fffffff;\n/** The maximum possible 32-bit unsigned int. */\n\nvar MAX_UINT32 = 0xffffffff;\n/** The minimum possible 64-bit signed int. */\n// const MIN_INT64 = -0x8000000000000000;\n\n/**\n * The maximum possible 64-bit signed int that is representable as a\n * JavaScript number.\n */\n// const MAX_INT64 = 0x7ffffffffffffc00;\n\n/**\n * The maximum possible 64-bit unsigned int that is representable as a\n * JavaScript number.\n */\n// const MAX_UINT64 = 0xfffffffffffff800;\n\n/*\n * Helper functions\n */\n\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as a signed value. The buffer is\n * taken to represent a signed number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order non-sign-matching bit, plus two. For example:\n *\n *   11111011 01110101\n *   high          low\n *\n * The sign bit here is 1 (that is, it's a negative number). The highest\n * bit number that doesn't match the sign is bit #10 (where the lowest-order\n * bit is bit #0). So, we have to encode at least 12 bits total.\n *\n * As a special degenerate case, the numbers 0 and -1 each require just one bit.\n */\n\nfunction signedBitCount(buffer) {\n  return bits.highOrder(bits.getSign(buffer) ^ 1, buffer) + 2;\n}\n/**\n * Determines the number of bits required to encode the number\n * represented in the given buffer as an unsigned value. The buffer is\n * taken to represent an unsigned number in little-endian form.\n *\n * The number of bits to encode is the (zero-based) bit number of the\n * highest-order 1 bit, plus one. For example:\n *\n *   00011000 01010011\n *   high          low\n *\n * The highest-order 1 bit here is bit #12 (where the lowest-order bit\n * is bit #0). So, we have to encode at least 13 bits total.\n *\n * As a special degenerate case, the number 0 requires 1 bit.\n */\n\n\nfunction unsignedBitCount(buffer) {\n  var result = bits.highOrder(1, buffer) + 1;\n  return result ? result : 1;\n}\n/**\n * Common encoder for both signed and unsigned ints. This takes a\n * bigint-ish buffer, returning an LEB128-encoded buffer.\n */\n\n\nfunction encodeBufferCommon(buffer, signed) {\n  var signBit;\n  var bitCount;\n\n  if (signed) {\n    signBit = bits.getSign(buffer);\n    bitCount = signedBitCount(buffer);\n  } else {\n    signBit = 0;\n    bitCount = unsignedBitCount(buffer);\n  }\n\n  var byteCount = Math.ceil(bitCount / 7);\n  var result = bufs.alloc(byteCount);\n\n  for (var i = 0; i < byteCount; i++) {\n    var payload = bits.extract(buffer, i * 7, 7, signBit);\n    result[i] = payload | 0x80;\n  } // Mask off the top bit of the last byte, to indicate the end of the\n  // encoding.\n\n\n  result[byteCount - 1] &= 0x7f;\n  return result;\n}\n/**\n * Gets the byte-length of the value encoded in the given buffer at\n * the given index.\n */\n\n\nfunction encodedLength(encodedBuffer, index) {\n  var result = 0;\n\n  while (encodedBuffer[index + result] >= 0x80) {\n    result++;\n  }\n\n  result++; // to account for the last byte\n\n  if (index + result > encodedBuffer.length) {// FIXME(sven): seems to cause false positives\n    // throw new Error(\"integer representation too long\");\n  }\n\n  return result;\n}\n/**\n * Common decoder for both signed and unsigned ints. This takes an\n * LEB128-encoded buffer, returning a bigint-ish buffer.\n */\n\n\nfunction decodeBufferCommon(encodedBuffer, index, signed) {\n  index = index === undefined ? 0 : index;\n  var length = encodedLength(encodedBuffer, index);\n  var bitLength = length * 7;\n  var byteLength = Math.ceil(bitLength / 8);\n  var result = bufs.alloc(byteLength);\n  var outIndex = 0;\n\n  while (length > 0) {\n    bits.inject(result, outIndex, 7, encodedBuffer[index]);\n    outIndex += 7;\n    index++;\n    length--;\n  }\n\n  var signBit;\n  var signByte;\n\n  if (signed) {\n    // Sign-extend the last byte.\n    var lastByte = result[byteLength - 1];\n    var endBit = outIndex % 8;\n\n    if (endBit !== 0) {\n      var shift = 32 - endBit; // 32 because JS bit ops work on 32-bit ints.\n\n      lastByte = result[byteLength - 1] = lastByte << shift >> shift & 0xff;\n    }\n\n    signBit = lastByte >> 7;\n    signByte = signBit * 0xff;\n  } else {\n    signBit = 0;\n    signByte = 0;\n  } // Slice off any superfluous bytes, that is, ones that add no meaningful\n  // bits (because the value would be the same if they were removed).\n\n\n  while (byteLength > 1 && result[byteLength - 1] === signByte && (!signed || result[byteLength - 2] >> 7 === signBit)) {\n    byteLength--;\n  }\n\n  result = bufs.resize(result, byteLength);\n  return {\n    value: result,\n    nextIndex: index\n  };\n}\n/*\n * Exported bindings\n */\n\n\nfunction encodeIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, true);\n}\n\nfunction decodeIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, true);\n}\n\nfunction encodeInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeInt32LE(num, 0);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt32(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value < MIN_INT32 || value > MAX_INT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeInt64(num, buf);\n  var result = encodeIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeInt64(encodedBuffer, index) {\n  var result = decodeIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, false);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nfunction encodeUIntBuffer(buffer) {\n  return encodeBufferCommon(buffer, false);\n}\n\nfunction decodeUIntBuffer(encodedBuffer, index) {\n  return decodeBufferCommon(encodedBuffer, index, false);\n}\n\nfunction encodeUInt32(num) {\n  var buf = bufs.alloc(4);\n  buf.writeUInt32LE(num, 0);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt32(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var parsed = bufs.readUInt(result.value);\n  var value = parsed.value;\n  bufs.free(result.value);\n\n  if (value > MAX_UINT32) {\n    throw new Error(\"integer too large\");\n  }\n\n  return {\n    value: value,\n    nextIndex: result.nextIndex\n  };\n}\n\nfunction encodeUInt64(num) {\n  var buf = bufs.alloc(8);\n  bufs.writeUInt64(num, buf);\n  var result = encodeUIntBuffer(buf);\n  bufs.free(buf);\n  return result;\n}\n\nfunction decodeUInt64(encodedBuffer, index) {\n  var result = decodeUIntBuffer(encodedBuffer, index);\n  var value = Long.fromBytesLE(result.value, true);\n  bufs.free(result.value);\n  return {\n    value: value,\n    nextIndex: result.nextIndex,\n    lossy: false\n  };\n}\n\nexport default {\n  decodeInt32: decodeInt32,\n  decodeInt64: decodeInt64,\n  decodeIntBuffer: decodeIntBuffer,\n  decodeUInt32: decodeUInt32,\n  decodeUInt64: decodeUInt64,\n  decodeUIntBuffer: decodeUIntBuffer,\n  encodeInt32: encodeInt32,\n  encodeInt64: encodeInt64,\n  encodeIntBuffer: encodeIntBuffer,\n  encodeUInt32: encodeUInt32,\n  encodeUInt64: encodeUInt64,\n  encodeUIntBuffer: encodeUIntBuffer\n};"]},"metadata":{},"sourceType":"module"}