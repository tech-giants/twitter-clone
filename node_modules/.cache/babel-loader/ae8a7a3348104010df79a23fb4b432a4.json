{"ast":null,"code":"function _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { decodeInt32, decodeUInt32, MAX_NUMBER_OF_BYTE_U32, decodeInt64, decodeUInt64, MAX_NUMBER_OF_BYTE_U64 } from \"@webassemblyjs/leb128\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\n\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\n\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n\n  function isEOF() {\n    return offset >= buf.length;\n  }\n\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n\n    return arr;\n  }\n\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n\n  function readU32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n\n  function read32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return decodeInt32(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n\n  function read64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return decodeInt64(buffer);\n  }\n\n  function readU64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt64(buffer);\n  }\n\n  function readByte() {\n    return readBytes(1)[0];\n  }\n\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var header = readBytes(4);\n\n    if (byteArrayEq(constants.magicModuleHeader, header) === false) {\n      throw new CompileError(\"magic header not detected\");\n    }\n\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var version = readBytes(4);\n\n    if (byteArrayEq(constants.moduleVersion, version) === false) {\n      throw new CompileError(\"unknown binary version\");\n    }\n\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n\n    if (length === 0) {\n      return [];\n    }\n\n    var elements = [];\n\n    for (var i = 0; i < length; i++) {\n      var byte = readByte();\n      eatBytes(1);\n      var value = cast(byte);\n      dump([byte], value);\n\n      if (typeof value === \"undefined\") {\n        throw new CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n\n      elements.push(value);\n    }\n\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n\n    for (var i = 0; i < numberOfTypes; i++) {\n      var _startLoc = getPosition();\n\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n\n      if (type == constants.types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam(\n          /*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        typeInstructionNodes.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);\n        }());\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n\n      var _startLoc2 = getPosition();\n      /**\n       * Module name\n       */\n\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = constants.importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n\n      if (typeof descrType === \"undefined\") {\n        throw new CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n\n      var importDescr = void 0;\n\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"mem\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new CompileError(\"Unsupported import of type: \" + descrType);\n      }\n\n      imports.push(function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);\n      }());\n    }\n\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n\n      if (typeof signature === \"undefined\") {\n        throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var _startLoc3 = getPosition();\n      /**\n       * Name\n       */\n\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n          signature = void 0;\n\n      if (constants.exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n\n        if (typeof func === \"undefined\") {\n          throw new CompileError(\"unknown function (\".concat(index, \")\"));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (constants.exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n\n        if (typeof table === \"undefined\") {\n          throw new CompileError(\"unknown table \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Mem\") {\n        var memNode = state.memoriesInModule[index];\n\n        if (typeof memNode === \"undefined\") {\n          throw new CompileError(\"unknown memory \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n\n        if (typeof global === \"undefined\") {\n          throw new CompileError(\"unknown global \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: constants.exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: _startLoc3\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var _startLoc4 = getPosition();\n\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = [];\n      /**\n       * Parse locals\n       */\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var _startLoc5 = getPosition();\n\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = constants.valtypes[valtypeByte];\n        var args = [];\n\n        for (var _i2 = 0; _i2 < localCount; _i2++) {\n          args.push(t.valtypeLiteral(type));\n        }\n\n        var localNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(\"local\", args), endLoc, _startLoc5);\n        }();\n\n        locals.push(localNode);\n        dump([valtypeByte], type);\n\n        if (typeof type === \"undefined\") {\n          throw new CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      }\n\n      code.push.apply(code, locals); // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: _startLoc4,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n\n  function parseInstructionBlock(code) {\n    while (true) {\n      var _startLoc6 = getPosition();\n\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n\n      if (instructionByte === 0xfe) {\n        throw new CompileError(\"Atomic instructions are not implemented\");\n      }\n\n      var instruction = constants.symbolsByByte[instructionByte];\n\n      if (typeof instruction === \"undefined\") {\n        throw new CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n\n      if (instruction.name === \"end\") {\n        var node = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);\n        }();\n\n        code.push(node);\n        break;\n      }\n\n      var args = [];\n\n      if (instruction.name === \"loop\") {\n        var _startLoc7 = getPosition();\n\n        var blocktypeByte = readByte();\n        eatBytes(1);\n        var blocktype = constants.blockTypes[blocktypeByte];\n        dump([blocktypeByte], \"blocktype\");\n\n        if (typeof blocktype === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(blocktypeByte));\n        }\n\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n\n        var loopNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);\n        }();\n\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _startLoc8 = getPosition();\n\n        var _blocktypeByte = readByte();\n\n        eatBytes(1);\n        var _blocktype = constants.blockTypes[_blocktypeByte];\n        dump([_blocktypeByte], \"blocktype\");\n\n        if (typeof _blocktype === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte));\n        }\n\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n\n        var ifNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);\n        }();\n\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _startLoc9 = getPosition();\n\n        var _blocktypeByte2 = readByte();\n\n        eatBytes(1);\n        var _blocktype2 = constants.blockTypes[_blocktypeByte2];\n        dump([_blocktypeByte2], \"blocktype\");\n\n        if (typeof _blocktype2 === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte2));\n        }\n\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n\n        var blockNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);\n        }();\n\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n\n        var callNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);\n        }();\n\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var _startLoc10 = getPosition();\n\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n\n        if (flag !== 0) {\n          throw new CompileError(\"zero flag expected\");\n        }\n\n        code.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(_callNode, endLoc, _startLoc10);\n        }());\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n              low = _value2.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(_node);\n        }\n\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n              _low = _value3.low;\n          var _node2 = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node2);\n        }\n\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else {\n        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i3);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          var _node3 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args), endLoc, _startLoc6);\n          }();\n\n          code.push(_node3);\n        } else {\n          var _node4 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.instruction(instruction.name, args), endLoc, _startLoc6);\n          }();\n\n          code.push(_node4);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    dump([limitType], \"limit type\");\n    var min, max;\n\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n      var u32min = readU32();\n      min = parseInt(u32min.value);\n      eatBytes(u32min.nextIndex);\n      dump([min], \"min\");\n      var u32max = readU32();\n      max = parseInt(u32max.value);\n      eatBytes(u32max.nextIndex);\n      dump([max], \"max\");\n    }\n\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n\n    return t.limit(min, max);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = constants.tableTypes[elementTypeByte];\n\n    if (typeof elementType === \"undefined\") {\n      throw new CompileError(\"Unknown element type in table: \" + toHex(elementType));\n    }\n\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = constants.valtypes[valtypeByte];\n    dump([valtypeByte], type);\n\n    if (typeof type === \"undefined\") {\n      throw new CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = constants.globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n\n    if (typeof globalType === \"undefined\") {\n      throw new CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n\n    return functionNames;\n  }\n\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n\n      for (var _i4 = 0; _i4 < numLocals; _i4++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n\n    return nameMetadata;\n  } // this is a custom section used for information about the producers\n  // https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md\n\n\n  function parseProducersSection() {\n    var metadata = t.producersSectionMetadata([]); // field_count\n\n    var sectionTypeByte = readVaruint32();\n    eatBytes(sectionTypeByte.nextIndex);\n    dump([sectionTypeByte.value], \"num of producers\");\n    var fields = {\n      language: [],\n      \"processed-by\": [],\n      sdk: []\n    }; // fields\n\n    for (var fieldI = 0; fieldI < sectionTypeByte.value; fieldI++) {\n      // field_name\n      var fieldName = readUTF8String();\n      eatBytes(fieldName.nextIndex); // field_value_count\n\n      var valueCount = readVaruint32();\n      eatBytes(valueCount.nextIndex); // field_values\n\n      for (var producerI = 0; producerI < valueCount.value; producerI++) {\n        var producerName = readUTF8String();\n        eatBytes(producerName.nextIndex);\n        var producerVersion = readUTF8String();\n        eatBytes(producerVersion.nextIndex);\n        fields[fieldName.value].push(t.producerMetadataVersionedName(producerName.value, producerVersion.value));\n      }\n\n      metadata.producers.push(fields[fieldName.value]);\n    }\n\n    return metadata;\n  }\n\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var _startLoc11 = getPosition();\n\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n\n      var node = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.global(globalType, init), endLoc, _startLoc11);\n      }();\n\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n\n    return globals;\n  }\n\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var _startLoc12 = getPosition();\n\n      var tableindexu32 = readU32();\n      var tableindex = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([tableindex], \"table index\");\n      /**\n       * Parse instructions\n       */\n\n      var instr = [];\n      parseInstructionBlock(instr);\n      /**\n       * Parse ( vector function index ) *\n       */\n\n      var indicesu32 = readU32();\n      var indices = indicesu32.value;\n      eatBytes(indicesu32.nextIndex);\n      dump([indices], \"num indices\");\n      var indexValues = [];\n\n      for (var _i5 = 0; _i5 < indices; _i5++) {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n        indexValues.push(t.indexLiteral(index));\n      }\n\n      var elemNode = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.elem(t.indexLiteral(tableindex), instr, indexValues), endLoc, _startLoc12);\n      }();\n\n      elems.push(elemNode);\n    }\n\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    return function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n    }();\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      var hasExtraInstrs = instrs.filter(function (i) {\n        return i.id !== \"end\";\n      }).length !== 1;\n\n      if (hasExtraInstrs) {\n        throw new CompileError(\"data section offset must be a single instruction\");\n      }\n\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n\n    if (sectionId >= sectionIndex || sectionIndex === constants.sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== constants.sections.custom) throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n\n    var sectionSizeInBytesNode = function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), endLoc, startLoc);\n    }();\n\n    switch (sectionId) {\n      case constants.sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc13 = getPosition();\n\n          var _u = readU32();\n\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n\n          var _metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endLoc, _startLoc13);\n          }());\n\n          var _nodes = parseTypeSection(numberOfTypes);\n\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc14 = getPosition();\n\n          var _u2 = readU32();\n\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          dump([numberOfTable], \"num tables\");\n\n          var _metadata2 = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTable), endLoc, _startLoc14);\n          }());\n\n          var _nodes2 = parseTableSection(numberOfTable);\n\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.import:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc15 = getPosition();\n\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          dump([numberOfImports], \"number of imports\");\n\n          var _metadata3 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfImports), endLoc, _startLoc15);\n          }());\n\n          var _nodes3 = parseImportSection(numberOfImports);\n\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc16 = getPosition();\n\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n\n          var _metadata4 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), endLoc, _startLoc16);\n          }());\n\n          parseFuncSection(numberOfFunctions);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.export:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc17 = getPosition();\n\n          var _u3 = readU32();\n\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n\n          var _metadata5 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfExport), endLoc, _startLoc17);\n          }());\n\n          parseExportSection(numberOfExport);\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc18 = getPosition();\n\n          var _u4 = readU32();\n\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n\n          var _metadata6 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), endLoc, _startLoc18);\n          }());\n\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n\n          var _nodes6 = [];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata7 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n\n          var _nodes7 = [parseStartSection()];\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc19 = getPosition();\n\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n\n          var _metadata8 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfElements), endLoc, _startLoc19);\n          }());\n\n          var _nodes8 = parseElemSection(numberOfElements);\n\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc20 = getPosition();\n\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n\n          var _metadata9 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), endLoc, _startLoc20);\n          }());\n\n          var _nodes9 = parseGlobalSection(numberOfGlobals);\n\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc21 = getPosition();\n\n          var _numberOfElementsu = readU32();\n\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n\n          var _metadata10 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements), endLoc, _startLoc21);\n          }());\n\n          var _nodes10 = parseMemorySection(_numberOfElements);\n\n          return {\n            nodes: _nodes10,\n            metadata: _metadata10,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata11 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n\n          var _startLoc22 = getPosition();\n\n          var _numberOfElementsu2 = readU32();\n\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n\n          _metadata11.vectorOfSize = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), endLoc, _startLoc22);\n          }();\n\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata11,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes11 = parseDataSection(_numberOfElements2);\n\n            return {\n              nodes: _nodes11,\n              metadata: _metadata11,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n\n      case constants.sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata12 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n\n          if (sectionName.value === \"name\") {\n            var initialOffset = offset;\n\n            try {\n              _metadata12.push.apply(_metadata12, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (initialOffset + _remainingBytes2));\n            }\n          } else if (sectionName.value === \"producers\") {\n            var _initialOffset = offset;\n\n            try {\n              _metadata12.push(parseProducersSection());\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"producers\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (_initialOffset + _remainingBytes2));\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n\n          return {\n            nodes: [],\n            metadata: _metadata12,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n\n    throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n  }\n\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: [],\n    producers: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n        _nodes12 = _parseSection.nodes,\n        _metadata13 = _parseSection.metadata,\n        nextSectionIndex = _parseSection.nextSectionIndex;\n\n    moduleFields.push.apply(moduleFields, _toConsumableArray(_nodes12));\n    var metadataArray = Array.isArray(_metadata13) ? _metadata13 : [_metadata13];\n    metadataArray.forEach(function (metadataItem) {\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem);\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem);\n      } else if (metadataItem.type === \"ProducersSectionMetadata\") {\n        moduleMetadata.producers.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n\n      body = decodedElementInCodeSection.code;\n    }\n\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n\n    if (opts.ignoreCodeSection === false) {\n      var _startLoc23 = decodedElementInCodeSection.startLoc,\n          endLoc = decodedElementInCodeSection.endLoc,\n          bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, _startLoc23);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames, moduleMetadata.producers));\n  return t.program([module]);\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/wasm-parser/esm/decoder.js"],"names":["_toConsumableArray","arr","Array","isArray","i","arr2","length","from","CompileError","ieee754","utf8","t","decodeInt32","decodeUInt32","MAX_NUMBER_OF_BYTE_U32","decodeInt64","decodeUInt64","MAX_NUMBER_OF_BYTE_U64","constants","toHex","n","Number","toString","byteArrayEq","l","r","decode","ab","opts","buf","Uint8Array","getUniqueName","getUniqueNameGenerator","offset","getPosition","line","column","dump","b","msg","pad","str","map","join","console","log","dumpSep","state","elementsInFuncSection","elementsInExportSection","elementsInCodeSection","memoriesInModule","typesInModule","functionsInModule","tablesInModule","globalsInModule","isEOF","eatBytes","readBytesAtOffset","_offset","numberOfBytes","push","readBytes","readF64","bytes","NUMBER_OF_BYTE_F64","value","decodeF64","Math","sign","Infinity","inf","nextIndex","isNaN","mantissa","pow","nan","readF32","NUMBER_OF_BYTE_F32","decodeF32","readUTF8String","lenu32","readU32","strlen","buffer","Buffer","readVaruint32","readVaruint7","read32","read64","readU64","readByte","parseModuleHeader","Error","header","magicModuleHeader","parseVersion","version","moduleVersion","parseVec","cast","u32","elements","byte","parseTypeSection","numberOfTypes","typeInstructionNodes","_startLoc","type","types","func","paramValtypes","valtypes","params","v","funcParam","result","endLoc","withLoc","typeInstruction","undefined","signature","parseImportSection","numberOfImports","imports","_startLoc2","moduleName","concat","name","descrTypeByte","descrType","importTypes","importDescr","indexU32","typeindex","id","funcImportDescr","identifier","isExternal","parseGlobalType","globalNode","global","parseTableType","memoryNode","parseMemoryType","moduleImport","parseFuncSection","numberOfFunctions","withRaw","parseExportSection","numberOfExport","_startLoc3","typeIndex","indexu32","index","exportTypes","numberLiteralFromRaw","String","table","memNode","warn","startLoc","parseCodeSection","numberOfFuncs","_startLoc4","bodySizeU32","code","funcLocalNumU32","funcLocalNum","locals","_i","_startLoc5","localCountU32","localCount","valtypeByte","args","_i2","valtypeLiteral","localNode","instruction","apply","parseInstructionBlock","bodySize","_startLoc6","instructionAlreadyCreated","instructionByte","symbolsByByte","object","node","_startLoc7","blocktypeByte","blocktype","blockTypes","instr","label","loopNode","loopInstruction","_startLoc8","_blocktypeByte","_blocktype","testIndex","ifBody","elseIndex","_instr","consequentInstr","slice","alternate","testInstrs","ifNode","ifInstruction","_startLoc9","_blocktypeByte2","_blocktype2","_instr2","_label","blockNode","blockInstruction","callNode","callInstruction","indexLiteral","_startLoc10","_callNode","callIndirectInstruction","flagU32","flag","indicesu32","indices","_indexu","_index","_indexU","_index2","aligun32","align","offsetu32","_offset2","value32","valueu32","_value","value64","_value2","high","low","_node","valueu64","_value3","_high","_low","_node2","valuef32","_value4","floatLiteral","valuef64","_value5","_i3","numberOfArgs","_node3","objectInstruction","_node4","parseLimits","limitType","min","max","u32min","parseInt","u32max","_u32min","limit","elementTypeByte","elementType","tableTypes","limits","globalTypeByte","globalType","globalTypes","parseNameSectionFunctions","functionNames","numberOfFunctionsu32","numbeOfFunctions","functionNameMetadata","parseNameSectionLocals","localNames","numbeOfFunctionsu32","functionIndexu32","functionIndex","numLocalsu32","numLocals","_i4","localIndexu32","localIndex","localNameMetadata","parseNameSection","remainingBytes","nameMetadata","initialOffset","sectionTypeByte","subSectionSizeInBytesu32","parseProducersSection","metadata","producersSectionMetadata","fields","language","sdk","fieldI","fieldName","valueCount","producerI","producerName","producerVersion","producerMetadataVersionedName","producers","parseGlobalSection","numberOfGlobals","globals","_startLoc11","init","parseElemSection","numberOfElements","elems","_startLoc12","tableindexu32","tableindex","indexValues","_i5","elemNode","elem","memory","parseTableSection","tables","tablesNode","parseMemorySection","memories","parseStartSection","startFuncIndex","start","parseDataSection","dataEntries","memoryIndexu32","memoryIndex","instrs","hasExtraInstrs","filter","data","memIndexLiteral","byteArray","parseSection","sectionIndex","sectionId","sections","custom","nextSectionIndex","startOffset","sectionSizeInBytes","sectionSizeInBytesNode","_startLoc13","_u","_metadata","sectionMetadata","_nodes","nodes","_startLoc14","_u2","numberOfTable","_metadata2","_nodes2","import","_startLoc15","numberOfImportsu32","_metadata3","_nodes3","_startLoc16","_metadata4","_nodes4","export","_startLoc17","_u3","_metadata5","_nodes5","_startLoc18","_u4","_metadata6","ignoreCodeSection","_nodes6","_metadata7","_nodes7","element","_startLoc19","numberOfElementsu32","_metadata8","_nodes8","_startLoc20","numberOfGlobalsu32","_metadata9","_nodes9","_startLoc21","_numberOfElementsu","_numberOfElements","_metadata10","_nodes10","_metadata11","_startLoc22","_numberOfElementsu2","_numberOfElements2","vectorOfSize","ignoreDataSection","_remainingBytes","_nodes11","_metadata12","sectionName","_remainingBytes2","e","message","_initialOffset","JSON","stringify","moduleFields","moduleMetadata","_parseSection","_nodes12","_metadata13","metadataArray","forEach","metadataItem","funcIndex","body","decodedElementInCodeSection","funcNode","_startLoc23","moduleExport","moduleExportDescr","module","program"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport { CompileError } from \"@webassemblyjs/helper-api-error\";\nimport * as ieee754 from \"@webassemblyjs/ieee754\";\nimport * as utf8 from \"@webassemblyjs/utf8\";\nimport * as t from \"@webassemblyjs/ast\";\nimport { decodeInt32, decodeUInt32, MAX_NUMBER_OF_BYTE_U32, decodeInt64, decodeUInt64, MAX_NUMBER_OF_BYTE_U64 } from \"@webassemblyjs/leb128\";\nimport constants from \"@webassemblyjs/helper-wasm-bytecode\";\n\nfunction toHex(n) {\n  return \"0x\" + Number(n).toString(16);\n}\n\nfunction byteArrayEq(l, r) {\n  if (l.length !== r.length) {\n    return false;\n  }\n\n  for (var i = 0; i < l.length; i++) {\n    if (l[i] !== r[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function decode(ab, opts) {\n  var buf = new Uint8Array(ab);\n  var getUniqueName = t.getUniqueNameGenerator();\n  var offset = 0;\n\n  function getPosition() {\n    return {\n      line: -1,\n      column: offset\n    };\n  }\n\n  function dump(b, msg) {\n    if (opts.dump === false) return;\n    var pad = \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n    var str = \"\";\n\n    if (b.length < 5) {\n      str = b.map(toHex).join(\" \");\n    } else {\n      str = \"...\";\n    }\n\n    console.log(toHex(offset) + \":\\t\", str, pad, \";\", msg);\n  }\n\n  function dumpSep(msg) {\n    if (opts.dump === false) return;\n    console.log(\";\", msg);\n  }\n  /**\n   * TODO(sven): we can atually use a same structure\n   * we are adding incrementally new features\n   */\n\n\n  var state = {\n    elementsInFuncSection: [],\n    elementsInExportSection: [],\n    elementsInCodeSection: [],\n\n    /**\n     * Decode memory from:\n     * - Memory section\n     */\n    memoriesInModule: [],\n\n    /**\n     * Decoded types from:\n     * - Type section\n     */\n    typesInModule: [],\n\n    /**\n     * Decoded functions from:\n     * - Function section\n     * - Import section\n     */\n    functionsInModule: [],\n\n    /**\n     * Decoded tables from:\n     * - Table section\n     */\n    tablesInModule: [],\n\n    /**\n     * Decoded globals from:\n     * - Global section\n     */\n    globalsInModule: []\n  };\n\n  function isEOF() {\n    return offset >= buf.length;\n  }\n\n  function eatBytes(n) {\n    offset = offset + n;\n  }\n\n  function readBytesAtOffset(_offset, numberOfBytes) {\n    var arr = [];\n\n    for (var i = 0; i < numberOfBytes; i++) {\n      arr.push(buf[_offset + i]);\n    }\n\n    return arr;\n  }\n\n  function readBytes(numberOfBytes) {\n    return readBytesAtOffset(offset, numberOfBytes);\n  }\n\n  function readF64() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F64);\n    var value = ieee754.decodeF64(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 16 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F64\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F64\n    };\n  }\n\n  function readF32() {\n    var bytes = readBytes(ieee754.NUMBER_OF_BYTE_F32);\n    var value = ieee754.decodeF32(bytes);\n\n    if (Math.sign(value) * value === Infinity) {\n      return {\n        value: Math.sign(value),\n        inf: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    if (isNaN(value)) {\n      var sign = bytes[bytes.length - 1] >> 7 ? -1 : 1;\n      var mantissa = 0;\n\n      for (var i = 0; i < bytes.length - 2; ++i) {\n        mantissa += bytes[i] * Math.pow(256, i);\n      }\n\n      mantissa += bytes[bytes.length - 2] % 128 * Math.pow(256, bytes.length - 2);\n      return {\n        value: sign * mantissa,\n        nan: true,\n        nextIndex: ieee754.NUMBER_OF_BYTE_F32\n      };\n    }\n\n    return {\n      value: value,\n      nextIndex: ieee754.NUMBER_OF_BYTE_F32\n    };\n  }\n\n  function readUTF8String() {\n    var lenu32 = readU32(); // Don't eat any bytes. Instead, peek ahead of the current offset using\n    // readBytesAtOffset below. This keeps readUTF8String neutral with respect\n    // to the current offset, just like the other readX functions.\n\n    var strlen = lenu32.value;\n    dump([strlen], \"string length\");\n    var bytes = readBytesAtOffset(offset + lenu32.nextIndex, strlen);\n    var value = utf8.decode(bytes);\n    return {\n      value: value,\n      nextIndex: strlen + lenu32.nextIndex\n    };\n  }\n  /**\n   * Decode an unsigned 32bits integer\n   *\n   * The length will be handled by the leb librairy, we pass the max number of\n   * byte.\n   */\n\n\n  function readU32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n\n  function readVaruint32() {\n    // where 32 bits = max 4 bytes\n    var bytes = readBytes(4);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n\n  function readVaruint7() {\n    // where 7 bits = max 1 bytes\n    var bytes = readBytes(1);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt32(buffer);\n  }\n  /**\n   * Decode a signed 32bits interger\n   */\n\n\n  function read32() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U32);\n    var buffer = Buffer.from(bytes);\n    return decodeInt32(buffer);\n  }\n  /**\n   * Decode a signed 64bits integer\n   */\n\n\n  function read64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return decodeInt64(buffer);\n  }\n\n  function readU64() {\n    var bytes = readBytes(MAX_NUMBER_OF_BYTE_U64);\n    var buffer = Buffer.from(bytes);\n    return decodeUInt64(buffer);\n  }\n\n  function readByte() {\n    return readBytes(1)[0];\n  }\n\n  function parseModuleHeader() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var header = readBytes(4);\n\n    if (byteArrayEq(constants.magicModuleHeader, header) === false) {\n      throw new CompileError(\"magic header not detected\");\n    }\n\n    dump(header, \"wasm magic header\");\n    eatBytes(4);\n  }\n\n  function parseVersion() {\n    if (isEOF() === true || offset + 4 > buf.length) {\n      throw new Error(\"unexpected end\");\n    }\n\n    var version = readBytes(4);\n\n    if (byteArrayEq(constants.moduleVersion, version) === false) {\n      throw new CompileError(\"unknown binary version\");\n    }\n\n    dump(version, \"wasm version\");\n    eatBytes(4);\n  }\n\n  function parseVec(cast) {\n    var u32 = readU32();\n    var length = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([length], \"number\");\n\n    if (length === 0) {\n      return [];\n    }\n\n    var elements = [];\n\n    for (var i = 0; i < length; i++) {\n      var byte = readByte();\n      eatBytes(1);\n      var value = cast(byte);\n      dump([byte], value);\n\n      if (typeof value === \"undefined\") {\n        throw new CompileError(\"Internal failure: parseVec could not cast the value\");\n      }\n\n      elements.push(value);\n    }\n\n    return elements;\n  } // Type section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-typesec\n\n\n  function parseTypeSection(numberOfTypes) {\n    var typeInstructionNodes = [];\n    dump([numberOfTypes], \"num types\");\n\n    for (var i = 0; i < numberOfTypes; i++) {\n      var _startLoc = getPosition();\n\n      dumpSep(\"type \" + i);\n      var type = readByte();\n      eatBytes(1);\n\n      if (type == constants.types.func) {\n        dump([type], \"func\");\n        var paramValtypes = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        var params = paramValtypes.map(function (v) {\n          return t.funcParam(\n          /*valtype*/\n          v);\n        });\n        var result = parseVec(function (b) {\n          return constants.valtypes[b];\n        });\n        typeInstructionNodes.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.typeInstruction(undefined, t.signature(params, result)), endLoc, _startLoc);\n        }());\n        state.typesInModule.push({\n          params: params,\n          result: result\n        });\n      } else {\n        throw new Error(\"Unsupported type: \" + toHex(type));\n      }\n    }\n\n    return typeInstructionNodes;\n  } // Import section\n  // https://webassembly.github.io/spec/binary/modules.html#binary-importsec\n\n\n  function parseImportSection(numberOfImports) {\n    var imports = [];\n\n    for (var i = 0; i < numberOfImports; i++) {\n      dumpSep(\"import header \" + i);\n\n      var _startLoc2 = getPosition();\n      /**\n       * Module name\n       */\n\n\n      var moduleName = readUTF8String();\n      eatBytes(moduleName.nextIndex);\n      dump([], \"module name (\".concat(moduleName.value, \")\"));\n      /**\n       * Name\n       */\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"name (\".concat(name.value, \")\"));\n      /**\n       * Import descr\n       */\n\n      var descrTypeByte = readByte();\n      eatBytes(1);\n      var descrType = constants.importTypes[descrTypeByte];\n      dump([descrTypeByte], \"import kind\");\n\n      if (typeof descrType === \"undefined\") {\n        throw new CompileError(\"Unknown import description type: \" + toHex(descrTypeByte));\n      }\n\n      var importDescr = void 0;\n\n      if (descrType === \"func\") {\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var id = getUniqueName(\"func\");\n        importDescr = t.funcImportDescr(id, t.signature(signature.params, signature.result));\n        state.functionsInModule.push({\n          id: t.identifier(name.value),\n          signature: signature,\n          isExternal: true\n        });\n      } else if (descrType === \"global\") {\n        importDescr = parseGlobalType();\n        var globalNode = t.global(importDescr, []);\n        state.globalsInModule.push(globalNode);\n      } else if (descrType === \"table\") {\n        importDescr = parseTableType(i);\n      } else if (descrType === \"mem\") {\n        var memoryNode = parseMemoryType(0);\n        state.memoriesInModule.push(memoryNode);\n        importDescr = memoryNode;\n      } else {\n        throw new CompileError(\"Unsupported import of type: \" + descrType);\n      }\n\n      imports.push(function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.moduleImport(moduleName.value, name.value, importDescr), endLoc, _startLoc2);\n      }());\n    }\n\n    return imports;\n  } // Function section\n  // https://webassembly.github.io/spec/binary/modules.html#function-section\n\n\n  function parseFuncSection(numberOfFunctions) {\n    dump([numberOfFunctions], \"num funcs\");\n\n    for (var i = 0; i < numberOfFunctions; i++) {\n      var indexU32 = readU32();\n      var typeindex = indexU32.value;\n      eatBytes(indexU32.nextIndex);\n      dump([typeindex], \"type index\");\n      var signature = state.typesInModule[typeindex];\n\n      if (typeof signature === \"undefined\") {\n        throw new CompileError(\"function signature not found (\".concat(typeindex, \")\"));\n      } // preserve anonymous, a name might be resolved later\n\n\n      var id = t.withRaw(t.identifier(getUniqueName(\"func\")), \"\");\n      state.functionsInModule.push({\n        id: id,\n        signature: signature,\n        isExternal: false\n      });\n    }\n  } // Export section\n  // https://webassembly.github.io/spec/binary/modules.html#export-section\n\n\n  function parseExportSection(numberOfExport) {\n    dump([numberOfExport], \"num exports\"); // Parse vector of exports\n\n    for (var i = 0; i < numberOfExport; i++) {\n      var _startLoc3 = getPosition();\n      /**\n       * Name\n       */\n\n\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      dump([], \"export name (\".concat(name.value, \")\"));\n      /**\n       * exportdescr\n       */\n\n      var typeIndex = readByte();\n      eatBytes(1);\n      dump([typeIndex], \"export kind\");\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      dump([index], \"export index\");\n      var id = void 0,\n          signature = void 0;\n\n      if (constants.exportTypes[typeIndex] === \"Func\") {\n        var func = state.functionsInModule[index];\n\n        if (typeof func === \"undefined\") {\n          throw new CompileError(\"unknown function (\".concat(index, \")\"));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = func.signature;\n      } else if (constants.exportTypes[typeIndex] === \"Table\") {\n        var table = state.tablesInModule[index];\n\n        if (typeof table === \"undefined\") {\n          throw new CompileError(\"unknown table \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Mem\") {\n        var memNode = state.memoriesInModule[index];\n\n        if (typeof memNode === \"undefined\") {\n          throw new CompileError(\"unknown memory \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else if (constants.exportTypes[typeIndex] === \"Global\") {\n        var global = state.globalsInModule[index];\n\n        if (typeof global === \"undefined\") {\n          throw new CompileError(\"unknown global \".concat(index));\n        }\n\n        id = t.numberLiteralFromRaw(index, String(index));\n        signature = null;\n      } else {\n        console.warn(\"Unsupported export type: \" + toHex(typeIndex));\n        return;\n      }\n\n      var endLoc = getPosition();\n      state.elementsInExportSection.push({\n        name: name.value,\n        type: constants.exportTypes[typeIndex],\n        signature: signature,\n        id: id,\n        index: index,\n        endLoc: endLoc,\n        startLoc: _startLoc3\n      });\n    }\n  } // Code section\n  // https://webassembly.github.io/spec/binary/modules.html#code-section\n\n\n  function parseCodeSection(numberOfFuncs) {\n    dump([numberOfFuncs], \"number functions\"); // Parse vector of function\n\n    for (var i = 0; i < numberOfFuncs; i++) {\n      var _startLoc4 = getPosition();\n\n      dumpSep(\"function body \" + i); // the u32 size of the function code in bytes\n      // Ignore it for now\n\n      var bodySizeU32 = readU32();\n      eatBytes(bodySizeU32.nextIndex);\n      dump([bodySizeU32.value], \"function body size\");\n      var code = [];\n      /**\n       * Parse locals\n       */\n\n      var funcLocalNumU32 = readU32();\n      var funcLocalNum = funcLocalNumU32.value;\n      eatBytes(funcLocalNumU32.nextIndex);\n      dump([funcLocalNum], \"num locals\");\n      var locals = [];\n\n      for (var _i = 0; _i < funcLocalNum; _i++) {\n        var _startLoc5 = getPosition();\n\n        var localCountU32 = readU32();\n        var localCount = localCountU32.value;\n        eatBytes(localCountU32.nextIndex);\n        dump([localCount], \"num local\");\n        var valtypeByte = readByte();\n        eatBytes(1);\n        var type = constants.valtypes[valtypeByte];\n        var args = [];\n\n        for (var _i2 = 0; _i2 < localCount; _i2++) {\n          args.push(t.valtypeLiteral(type));\n        }\n\n        var localNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(\"local\", args), endLoc, _startLoc5);\n        }();\n\n        locals.push(localNode);\n        dump([valtypeByte], type);\n\n        if (typeof type === \"undefined\") {\n          throw new CompileError(\"Unexpected valtype: \" + toHex(valtypeByte));\n        }\n      }\n\n      code.push.apply(code, locals); // Decode instructions until the end\n\n      parseInstructionBlock(code);\n      var endLoc = getPosition();\n      state.elementsInCodeSection.push({\n        code: code,\n        locals: locals,\n        endLoc: endLoc,\n        startLoc: _startLoc4,\n        bodySize: bodySizeU32.value\n      });\n    }\n  }\n\n  function parseInstructionBlock(code) {\n    while (true) {\n      var _startLoc6 = getPosition();\n\n      var instructionAlreadyCreated = false;\n      var instructionByte = readByte();\n      eatBytes(1);\n\n      if (instructionByte === 0xfe) {\n        throw new CompileError(\"Atomic instructions are not implemented\");\n      }\n\n      var instruction = constants.symbolsByByte[instructionByte];\n\n      if (typeof instruction === \"undefined\") {\n        throw new CompileError(\"Unexpected instruction: \" + toHex(instructionByte));\n      }\n\n      if (typeof instruction.object === \"string\") {\n        dump([instructionByte], \"\".concat(instruction.object, \".\").concat(instruction.name));\n      } else {\n        dump([instructionByte], instruction.name);\n      }\n      /**\n       * End of the function\n       */\n\n\n      if (instruction.name === \"end\") {\n        var node = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.instruction(instruction.name), endLoc, _startLoc6);\n        }();\n\n        code.push(node);\n        break;\n      }\n\n      var args = [];\n\n      if (instruction.name === \"loop\") {\n        var _startLoc7 = getPosition();\n\n        var blocktypeByte = readByte();\n        eatBytes(1);\n        var blocktype = constants.blockTypes[blocktypeByte];\n        dump([blocktypeByte], \"blocktype\");\n\n        if (typeof blocktype === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(blocktypeByte));\n        }\n\n        var instr = [];\n        parseInstructionBlock(instr); // preserve anonymous\n\n        var label = t.withRaw(t.identifier(getUniqueName(\"loop\")), \"\");\n\n        var loopNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.loopInstruction(label, blocktype, instr), endLoc, _startLoc7);\n        }();\n\n        code.push(loopNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"if\") {\n        var _startLoc8 = getPosition();\n\n        var _blocktypeByte = readByte();\n\n        eatBytes(1);\n        var _blocktype = constants.blockTypes[_blocktypeByte];\n        dump([_blocktypeByte], \"blocktype\");\n\n        if (typeof _blocktype === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte));\n        }\n\n        var testIndex = t.withRaw(t.identifier(getUniqueName(\"if\")), \"\");\n        var ifBody = [];\n        parseInstructionBlock(ifBody); // Defaults to no alternate\n\n        var elseIndex = 0;\n\n        for (elseIndex = 0; elseIndex < ifBody.length; ++elseIndex) {\n          var _instr = ifBody[elseIndex];\n\n          if (_instr.type === \"Instr\" && _instr.id === \"else\") {\n            break;\n          }\n        }\n\n        var consequentInstr = ifBody.slice(0, elseIndex);\n        var alternate = ifBody.slice(elseIndex + 1); // wast sugar\n\n        var testInstrs = [];\n\n        var ifNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.ifInstruction(testIndex, testInstrs, _blocktype, consequentInstr, alternate), endLoc, _startLoc8);\n        }();\n\n        code.push(ifNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"block\") {\n        var _startLoc9 = getPosition();\n\n        var _blocktypeByte2 = readByte();\n\n        eatBytes(1);\n        var _blocktype2 = constants.blockTypes[_blocktypeByte2];\n        dump([_blocktypeByte2], \"blocktype\");\n\n        if (typeof _blocktype2 === \"undefined\") {\n          throw new CompileError(\"Unexpected blocktype: \" + toHex(_blocktypeByte2));\n        }\n\n        var _instr2 = [];\n        parseInstructionBlock(_instr2); // preserve anonymous\n\n        var _label = t.withRaw(t.identifier(getUniqueName(\"block\")), \"\");\n\n        var blockNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.blockInstruction(_label, _instr2, _blocktype2), endLoc, _startLoc9);\n        }();\n\n        code.push(blockNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call\") {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n\n        var callNode = function () {\n          var endLoc = getPosition();\n          return t.withLoc(t.callInstruction(t.indexLiteral(index)), endLoc, _startLoc6);\n        }();\n\n        code.push(callNode);\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"call_indirect\") {\n        var _startLoc10 = getPosition();\n\n        var indexU32 = readU32();\n        var typeindex = indexU32.value;\n        eatBytes(indexU32.nextIndex);\n        dump([typeindex], \"type index\");\n        var signature = state.typesInModule[typeindex];\n\n        if (typeof signature === \"undefined\") {\n          throw new CompileError(\"call_indirect signature not found (\".concat(typeindex, \")\"));\n        }\n\n        var _callNode = t.callIndirectInstruction(t.signature(signature.params, signature.result), []);\n\n        var flagU32 = readU32();\n        var flag = flagU32.value; // 0x00 - reserved byte\n\n        eatBytes(flagU32.nextIndex);\n\n        if (flag !== 0) {\n          throw new CompileError(\"zero flag expected\");\n        }\n\n        code.push(function () {\n          var endLoc = getPosition();\n          return t.withLoc(_callNode, endLoc, _startLoc10);\n        }());\n        instructionAlreadyCreated = true;\n      } else if (instruction.name === \"br_table\") {\n        var indicesu32 = readU32();\n        var indices = indicesu32.value;\n        eatBytes(indicesu32.nextIndex);\n        dump([indices], \"num indices\");\n\n        for (var i = 0; i <= indices; i++) {\n          var _indexu = readU32();\n\n          var _index = _indexu.value;\n          eatBytes(_indexu.nextIndex);\n          dump([_index], \"index\");\n          args.push(t.numberLiteralFromRaw(_indexu.value.toString(), \"u32\"));\n        }\n      } else if (instructionByte >= 0x28 && instructionByte <= 0x40) {\n        /**\n         * Memory instructions\n         */\n        if (instruction.name === \"grow_memory\" || instruction.name === \"current_memory\") {\n          var _indexU = readU32();\n\n          var _index2 = _indexU.value;\n          eatBytes(_indexU.nextIndex);\n\n          if (_index2 !== 0) {\n            throw new Error(\"zero flag expected\");\n          }\n\n          dump([_index2], \"index\");\n        } else {\n          var aligun32 = readU32();\n          var align = aligun32.value;\n          eatBytes(aligun32.nextIndex);\n          dump([align], \"align\");\n          var offsetu32 = readU32();\n          var _offset2 = offsetu32.value;\n          eatBytes(offsetu32.nextIndex);\n          dump([_offset2], \"offset\");\n        }\n      } else if (instructionByte >= 0x41 && instructionByte <= 0x44) {\n        /**\n         * Numeric instructions\n         */\n        if (instruction.object === \"i32\") {\n          var value32 = read32();\n          var value = value32.value;\n          eatBytes(value32.nextIndex);\n          dump([value], \"i32 value\");\n          args.push(t.numberLiteralFromRaw(value));\n        }\n\n        if (instruction.object === \"u32\") {\n          var valueu32 = readU32();\n          var _value = valueu32.value;\n          eatBytes(valueu32.nextIndex);\n          dump([_value], \"u32 value\");\n          args.push(t.numberLiteralFromRaw(_value));\n        }\n\n        if (instruction.object === \"i64\") {\n          var value64 = read64();\n          var _value2 = value64.value;\n          eatBytes(value64.nextIndex);\n          dump([Number(_value2.toString())], \"i64 value\");\n          var high = _value2.high,\n              low = _value2.low;\n          var _node = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: high,\n              low: low\n            }\n          };\n          args.push(_node);\n        }\n\n        if (instruction.object === \"u64\") {\n          var valueu64 = readU64();\n          var _value3 = valueu64.value;\n          eatBytes(valueu64.nextIndex);\n          dump([Number(_value3.toString())], \"u64 value\");\n          var _high = _value3.high,\n              _low = _value3.low;\n          var _node2 = {\n            type: \"LongNumberLiteral\",\n            value: {\n              high: _high,\n              low: _low\n            }\n          };\n          args.push(_node2);\n        }\n\n        if (instruction.object === \"f32\") {\n          var valuef32 = readF32();\n          var _value4 = valuef32.value;\n          eatBytes(valuef32.nextIndex);\n          dump([_value4], \"f32 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value4, valuef32.nan, valuef32.inf, String(_value4)));\n        }\n\n        if (instruction.object === \"f64\") {\n          var valuef64 = readF64();\n          var _value5 = valuef64.value;\n          eatBytes(valuef64.nextIndex);\n          dump([_value5], \"f64 value\");\n          args.push( // $FlowIgnore\n          t.floatLiteral(_value5, valuef64.nan, valuef64.inf, String(_value5)));\n        }\n      } else {\n        for (var _i3 = 0; _i3 < instruction.numberOfArgs; _i3++) {\n          var u32 = readU32();\n          eatBytes(u32.nextIndex);\n          dump([u32.value], \"argument \" + _i3);\n          args.push(t.numberLiteralFromRaw(u32.value));\n        }\n      }\n\n      if (instructionAlreadyCreated === false) {\n        if (typeof instruction.object === \"string\") {\n          var _node3 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.objectInstruction(instruction.name, instruction.object, args), endLoc, _startLoc6);\n          }();\n\n          code.push(_node3);\n        } else {\n          var _node4 = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.instruction(instruction.name, args), endLoc, _startLoc6);\n          }();\n\n          code.push(_node4);\n        }\n      }\n    }\n  } // https://webassembly.github.io/spec/core/binary/types.html#limits\n\n\n  function parseLimits() {\n    var limitType = readByte();\n    eatBytes(1);\n    dump([limitType], \"limit type\");\n    var min, max;\n\n    if (limitType === 0x01 || limitType === 0x03 // shared limits\n    ) {\n        var u32min = readU32();\n        min = parseInt(u32min.value);\n        eatBytes(u32min.nextIndex);\n        dump([min], \"min\");\n        var u32max = readU32();\n        max = parseInt(u32max.value);\n        eatBytes(u32max.nextIndex);\n        dump([max], \"max\");\n      }\n\n    if (limitType === 0x00) {\n      var _u32min = readU32();\n\n      min = parseInt(_u32min.value);\n      eatBytes(_u32min.nextIndex);\n      dump([min], \"min\");\n    }\n\n    return t.limit(min, max);\n  } // https://webassembly.github.io/spec/core/binary/types.html#binary-tabletype\n\n\n  function parseTableType(index) {\n    var name = t.withRaw(t.identifier(getUniqueName(\"table\")), String(index));\n    var elementTypeByte = readByte();\n    eatBytes(1);\n    dump([elementTypeByte], \"element type\");\n    var elementType = constants.tableTypes[elementTypeByte];\n\n    if (typeof elementType === \"undefined\") {\n      throw new CompileError(\"Unknown element type in table: \" + toHex(elementType));\n    }\n\n    var limits = parseLimits();\n    return t.table(elementType, limits, name);\n  } // https://webassembly.github.io/spec/binary/types.html#global-types\n\n\n  function parseGlobalType() {\n    var valtypeByte = readByte();\n    eatBytes(1);\n    var type = constants.valtypes[valtypeByte];\n    dump([valtypeByte], type);\n\n    if (typeof type === \"undefined\") {\n      throw new CompileError(\"Unknown valtype: \" + toHex(valtypeByte));\n    }\n\n    var globalTypeByte = readByte();\n    eatBytes(1);\n    var globalType = constants.globalTypes[globalTypeByte];\n    dump([globalTypeByte], \"global type (\".concat(globalType, \")\"));\n\n    if (typeof globalType === \"undefined\") {\n      throw new CompileError(\"Invalid mutability: \" + toHex(globalTypeByte));\n    }\n\n    return t.globalType(type, globalType);\n  } // function parseNameModule() {\n  //   const lenu32 = readVaruint32();\n  //   eatBytes(lenu32.nextIndex);\n  //   console.log(\"len\", lenu32);\n  //   const strlen = lenu32.value;\n  //   dump([strlen], \"string length\");\n  //   const bytes = readBytes(strlen);\n  //   eatBytes(strlen);\n  //   const value = utf8.decode(bytes);\n  //   return [t.moduleNameMetadata(value)];\n  // }\n  // this section contains an array of function names and indices\n\n\n  function parseNameSectionFunctions() {\n    var functionNames = [];\n    var numberOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numberOfFunctionsu32.value;\n    eatBytes(numberOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var indexu32 = readU32();\n      var index = indexu32.value;\n      eatBytes(indexu32.nextIndex);\n      var name = readUTF8String();\n      eatBytes(name.nextIndex);\n      functionNames.push(t.functionNameMetadata(name.value, index));\n    }\n\n    return functionNames;\n  }\n\n  function parseNameSectionLocals() {\n    var localNames = [];\n    var numbeOfFunctionsu32 = readU32();\n    var numbeOfFunctions = numbeOfFunctionsu32.value;\n    eatBytes(numbeOfFunctionsu32.nextIndex);\n\n    for (var i = 0; i < numbeOfFunctions; i++) {\n      var functionIndexu32 = readU32();\n      var functionIndex = functionIndexu32.value;\n      eatBytes(functionIndexu32.nextIndex);\n      var numLocalsu32 = readU32();\n      var numLocals = numLocalsu32.value;\n      eatBytes(numLocalsu32.nextIndex);\n\n      for (var _i4 = 0; _i4 < numLocals; _i4++) {\n        var localIndexu32 = readU32();\n        var localIndex = localIndexu32.value;\n        eatBytes(localIndexu32.nextIndex);\n        var name = readUTF8String();\n        eatBytes(name.nextIndex);\n        localNames.push(t.localNameMetadata(name.value, localIndex, functionIndex));\n      }\n    }\n\n    return localNames;\n  } // this is a custom section used for name resolution\n  // https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n\n\n  function parseNameSection(remainingBytes) {\n    var nameMetadata = [];\n    var initialOffset = offset;\n\n    while (offset - initialOffset < remainingBytes) {\n      // name_type\n      var sectionTypeByte = readVaruint7();\n      eatBytes(sectionTypeByte.nextIndex); // name_payload_len\n\n      var subSectionSizeInBytesu32 = readVaruint32();\n      eatBytes(subSectionSizeInBytesu32.nextIndex);\n\n      switch (sectionTypeByte.value) {\n        // case 0: {\n        // TODO(sven): re-enable that\n        // Current status: it seems that when we decode the module's name\n        // no name_payload_len is used.\n        //\n        // See https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#name-section\n        //\n        // nameMetadata.push(...parseNameModule());\n        // break;\n        // }\n        case 1:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionFunctions()));\n            break;\n          }\n\n        case 2:\n          {\n            nameMetadata.push.apply(nameMetadata, _toConsumableArray(parseNameSectionLocals()));\n            break;\n          }\n\n        default:\n          {\n            // skip unknown subsection\n            eatBytes(subSectionSizeInBytesu32.value);\n          }\n      }\n    }\n\n    return nameMetadata;\n  } // this is a custom section used for information about the producers\n  // https://github.com/WebAssembly/tool-conventions/blob/master/ProducersSection.md\n\n\n  function parseProducersSection() {\n    var metadata = t.producersSectionMetadata([]); // field_count\n\n    var sectionTypeByte = readVaruint32();\n    eatBytes(sectionTypeByte.nextIndex);\n    dump([sectionTypeByte.value], \"num of producers\");\n    var fields = {\n      language: [],\n      \"processed-by\": [],\n      sdk: []\n    }; // fields\n\n    for (var fieldI = 0; fieldI < sectionTypeByte.value; fieldI++) {\n      // field_name\n      var fieldName = readUTF8String();\n      eatBytes(fieldName.nextIndex); // field_value_count\n\n      var valueCount = readVaruint32();\n      eatBytes(valueCount.nextIndex); // field_values\n\n      for (var producerI = 0; producerI < valueCount.value; producerI++) {\n        var producerName = readUTF8String();\n        eatBytes(producerName.nextIndex);\n        var producerVersion = readUTF8String();\n        eatBytes(producerVersion.nextIndex);\n        fields[fieldName.value].push(t.producerMetadataVersionedName(producerName.value, producerVersion.value));\n      }\n\n      metadata.producers.push(fields[fieldName.value]);\n    }\n\n    return metadata;\n  }\n\n  function parseGlobalSection(numberOfGlobals) {\n    var globals = [];\n    dump([numberOfGlobals], \"num globals\");\n\n    for (var i = 0; i < numberOfGlobals; i++) {\n      var _startLoc11 = getPosition();\n\n      var globalType = parseGlobalType();\n      /**\n       * Global expressions\n       */\n\n      var init = [];\n      parseInstructionBlock(init);\n\n      var node = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.global(globalType, init), endLoc, _startLoc11);\n      }();\n\n      globals.push(node);\n      state.globalsInModule.push(node);\n    }\n\n    return globals;\n  }\n\n  function parseElemSection(numberOfElements) {\n    var elems = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var _startLoc12 = getPosition();\n\n      var tableindexu32 = readU32();\n      var tableindex = tableindexu32.value;\n      eatBytes(tableindexu32.nextIndex);\n      dump([tableindex], \"table index\");\n      /**\n       * Parse instructions\n       */\n\n      var instr = [];\n      parseInstructionBlock(instr);\n      /**\n       * Parse ( vector function index ) *\n       */\n\n      var indicesu32 = readU32();\n      var indices = indicesu32.value;\n      eatBytes(indicesu32.nextIndex);\n      dump([indices], \"num indices\");\n      var indexValues = [];\n\n      for (var _i5 = 0; _i5 < indices; _i5++) {\n        var indexu32 = readU32();\n        var index = indexu32.value;\n        eatBytes(indexu32.nextIndex);\n        dump([index], \"index\");\n        indexValues.push(t.indexLiteral(index));\n      }\n\n      var elemNode = function () {\n        var endLoc = getPosition();\n        return t.withLoc(t.elem(t.indexLiteral(tableindex), instr, indexValues), endLoc, _startLoc12);\n      }();\n\n      elems.push(elemNode);\n    }\n\n    return elems;\n  } // https://webassembly.github.io/spec/core/binary/types.html#memory-types\n\n\n  function parseMemoryType(i) {\n    var limits = parseLimits();\n    return t.memory(limits, t.indexLiteral(i));\n  } // https://webassembly.github.io/spec/binary/modules.html#table-section\n\n\n  function parseTableSection(numberOfElements) {\n    var tables = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var tablesNode = parseTableType(i);\n      state.tablesInModule.push(tablesNode);\n      tables.push(tablesNode);\n    }\n\n    return tables;\n  } // https://webassembly.github.io/spec/binary/modules.html#memory-section\n\n\n  function parseMemorySection(numberOfElements) {\n    var memories = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryNode = parseMemoryType(i);\n      state.memoriesInModule.push(memoryNode);\n      memories.push(memoryNode);\n    }\n\n    return memories;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-startsec\n\n\n  function parseStartSection() {\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var startFuncIndex = u32.value;\n    eatBytes(u32.nextIndex);\n    dump([startFuncIndex], \"index\");\n    return function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.start(t.indexLiteral(startFuncIndex)), endLoc, startLoc);\n    }();\n  } // https://webassembly.github.io/spec/binary/modules.html#data-section\n\n\n  function parseDataSection(numberOfElements) {\n    var dataEntries = [];\n    dump([numberOfElements], \"num elements\");\n\n    for (var i = 0; i < numberOfElements; i++) {\n      var memoryIndexu32 = readU32();\n      var memoryIndex = memoryIndexu32.value;\n      eatBytes(memoryIndexu32.nextIndex);\n      dump([memoryIndex], \"memory index\");\n      var instrs = [];\n      parseInstructionBlock(instrs);\n      var hasExtraInstrs = instrs.filter(function (i) {\n        return i.id !== \"end\";\n      }).length !== 1;\n\n      if (hasExtraInstrs) {\n        throw new CompileError(\"data section offset must be a single instruction\");\n      }\n\n      var bytes = parseVec(function (b) {\n        return b;\n      });\n      dump([], \"init\");\n      dataEntries.push(t.data(t.memIndexLiteral(memoryIndex), instrs[0], t.byteArray(bytes)));\n    }\n\n    return dataEntries;\n  } // https://webassembly.github.io/spec/binary/modules.html#binary-section\n\n\n  function parseSection(sectionIndex) {\n    var sectionId = readByte();\n    eatBytes(1);\n\n    if (sectionId >= sectionIndex || sectionIndex === constants.sections.custom) {\n      sectionIndex = sectionId + 1;\n    } else {\n      if (sectionId !== constants.sections.custom) throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n    }\n\n    var nextSectionIndex = sectionIndex;\n    var startOffset = offset;\n    var startLoc = getPosition();\n    var u32 = readU32();\n    var sectionSizeInBytes = u32.value;\n    eatBytes(u32.nextIndex);\n\n    var sectionSizeInBytesNode = function () {\n      var endLoc = getPosition();\n      return t.withLoc(t.numberLiteralFromRaw(sectionSizeInBytes), endLoc, startLoc);\n    }();\n\n    switch (sectionId) {\n      case constants.sections.type:\n        {\n          dumpSep(\"section Type\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc13 = getPosition();\n\n          var _u = readU32();\n\n          var numberOfTypes = _u.value;\n          eatBytes(_u.nextIndex);\n\n          var _metadata = t.sectionMetadata(\"type\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTypes), endLoc, _startLoc13);\n          }());\n\n          var _nodes = parseTypeSection(numberOfTypes);\n\n          return {\n            nodes: _nodes,\n            metadata: _metadata,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.table:\n        {\n          dumpSep(\"section Table\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc14 = getPosition();\n\n          var _u2 = readU32();\n\n          var numberOfTable = _u2.value;\n          eatBytes(_u2.nextIndex);\n          dump([numberOfTable], \"num tables\");\n\n          var _metadata2 = t.sectionMetadata(\"table\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfTable), endLoc, _startLoc14);\n          }());\n\n          var _nodes2 = parseTableSection(numberOfTable);\n\n          return {\n            nodes: _nodes2,\n            metadata: _metadata2,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.import:\n        {\n          dumpSep(\"section Import\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc15 = getPosition();\n\n          var numberOfImportsu32 = readU32();\n          var numberOfImports = numberOfImportsu32.value;\n          eatBytes(numberOfImportsu32.nextIndex);\n          dump([numberOfImports], \"number of imports\");\n\n          var _metadata3 = t.sectionMetadata(\"import\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfImports), endLoc, _startLoc15);\n          }());\n\n          var _nodes3 = parseImportSection(numberOfImports);\n\n          return {\n            nodes: _nodes3,\n            metadata: _metadata3,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.func:\n        {\n          dumpSep(\"section Function\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc16 = getPosition();\n\n          var numberOfFunctionsu32 = readU32();\n          var numberOfFunctions = numberOfFunctionsu32.value;\n          eatBytes(numberOfFunctionsu32.nextIndex);\n\n          var _metadata4 = t.sectionMetadata(\"func\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFunctions), endLoc, _startLoc16);\n          }());\n\n          parseFuncSection(numberOfFunctions);\n          var _nodes4 = [];\n          return {\n            nodes: _nodes4,\n            metadata: _metadata4,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.export:\n        {\n          dumpSep(\"section Export\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc17 = getPosition();\n\n          var _u3 = readU32();\n\n          var numberOfExport = _u3.value;\n          eatBytes(_u3.nextIndex);\n\n          var _metadata5 = t.sectionMetadata(\"export\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfExport), endLoc, _startLoc17);\n          }());\n\n          parseExportSection(numberOfExport);\n          var _nodes5 = [];\n          return {\n            nodes: _nodes5,\n            metadata: _metadata5,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.code:\n        {\n          dumpSep(\"section Code\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc18 = getPosition();\n\n          var _u4 = readU32();\n\n          var numberOfFuncs = _u4.value;\n          eatBytes(_u4.nextIndex);\n\n          var _metadata6 = t.sectionMetadata(\"code\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfFuncs), endLoc, _startLoc18);\n          }());\n\n          if (opts.ignoreCodeSection === true) {\n            var remainingBytes = sectionSizeInBytes - _u4.nextIndex;\n            eatBytes(remainingBytes); // eat the entire section\n          } else {\n            parseCodeSection(numberOfFuncs);\n          }\n\n          var _nodes6 = [];\n          return {\n            nodes: _nodes6,\n            metadata: _metadata6,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.start:\n        {\n          dumpSep(\"section Start\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata7 = t.sectionMetadata(\"start\", startOffset, sectionSizeInBytesNode);\n\n          var _nodes7 = [parseStartSection()];\n          return {\n            nodes: _nodes7,\n            metadata: _metadata7,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.element:\n        {\n          dumpSep(\"section Element\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc19 = getPosition();\n\n          var numberOfElementsu32 = readU32();\n          var numberOfElements = numberOfElementsu32.value;\n          eatBytes(numberOfElementsu32.nextIndex);\n\n          var _metadata8 = t.sectionMetadata(\"element\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfElements), endLoc, _startLoc19);\n          }());\n\n          var _nodes8 = parseElemSection(numberOfElements);\n\n          return {\n            nodes: _nodes8,\n            metadata: _metadata8,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.global:\n        {\n          dumpSep(\"section Global\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc20 = getPosition();\n\n          var numberOfGlobalsu32 = readU32();\n          var numberOfGlobals = numberOfGlobalsu32.value;\n          eatBytes(numberOfGlobalsu32.nextIndex);\n\n          var _metadata9 = t.sectionMetadata(\"global\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(numberOfGlobals), endLoc, _startLoc20);\n          }());\n\n          var _nodes9 = parseGlobalSection(numberOfGlobals);\n\n          return {\n            nodes: _nodes9,\n            metadata: _metadata9,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.memory:\n        {\n          dumpSep(\"section Memory\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _startLoc21 = getPosition();\n\n          var _numberOfElementsu = readU32();\n\n          var _numberOfElements = _numberOfElementsu.value;\n          eatBytes(_numberOfElementsu.nextIndex);\n\n          var _metadata10 = t.sectionMetadata(\"memory\", startOffset, sectionSizeInBytesNode, function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements), endLoc, _startLoc21);\n          }());\n\n          var _nodes10 = parseMemorySection(_numberOfElements);\n\n          return {\n            nodes: _nodes10,\n            metadata: _metadata10,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n\n      case constants.sections.data:\n        {\n          dumpSep(\"section Data\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n\n          var _metadata11 = t.sectionMetadata(\"data\", startOffset, sectionSizeInBytesNode);\n\n          var _startLoc22 = getPosition();\n\n          var _numberOfElementsu2 = readU32();\n\n          var _numberOfElements2 = _numberOfElementsu2.value;\n          eatBytes(_numberOfElementsu2.nextIndex);\n\n          _metadata11.vectorOfSize = function () {\n            var endLoc = getPosition();\n            return t.withLoc(t.numberLiteralFromRaw(_numberOfElements2), endLoc, _startLoc22);\n          }();\n\n          if (opts.ignoreDataSection === true) {\n            var _remainingBytes = sectionSizeInBytes - _numberOfElementsu2.nextIndex;\n\n            eatBytes(_remainingBytes); // eat the entire section\n\n            dumpSep(\"ignore data (\" + sectionSizeInBytes + \" bytes)\");\n            return {\n              nodes: [],\n              metadata: _metadata11,\n              nextSectionIndex: nextSectionIndex\n            };\n          } else {\n            var _nodes11 = parseDataSection(_numberOfElements2);\n\n            return {\n              nodes: _nodes11,\n              metadata: _metadata11,\n              nextSectionIndex: nextSectionIndex\n            };\n          }\n        }\n\n      case constants.sections.custom:\n        {\n          dumpSep(\"section Custom\");\n          dump([sectionId], \"section code\");\n          dump([sectionSizeInBytes], \"section size\");\n          var _metadata12 = [t.sectionMetadata(\"custom\", startOffset, sectionSizeInBytesNode)];\n          var sectionName = readUTF8String();\n          eatBytes(sectionName.nextIndex);\n          dump([], \"section name (\".concat(sectionName.value, \")\"));\n\n          var _remainingBytes2 = sectionSizeInBytes - sectionName.nextIndex;\n\n          if (sectionName.value === \"name\") {\n            var initialOffset = offset;\n\n            try {\n              _metadata12.push.apply(_metadata12, _toConsumableArray(parseNameSection(_remainingBytes2)));\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"name\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (initialOffset + _remainingBytes2));\n            }\n          } else if (sectionName.value === \"producers\") {\n            var _initialOffset = offset;\n\n            try {\n              _metadata12.push(parseProducersSection());\n            } catch (e) {\n              console.warn(\"Failed to decode custom \\\"producers\\\" section @\".concat(offset, \"; ignoring (\").concat(e.message, \").\"));\n              eatBytes(offset - (_initialOffset + _remainingBytes2));\n            }\n          } else {\n            // We don't parse the custom section\n            eatBytes(_remainingBytes2);\n            dumpSep(\"ignore custom \" + JSON.stringify(sectionName.value) + \" section (\" + _remainingBytes2 + \" bytes)\");\n          }\n\n          return {\n            nodes: [],\n            metadata: _metadata12,\n            nextSectionIndex: nextSectionIndex\n          };\n        }\n    }\n\n    throw new CompileError(\"Unexpected section: \" + toHex(sectionId));\n  }\n\n  parseModuleHeader();\n  parseVersion();\n  var moduleFields = [];\n  var sectionIndex = 0;\n  var moduleMetadata = {\n    sections: [],\n    functionNames: [],\n    localNames: [],\n    producers: []\n  };\n  /**\n   * All the generate declaration are going to be stored in our state\n   */\n\n  while (offset < buf.length) {\n    var _parseSection = parseSection(sectionIndex),\n        _nodes12 = _parseSection.nodes,\n        _metadata13 = _parseSection.metadata,\n        nextSectionIndex = _parseSection.nextSectionIndex;\n\n    moduleFields.push.apply(moduleFields, _toConsumableArray(_nodes12));\n    var metadataArray = Array.isArray(_metadata13) ? _metadata13 : [_metadata13];\n    metadataArray.forEach(function (metadataItem) {\n      if (metadataItem.type === \"FunctionNameMetadata\") {\n        moduleMetadata.functionNames.push(metadataItem);\n      } else if (metadataItem.type === \"LocalNameMetadata\") {\n        moduleMetadata.localNames.push(metadataItem);\n      } else if (metadataItem.type === \"ProducersSectionMetadata\") {\n        moduleMetadata.producers.push(metadataItem);\n      } else {\n        moduleMetadata.sections.push(metadataItem);\n      }\n    }); // Ignore custom section\n\n    if (nextSectionIndex) {\n      sectionIndex = nextSectionIndex;\n    }\n  }\n  /**\n   * Transform the state into AST nodes\n   */\n\n\n  var funcIndex = 0;\n  state.functionsInModule.forEach(function (func) {\n    var params = func.signature.params;\n    var result = func.signature.result;\n    var body = []; // External functions doesn't provide any code, can skip it here\n\n    if (func.isExternal === true) {\n      return;\n    }\n\n    var decodedElementInCodeSection = state.elementsInCodeSection[funcIndex];\n\n    if (opts.ignoreCodeSection === false) {\n      if (typeof decodedElementInCodeSection === \"undefined\") {\n        throw new CompileError(\"func \" + toHex(funcIndex) + \" code not found\");\n      }\n\n      body = decodedElementInCodeSection.code;\n    }\n\n    funcIndex++;\n    var funcNode = t.func(func.id, t.signature(params, result), body);\n\n    if (func.isExternal === true) {\n      funcNode.isExternal = func.isExternal;\n    } // Add function position in the binary if possible\n\n\n    if (opts.ignoreCodeSection === false) {\n      var _startLoc23 = decodedElementInCodeSection.startLoc,\n          endLoc = decodedElementInCodeSection.endLoc,\n          bodySize = decodedElementInCodeSection.bodySize;\n      funcNode = t.withLoc(funcNode, endLoc, _startLoc23);\n      funcNode.metadata = {\n        bodySize: bodySize\n      };\n    }\n\n    moduleFields.push(funcNode);\n  });\n  state.elementsInExportSection.forEach(function (moduleExport) {\n    /**\n     * If the export has no id, we won't be able to call it from the outside\n     * so we can omit it\n     */\n    if (moduleExport.id != null) {\n      moduleFields.push(t.withLoc(t.moduleExport(moduleExport.name, t.moduleExportDescr(moduleExport.type, moduleExport.id)), moduleExport.endLoc, moduleExport.startLoc));\n    }\n  });\n  dumpSep(\"end of program\");\n  var module = t.module(null, moduleFields, t.moduleMetadata(moduleMetadata.sections, moduleMetadata.functionNames, moduleMetadata.localNames, moduleMetadata.producers));\n  return t.program([module]);\n}"]},"metadata":{},"sourceType":"module"}