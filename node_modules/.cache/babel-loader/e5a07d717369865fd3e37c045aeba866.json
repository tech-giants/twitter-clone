{"ast":null,"code":"'use strict';\n\nvar splitString = require('split-string');\n\nvar utils = module.exports;\n/**\n * Module dependencies\n */\n\nutils.extend = require('extend-shallow');\nutils.flatten = require('arr-flatten');\nutils.isObject = require('isobject');\nutils.fillRange = require('fill-range');\nutils.repeat = require('repeat-element');\nutils.unique = require('array-unique');\n\nutils.define = function (obj, key, val) {\n  Object.defineProperty(obj, key, {\n    writable: true,\n    configurable: true,\n    enumerable: false,\n    value: val\n  });\n};\n/**\n * Returns true if the given string contains only empty brace sets.\n */\n\n\nutils.isEmptySets = function (str) {\n  return /^(?:\\{,\\})+$/.test(str);\n};\n/**\n * Returns true if the given string contains only empty brace sets.\n */\n\n\nutils.isQuotedString = function (str) {\n  var open = str.charAt(0);\n\n  if (open === '\\'' || open === '\"' || open === '`') {\n    return str.slice(-1) === open;\n  }\n\n  return false;\n};\n/**\n * Create the key to use for memoization. The unique key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\n\nutils.createKey = function (pattern, options) {\n  var id = pattern;\n\n  if (typeof options === 'undefined') {\n    return id;\n  }\n\n  var keys = Object.keys(options);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    id += ';' + key + '=' + String(options[key]);\n  }\n\n  return id;\n};\n/**\n * Normalize options\n */\n\n\nutils.createOptions = function (options) {\n  var opts = utils.extend.apply(null, arguments);\n\n  if (typeof opts.expand === 'boolean') {\n    opts.optimize = !opts.expand;\n  }\n\n  if (typeof opts.optimize === 'boolean') {\n    opts.expand = !opts.optimize;\n  }\n\n  if (opts.optimize === true) {\n    opts.makeRe = true;\n  }\n\n  return opts;\n};\n/**\n * Join patterns in `a` to patterns in `b`\n */\n\n\nutils.join = function (a, b, options) {\n  options = options || {};\n  a = utils.arrayify(a);\n  b = utils.arrayify(b);\n  if (!a.length) return b;\n  if (!b.length) return a;\n  var len = a.length;\n  var idx = -1;\n  var arr = [];\n\n  while (++idx < len) {\n    var val = a[idx];\n\n    if (Array.isArray(val)) {\n      for (var i = 0; i < val.length; i++) {\n        val[i] = utils.join(val[i], b, options);\n      }\n\n      arr.push(val);\n      continue;\n    }\n\n    for (var j = 0; j < b.length; j++) {\n      var bval = b[j];\n\n      if (Array.isArray(bval)) {\n        arr.push(utils.join(val, bval, options));\n      } else {\n        arr.push(val + bval);\n      }\n    }\n  }\n\n  return arr;\n};\n/**\n * Split the given string on `,` if not escaped.\n */\n\n\nutils.split = function (str, options) {\n  var opts = utils.extend({\n    sep: ','\n  }, options);\n\n  if (typeof opts.keepQuotes !== 'boolean') {\n    opts.keepQuotes = true;\n  }\n\n  if (opts.unescape === false) {\n    opts.keepEscaping = true;\n  }\n\n  return splitString(str, opts, utils.escapeBrackets(opts));\n};\n/**\n * Expand ranges or sets in the given `pattern`.\n *\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object}\n */\n\n\nutils.expand = function (str, options) {\n  var opts = utils.extend({\n    rangeLimit: 10000\n  }, options);\n  var segs = utils.split(str, opts);\n  var tok = {\n    segs: segs\n  };\n\n  if (utils.isQuotedString(str)) {\n    return tok;\n  }\n\n  if (opts.rangeLimit === true) {\n    opts.rangeLimit = 10000;\n  }\n\n  if (segs.length > 1) {\n    if (opts.optimize === false) {\n      tok.val = segs[0];\n      return tok;\n    }\n\n    tok.segs = utils.stringifyArray(tok.segs);\n  } else if (segs.length === 1) {\n    var arr = str.split('..');\n\n    if (arr.length === 1) {\n      tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;\n      tok.segs = [];\n      return tok;\n    }\n\n    if (arr.length === 2 && arr[0] === arr[1]) {\n      tok.escaped = true;\n      tok.val = arr[0];\n      tok.segs = [];\n      return tok;\n    }\n\n    if (arr.length > 1) {\n      if (opts.optimize !== false) {\n        opts.optimize = true;\n        delete opts.expand;\n      }\n\n      if (opts.optimize !== true) {\n        var min = Math.min(arr[0], arr[1]);\n        var max = Math.max(arr[0], arr[1]);\n        var step = arr[2] || 1;\n\n        if (opts.rangeLimit !== false && (max - min) / step >= opts.rangeLimit) {\n          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n        }\n      }\n\n      arr.push(opts);\n      tok.segs = utils.fillRange.apply(null, arr);\n\n      if (!tok.segs.length) {\n        tok.escaped = true;\n        tok.val = str;\n        return tok;\n      }\n\n      if (opts.optimize === true) {\n        tok.segs = utils.stringifyArray(tok.segs);\n      }\n\n      if (tok.segs === '') {\n        tok.val = str;\n      } else {\n        tok.val = tok.segs[0];\n      }\n\n      return tok;\n    }\n  } else {\n    tok.val = str;\n  }\n\n  return tok;\n};\n/**\n * Ensure commas inside brackets and parens are not split.\n * @param {Object} `tok` Token from the `split-string` module\n * @return {undefined}\n */\n\n\nutils.escapeBrackets = function (options) {\n  return function (tok) {\n    if (tok.escaped && tok.val === 'b') {\n      tok.val = '\\\\b';\n      return;\n    }\n\n    if (tok.val !== '(' && tok.val !== '[') return;\n    var opts = utils.extend({}, options);\n    var brackets = [];\n    var parens = [];\n    var stack = [];\n    var val = tok.val;\n    var str = tok.str;\n    var i = tok.idx - 1;\n\n    while (++i < str.length) {\n      var ch = str[i];\n\n      if (ch === '\\\\') {\n        val += (opts.keepEscaping === false ? '' : ch) + str[++i];\n        continue;\n      }\n\n      if (ch === '(') {\n        parens.push(ch);\n        stack.push(ch);\n      }\n\n      if (ch === '[') {\n        brackets.push(ch);\n        stack.push(ch);\n      }\n\n      if (ch === ')') {\n        parens.pop();\n        stack.pop();\n\n        if (!stack.length) {\n          val += ch;\n          break;\n        }\n      }\n\n      if (ch === ']') {\n        brackets.pop();\n        stack.pop();\n\n        if (!stack.length) {\n          val += ch;\n          break;\n        }\n      }\n\n      val += ch;\n    }\n\n    tok.split = false;\n    tok.val = val.slice(1);\n    tok.idx = i;\n  };\n};\n/**\n * Returns true if the given string looks like a regex quantifier\n * @return {Boolean}\n */\n\n\nutils.isQuantifier = function (str) {\n  return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);\n};\n/**\n * Cast `val` to an array.\n * @param {*} `val`\n */\n\n\nutils.stringifyArray = function (arr) {\n  return [utils.arrayify(arr).join('|')];\n};\n/**\n * Cast `val` to an array.\n * @param {*} `val`\n */\n\n\nutils.arrayify = function (arr) {\n  if (typeof arr === 'undefined') {\n    return [];\n  }\n\n  if (typeof arr === 'string') {\n    return [arr];\n  }\n\n  return arr;\n};\n/**\n * Returns true if the given `str` is a non-empty string\n * @return {Boolean}\n */\n\n\nutils.isString = function (str) {\n  return str != null && typeof str === 'string';\n};\n/**\n * Get the last element from `array`\n * @param {Array} `array`\n * @return {*}\n */\n\n\nutils.last = function (arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\nutils.escapeRegex = function (str) {\n  return str.replace(/\\\\?([!^*?()[\\]{}+?/])/g, '\\\\$1');\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/node_modules/braces/lib/utils.js"],"names":["splitString","require","utils","module","exports","extend","flatten","isObject","fillRange","repeat","unique","define","obj","key","val","Object","defineProperty","writable","configurable","enumerable","value","isEmptySets","str","test","isQuotedString","open","charAt","slice","createKey","pattern","options","id","keys","i","length","String","createOptions","opts","apply","arguments","expand","optimize","makeRe","join","a","b","arrayify","len","idx","arr","Array","isArray","push","j","bval","split","sep","keepQuotes","unescape","keepEscaping","escapeBrackets","rangeLimit","segs","tok","stringifyArray","escaped","min","Math","max","step","RangeError","brackets","parens","stack","ch","pop","isQuantifier","isString","last","n","escapeRegex","replace"],"mappings":"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","sourcesContent":["'use strict';\n\nvar splitString = require('split-string');\nvar utils = module.exports;\n\n/**\n * Module dependencies\n */\n\nutils.extend = require('extend-shallow');\nutils.flatten = require('arr-flatten');\nutils.isObject = require('isobject');\nutils.fillRange = require('fill-range');\nutils.repeat = require('repeat-element');\nutils.unique = require('array-unique');\n\nutils.define = function(obj, key, val) {\n  Object.defineProperty(obj, key, {\n    writable: true,\n    configurable: true,\n    enumerable: false,\n    value: val\n  });\n};\n\n/**\n * Returns true if the given string contains only empty brace sets.\n */\n\nutils.isEmptySets = function(str) {\n  return /^(?:\\{,\\})+$/.test(str);\n};\n\n/**\n * Returns true if the given string contains only empty brace sets.\n */\n\nutils.isQuotedString = function(str) {\n  var open = str.charAt(0);\n  if (open === '\\'' || open === '\"' || open === '`') {\n    return str.slice(-1) === open;\n  }\n  return false;\n};\n\n/**\n * Create the key to use for memoization. The unique key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  var id = pattern;\n  if (typeof options === 'undefined') {\n    return id;\n  }\n  var keys = Object.keys(options);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    id += ';' + key + '=' + String(options[key]);\n  }\n  return id;\n};\n\n/**\n * Normalize options\n */\n\nutils.createOptions = function(options) {\n  var opts = utils.extend.apply(null, arguments);\n  if (typeof opts.expand === 'boolean') {\n    opts.optimize = !opts.expand;\n  }\n  if (typeof opts.optimize === 'boolean') {\n    opts.expand = !opts.optimize;\n  }\n  if (opts.optimize === true) {\n    opts.makeRe = true;\n  }\n  return opts;\n};\n\n/**\n * Join patterns in `a` to patterns in `b`\n */\n\nutils.join = function(a, b, options) {\n  options = options || {};\n  a = utils.arrayify(a);\n  b = utils.arrayify(b);\n\n  if (!a.length) return b;\n  if (!b.length) return a;\n\n  var len = a.length;\n  var idx = -1;\n  var arr = [];\n\n  while (++idx < len) {\n    var val = a[idx];\n    if (Array.isArray(val)) {\n      for (var i = 0; i < val.length; i++) {\n        val[i] = utils.join(val[i], b, options);\n      }\n      arr.push(val);\n      continue;\n    }\n\n    for (var j = 0; j < b.length; j++) {\n      var bval = b[j];\n\n      if (Array.isArray(bval)) {\n        arr.push(utils.join(val, bval, options));\n      } else {\n        arr.push(val + bval);\n      }\n    }\n  }\n  return arr;\n};\n\n/**\n * Split the given string on `,` if not escaped.\n */\n\nutils.split = function(str, options) {\n  var opts = utils.extend({sep: ','}, options);\n  if (typeof opts.keepQuotes !== 'boolean') {\n    opts.keepQuotes = true;\n  }\n  if (opts.unescape === false) {\n    opts.keepEscaping = true;\n  }\n  return splitString(str, opts, utils.escapeBrackets(opts));\n};\n\n/**\n * Expand ranges or sets in the given `pattern`.\n *\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object}\n */\n\nutils.expand = function(str, options) {\n  var opts = utils.extend({rangeLimit: 10000}, options);\n  var segs = utils.split(str, opts);\n  var tok = { segs: segs };\n\n  if (utils.isQuotedString(str)) {\n    return tok;\n  }\n\n  if (opts.rangeLimit === true) {\n    opts.rangeLimit = 10000;\n  }\n\n  if (segs.length > 1) {\n    if (opts.optimize === false) {\n      tok.val = segs[0];\n      return tok;\n    }\n\n    tok.segs = utils.stringifyArray(tok.segs);\n  } else if (segs.length === 1) {\n    var arr = str.split('..');\n\n    if (arr.length === 1) {\n      tok.val = tok.segs[tok.segs.length - 1] || tok.val || str;\n      tok.segs = [];\n      return tok;\n    }\n\n    if (arr.length === 2 && arr[0] === arr[1]) {\n      tok.escaped = true;\n      tok.val = arr[0];\n      tok.segs = [];\n      return tok;\n    }\n\n    if (arr.length > 1) {\n      if (opts.optimize !== false) {\n        opts.optimize = true;\n        delete opts.expand;\n      }\n\n      if (opts.optimize !== true) {\n        var min = Math.min(arr[0], arr[1]);\n        var max = Math.max(arr[0], arr[1]);\n        var step = arr[2] || 1;\n\n        if (opts.rangeLimit !== false && ((max - min) / step >= opts.rangeLimit)) {\n          throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n        }\n      }\n\n      arr.push(opts);\n      tok.segs = utils.fillRange.apply(null, arr);\n\n      if (!tok.segs.length) {\n        tok.escaped = true;\n        tok.val = str;\n        return tok;\n      }\n\n      if (opts.optimize === true) {\n        tok.segs = utils.stringifyArray(tok.segs);\n      }\n\n      if (tok.segs === '') {\n        tok.val = str;\n      } else {\n        tok.val = tok.segs[0];\n      }\n      return tok;\n    }\n  } else {\n    tok.val = str;\n  }\n  return tok;\n};\n\n/**\n * Ensure commas inside brackets and parens are not split.\n * @param {Object} `tok` Token from the `split-string` module\n * @return {undefined}\n */\n\nutils.escapeBrackets = function(options) {\n  return function(tok) {\n    if (tok.escaped && tok.val === 'b') {\n      tok.val = '\\\\b';\n      return;\n    }\n\n    if (tok.val !== '(' && tok.val !== '[') return;\n    var opts = utils.extend({}, options);\n    var brackets = [];\n    var parens = [];\n    var stack = [];\n    var val = tok.val;\n    var str = tok.str;\n    var i = tok.idx - 1;\n\n    while (++i < str.length) {\n      var ch = str[i];\n\n      if (ch === '\\\\') {\n        val += (opts.keepEscaping === false ? '' : ch) + str[++i];\n        continue;\n      }\n\n      if (ch === '(') {\n        parens.push(ch);\n        stack.push(ch);\n      }\n\n      if (ch === '[') {\n        brackets.push(ch);\n        stack.push(ch);\n      }\n\n      if (ch === ')') {\n        parens.pop();\n        stack.pop();\n        if (!stack.length) {\n          val += ch;\n          break;\n        }\n      }\n\n      if (ch === ']') {\n        brackets.pop();\n        stack.pop();\n        if (!stack.length) {\n          val += ch;\n          break;\n        }\n      }\n      val += ch;\n    }\n\n    tok.split = false;\n    tok.val = val.slice(1);\n    tok.idx = i;\n  };\n};\n\n/**\n * Returns true if the given string looks like a regex quantifier\n * @return {Boolean}\n */\n\nutils.isQuantifier = function(str) {\n  return /^(?:[0-9]?,[0-9]|[0-9],)$/.test(str);\n};\n\n/**\n * Cast `val` to an array.\n * @param {*} `val`\n */\n\nutils.stringifyArray = function(arr) {\n  return [utils.arrayify(arr).join('|')];\n};\n\n/**\n * Cast `val` to an array.\n * @param {*} `val`\n */\n\nutils.arrayify = function(arr) {\n  if (typeof arr === 'undefined') {\n    return [];\n  }\n  if (typeof arr === 'string') {\n    return [arr];\n  }\n  return arr;\n};\n\n/**\n * Returns true if the given `str` is a non-empty string\n * @return {Boolean}\n */\n\nutils.isString = function(str) {\n  return str != null && typeof str === 'string';\n};\n\n/**\n * Get the last element from `array`\n * @param {Array} `array`\n * @return {*}\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\nutils.escapeRegex = function(str) {\n  return str.replace(/\\\\?([!^*?()[\\]{}+?/])/g, '\\\\$1');\n};\n"]},"metadata":{},"sourceType":"script"}