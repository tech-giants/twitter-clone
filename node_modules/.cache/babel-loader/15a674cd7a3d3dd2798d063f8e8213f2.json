{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * bufs: Buffer utilities.\n */\n\n/*\n * Module variables\n */\n\n/** Pool of buffers, where `bufPool[x].length === x`. */\nvar bufPool = [];\n/** Maximum length of kept temporary buffers. */\n\nvar TEMP_BUF_MAXIMUM_LENGTH = 20;\n/** Minimum exactly-representable 64-bit int. */\n\nvar MIN_EXACT_INT64 = -0x8000000000000000;\n/** Maximum exactly-representable 64-bit int. */\n\nvar MAX_EXACT_INT64 = 0x7ffffffffffffc00;\n/** Maximum exactly-representable 64-bit uint. */\n\nvar MAX_EXACT_UINT64 = 0xfffffffffffff800;\n/**\n * The int value consisting just of a 1 in bit #32 (that is, one more\n * than the maximum 32-bit unsigned value).\n */\n\nvar BIT_32 = 0x100000000;\n/**\n * The int value consisting just of a 1 in bit #64 (that is, one more\n * than the maximum 64-bit unsigned value).\n */\n\nvar BIT_64 = 0x10000000000000000;\n/*\n * Helper functions\n */\n\n/**\n * Masks off all but the lowest bit set of the given number.\n */\n\nfunction lowestBit(num) {\n  return num & -num;\n}\n/**\n * Gets whether trying to add the second number to the first is lossy\n * (inexact). The first number is meant to be an accumulated result.\n */\n\n\nfunction isLossyToAdd(accum, num) {\n  if (num === 0) {\n    return false;\n  }\n\n  var lowBit = lowestBit(num);\n  var added = accum + lowBit;\n\n  if (added === accum) {\n    return true;\n  }\n\n  if (added - lowBit !== accum) {\n    return true;\n  }\n\n  return false;\n}\n/*\n * Exported functions\n */\n\n/**\n * Allocates a buffer of the given length, which is initialized\n * with all zeroes. This returns a buffer from the pool if it is\n * available, or a freshly-allocated buffer if not.\n */\n\n\nexport function alloc(length) {\n  var result = bufPool[length];\n\n  if (result) {\n    bufPool[length] = undefined;\n  } else {\n    result = new Buffer(length);\n  }\n\n  result.fill(0);\n  return result;\n}\n/**\n * Releases a buffer back to the pool.\n */\n\nexport function free(buffer) {\n  var length = buffer.length;\n\n  if (length < TEMP_BUF_MAXIMUM_LENGTH) {\n    bufPool[length] = buffer;\n  }\n}\n/**\n * Resizes a buffer, returning a new buffer. Returns the argument if\n * the length wouldn't actually change. This function is only safe to\n * use if the given buffer was allocated within this module (since\n * otherwise the buffer might possibly be shared externally).\n */\n\nexport function resize(buffer, length) {\n  if (length === buffer.length) {\n    return buffer;\n  }\n\n  var newBuf = alloc(length);\n  buffer.copy(newBuf);\n  free(buffer);\n  return newBuf;\n}\n/**\n * Reads an arbitrary signed int from a buffer.\n */\n\nexport function readInt(buffer) {\n  var length = buffer.length;\n  var positive = buffer[length - 1] < 0x80;\n  var result = positive ? 0 : -1;\n  var lossy = false; // Note: We can't use bit manipulation here, since that stops\n  // working if the result won't fit in a 32-bit int.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (because the result has\n    // no more than 48 bits, and loss only happens with 54 or more).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i = length - 1; _i >= 0; _i--) {\n      var one = buffer[_i];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Reads an arbitrary unsigned int from a buffer.\n */\n\nexport function readUInt(buffer) {\n  var length = buffer.length;\n  var result = 0;\n  var lossy = false; // Note: See above in re bit manipulation.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (see above).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i2 = length - 1; _i2 >= 0; _i2--) {\n      var one = buffer[_i2];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Writes a little-endian 64-bit signed int into a buffer.\n */\n\nexport function writeInt64(value, buffer) {\n  if (value < MIN_EXACT_INT64 || value > MAX_EXACT_INT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  if (value < 0) {\n    value += BIT_64;\n  }\n\n  writeUInt64(value, buffer);\n}\n/**\n * Writes a little-endian 64-bit unsigned int into a buffer.\n */\n\nexport function writeUInt64(value, buffer) {\n  if (value < 0 || value > MAX_EXACT_UINT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  var lowWord = value % BIT_32;\n  var highWord = Math.floor(value / BIT_32);\n  buffer.writeUInt32LE(lowWord, 0);\n  buffer.writeUInt32LE(highWord, 4);\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/leb128/esm/bufs.js"],"names":["bufPool","TEMP_BUF_MAXIMUM_LENGTH","MIN_EXACT_INT64","MAX_EXACT_INT64","MAX_EXACT_UINT64","BIT_32","BIT_64","lowestBit","num","isLossyToAdd","accum","lowBit","added","alloc","length","result","undefined","Buffer","fill","free","buffer","resize","newBuf","copy","readInt","positive","lossy","i","_i","one","value","readUInt","_i2","writeInt64","Error","writeUInt64","lowWord","highWord","Math","floor","writeUInt32LE"],"mappings":"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","sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * bufs: Buffer utilities.\n */\n\n/*\n * Module variables\n */\n\n/** Pool of buffers, where `bufPool[x].length === x`. */\nvar bufPool = [];\n/** Maximum length of kept temporary buffers. */\n\nvar TEMP_BUF_MAXIMUM_LENGTH = 20;\n/** Minimum exactly-representable 64-bit int. */\n\nvar MIN_EXACT_INT64 = -0x8000000000000000;\n/** Maximum exactly-representable 64-bit int. */\n\nvar MAX_EXACT_INT64 = 0x7ffffffffffffc00;\n/** Maximum exactly-representable 64-bit uint. */\n\nvar MAX_EXACT_UINT64 = 0xfffffffffffff800;\n/**\n * The int value consisting just of a 1 in bit #32 (that is, one more\n * than the maximum 32-bit unsigned value).\n */\n\nvar BIT_32 = 0x100000000;\n/**\n * The int value consisting just of a 1 in bit #64 (that is, one more\n * than the maximum 64-bit unsigned value).\n */\n\nvar BIT_64 = 0x10000000000000000;\n/*\n * Helper functions\n */\n\n/**\n * Masks off all but the lowest bit set of the given number.\n */\n\nfunction lowestBit(num) {\n  return num & -num;\n}\n/**\n * Gets whether trying to add the second number to the first is lossy\n * (inexact). The first number is meant to be an accumulated result.\n */\n\n\nfunction isLossyToAdd(accum, num) {\n  if (num === 0) {\n    return false;\n  }\n\n  var lowBit = lowestBit(num);\n  var added = accum + lowBit;\n\n  if (added === accum) {\n    return true;\n  }\n\n  if (added - lowBit !== accum) {\n    return true;\n  }\n\n  return false;\n}\n/*\n * Exported functions\n */\n\n/**\n * Allocates a buffer of the given length, which is initialized\n * with all zeroes. This returns a buffer from the pool if it is\n * available, or a freshly-allocated buffer if not.\n */\n\n\nexport function alloc(length) {\n  var result = bufPool[length];\n\n  if (result) {\n    bufPool[length] = undefined;\n  } else {\n    result = new Buffer(length);\n  }\n\n  result.fill(0);\n  return result;\n}\n/**\n * Releases a buffer back to the pool.\n */\n\nexport function free(buffer) {\n  var length = buffer.length;\n\n  if (length < TEMP_BUF_MAXIMUM_LENGTH) {\n    bufPool[length] = buffer;\n  }\n}\n/**\n * Resizes a buffer, returning a new buffer. Returns the argument if\n * the length wouldn't actually change. This function is only safe to\n * use if the given buffer was allocated within this module (since\n * otherwise the buffer might possibly be shared externally).\n */\n\nexport function resize(buffer, length) {\n  if (length === buffer.length) {\n    return buffer;\n  }\n\n  var newBuf = alloc(length);\n  buffer.copy(newBuf);\n  free(buffer);\n  return newBuf;\n}\n/**\n * Reads an arbitrary signed int from a buffer.\n */\n\nexport function readInt(buffer) {\n  var length = buffer.length;\n  var positive = buffer[length - 1] < 0x80;\n  var result = positive ? 0 : -1;\n  var lossy = false; // Note: We can't use bit manipulation here, since that stops\n  // working if the result won't fit in a 32-bit int.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (because the result has\n    // no more than 48 bits, and loss only happens with 54 or more).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i = length - 1; _i >= 0; _i--) {\n      var one = buffer[_i];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Reads an arbitrary unsigned int from a buffer.\n */\n\nexport function readUInt(buffer) {\n  var length = buffer.length;\n  var result = 0;\n  var lossy = false; // Note: See above in re bit manipulation.\n\n  if (length < 7) {\n    // Common case which can't possibly be lossy (see above).\n    for (var i = length - 1; i >= 0; i--) {\n      result = result * 0x100 + buffer[i];\n    }\n  } else {\n    for (var _i2 = length - 1; _i2 >= 0; _i2--) {\n      var one = buffer[_i2];\n      result *= 0x100;\n\n      if (isLossyToAdd(result, one)) {\n        lossy = true;\n      }\n\n      result += one;\n    }\n  }\n\n  return {\n    value: result,\n    lossy: lossy\n  };\n}\n/**\n * Writes a little-endian 64-bit signed int into a buffer.\n */\n\nexport function writeInt64(value, buffer) {\n  if (value < MIN_EXACT_INT64 || value > MAX_EXACT_INT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  if (value < 0) {\n    value += BIT_64;\n  }\n\n  writeUInt64(value, buffer);\n}\n/**\n * Writes a little-endian 64-bit unsigned int into a buffer.\n */\n\nexport function writeUInt64(value, buffer) {\n  if (value < 0 || value > MAX_EXACT_UINT64) {\n    throw new Error(\"Value out of range.\");\n  }\n\n  var lowWord = value % BIT_32;\n  var highWord = Math.floor(value / BIT_32);\n  buffer.writeUInt32LE(lowWord, 0);\n  buffer.writeUInt32LE(highWord, 4);\n}"]},"metadata":{},"sourceType":"module"}