{"ast":null,"code":"'use strict';\n\nmodule.exports = copy;\nmodule.exports.item = copyItem;\nmodule.exports.recurse = recurseDir;\nmodule.exports.symlink = copySymlink;\nmodule.exports.file = copyFile;\n\nvar nodeFs = require('fs');\n\nvar path = require('path');\n\nvar validate = require('aproba');\n\nvar stockWriteStreamAtomic = require('fs-write-stream-atomic');\n\nvar mkdirp = require('mkdirp');\n\nvar rimraf = require('rimraf');\n\nvar isWindows = require('./is-windows');\n\nvar RunQueue = require('run-queue');\n\nvar extend = Object.assign || require('util')._extend;\n\nfunction promisify(Promise, fn) {\n  return function () {\n    var args = [].slice.call(arguments);\n    return new Promise(function (resolve, reject) {\n      return fn.apply(null, args.concat(function (err, value) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(value);\n        }\n      }));\n    });\n  };\n}\n\nfunction copy(from, to, opts) {\n  validate('SSO|SS', arguments);\n  opts = extend({}, opts || {});\n  var Promise = opts.Promise || global.Promise;\n  var fs = opts.fs || nodeFs;\n  if (opts.isWindows == null) opts.isWindows = isWindows;\n  if (!opts.Promise) opts.Promise = Promise;\n  if (!opts.fs) opts.fs = fs;\n  if (!opts.recurseWith) opts.recurseWith = copyItem;\n  if (!opts.lstat) opts.lstat = promisify(opts.Promise, fs.lstat);\n  if (!opts.stat) opts.stat = promisify(opts.Promise, fs.stat);\n  if (!opts.chown) opts.chown = promisify(opts.Promise, fs.chown);\n  if (!opts.readdir) opts.readdir = promisify(opts.Promise, fs.readdir);\n  if (!opts.readlink) opts.readlink = promisify(opts.Promise, fs.readlink);\n  if (!opts.symlink) opts.symlink = promisify(opts.Promise, fs.symlink);\n  if (!opts.chmod) opts.chmod = promisify(opts.Promise, fs.chmod);\n  opts.top = from;\n  opts.mkdirpAsync = promisify(opts.Promise, mkdirp);\n  var rimrafAsync = promisify(opts.Promise, rimraf);\n  var queue = new RunQueue({\n    maxConcurrency: opts.maxConcurrency,\n    Promise: Promise\n  });\n  opts.queue = queue;\n  queue.add(0, copyItem, [from, to, opts]);\n  return queue.run().catch(function (err) {\n    // if the target already exists don't clobber it\n    if (err.code === 'EEXIST' || err.code === 'EPERM') {\n      return passThroughError();\n    } else {\n      return remove(to).then(passThroughError, passThroughError);\n    }\n\n    function passThroughError() {\n      return Promise.reject(err);\n    }\n  });\n\n  function remove(target) {\n    var opts = {\n      unlink: fs.unlink,\n      chmod: fs.chmod,\n      stat: fs.stat,\n      lstat: fs.lstat,\n      rmdir: fs.rmdir,\n      readdir: fs.readdir,\n      glob: false\n    };\n    return rimrafAsync(target, opts);\n  }\n}\n\nfunction copyItem(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var Promise = opts.Promise || global.Promise;\n  var lstat = opts.lstat || promisify(Promise, fs.lstat);\n  return lstat(to).then(function () {\n    return Promise.reject(eexists(from, to));\n  }, function (err) {\n    if (err && err.code !== 'ENOENT') return Promise.reject(err);\n    return lstat(from);\n  }).then(function (fromStat) {\n    var cmdOpts = extend(extend({}, opts), fromStat);\n\n    if (fromStat.isDirectory()) {\n      return recurseDir(from, to, cmdOpts);\n    } else if (fromStat.isSymbolicLink()) {\n      opts.queue.add(1, copySymlink, [from, to, cmdOpts]);\n    } else if (fromStat.isFile()) {\n      return copyFile(from, to, cmdOpts);\n    } else if (fromStat.isBlockDevice()) {\n      return Promise.reject(eunsupported(from + \" is a block device, and we don't know how to copy those.\"));\n    } else if (fromStat.isCharacterDevice()) {\n      return Promise.reject(eunsupported(from + \" is a character device, and we don't know how to copy those.\"));\n    } else if (fromStat.isFIFO()) {\n      return Promise.reject(eunsupported(from + \" is a FIFO, and we don't know how to copy those.\"));\n    } else if (fromStat.isSocket()) {\n      return Promise.reject(eunsupported(from + \" is a socket, and we don't know how to copy those.\"));\n    } else {\n      return Promise.reject(eunsupported(\"We can't tell what \" + from + \" is and so we can't copy it.\"));\n    }\n  });\n}\n\nfunction recurseDir(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var recurseWith = opts.recurseWith || copyItem;\n  var fs = opts.fs || nodeFs;\n  var chown = opts.chown || promisify(Promise, fs.chown);\n  var readdir = opts.readdir || promisify(Promise, fs.readdir);\n  var mkdirpAsync = opts.mkdirpAsync || promisify(Promise, mkdirp);\n  return mkdirpAsync(to, {\n    fs: fs,\n    mode: opts.mode\n  }).then(function () {\n    var getuid = opts.getuid || process.getuid;\n\n    if (getuid && opts.uid != null && getuid() === 0) {\n      return chown(to, opts.uid, opts.gid);\n    }\n  }).then(function () {\n    return readdir(from);\n  }).then(function (files) {\n    files.forEach(function (file) {\n      opts.queue.add(0, recurseWith, [path.join(from, file), path.join(to, file), opts]);\n    });\n  });\n}\n\nfunction copySymlink(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var readlink = opts.readlink || promisify(Promise, fs.readlink);\n  var stat = opts.stat || promisify(Promise, fs.symlink);\n  var symlink = opts.symlink || promisify(Promise, fs.symlink);\n  var Promise = opts.Promise || global.Promise;\n  return readlink(from).then(function (fromDest) {\n    var absoluteDest = path.resolve(path.dirname(from), fromDest); // Treat absolute paths that are inside the tree we're\n    // copying as relative. This necessary to properly support junctions\n    // on windows (which are always absolute) but is also DWIM with symlinks.\n\n    var relativeDest = path.relative(opts.top, absoluteDest);\n    var linkFrom = relativeDest.substr(0, 2) === '..' ? fromDest : path.relative(path.dirname(from), absoluteDest);\n\n    if (opts.isWindows) {\n      return stat(absoluteDest).catch(function () {\n        return null;\n      }).then(function (destStat) {\n        var isDir = destStat && destStat.isDirectory();\n        var type = isDir ? 'dir' : 'file';\n        return symlink(linkFrom, to, type).catch(function (err) {\n          if (type === 'dir') {\n            return symlink(linkFrom, to, 'junction');\n          } else {\n            return Promise.reject(err);\n          }\n        });\n      });\n    } else {\n      return symlink(linkFrom, to);\n    }\n  });\n}\n\nfunction copyFile(from, to, opts) {\n  validate('SSO', [from, to, opts]);\n  var fs = opts.fs || nodeFs;\n  var writeStreamAtomic = opts.writeStreamAtomic || stockWriteStreamAtomic;\n  var Promise = opts.Promise || global.Promise;\n  var chmod = opts.chmod || promisify(Promise, fs.chmod);\n  var writeOpts = {};\n  var getuid = opts.getuid || process.getuid;\n\n  if (getuid && opts.uid != null && getuid() === 0) {\n    writeOpts.chown = {\n      uid: opts.uid,\n      gid: opts.gid\n    };\n  }\n\n  return new Promise(function (resolve, reject) {\n    var errored = false;\n\n    function onError(err) {\n      errored = true;\n      reject(err);\n    }\n\n    fs.createReadStream(from).once('error', onError).pipe(writeStreamAtomic(to, writeOpts)).once('error', onError).once('close', function () {\n      if (errored) return;\n\n      if (opts.mode != null) {\n        resolve(chmod(to, opts.mode));\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction eexists(from, to) {\n  var err = new Error('Could not move ' + from + ' to ' + to + ': destination already exists.');\n  err.code = 'EEXIST';\n  return err;\n}\n\nfunction eunsupported(msg) {\n  var err = new Error(msg);\n  err.code = 'EUNSUPPORTED';\n  return err;\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/copy-concurrently/copy.js"],"names":["module","exports","copy","item","copyItem","recurse","recurseDir","symlink","copySymlink","file","copyFile","nodeFs","require","path","validate","stockWriteStreamAtomic","mkdirp","rimraf","isWindows","RunQueue","extend","Object","assign","_extend","promisify","Promise","fn","args","slice","call","arguments","resolve","reject","apply","concat","err","value","from","to","opts","global","fs","recurseWith","lstat","stat","chown","readdir","readlink","chmod","top","mkdirpAsync","rimrafAsync","queue","maxConcurrency","add","run","catch","code","passThroughError","remove","then","target","unlink","rmdir","glob","eexists","fromStat","cmdOpts","isDirectory","isSymbolicLink","isFile","isBlockDevice","eunsupported","isCharacterDevice","isFIFO","isSocket","mode","getuid","process","uid","gid","files","forEach","join","fromDest","absoluteDest","dirname","relativeDest","relative","linkFrom","substr","destStat","isDir","type","writeStreamAtomic","writeOpts","errored","onError","createReadStream","once","pipe","Error","msg"],"mappings":"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","sourcesContent":["'use strict'\nmodule.exports = copy\nmodule.exports.item = copyItem\nmodule.exports.recurse = recurseDir\nmodule.exports.symlink = copySymlink\nmodule.exports.file = copyFile\n\nvar nodeFs = require('fs')\nvar path = require('path')\nvar validate = require('aproba')\nvar stockWriteStreamAtomic = require('fs-write-stream-atomic')\nvar mkdirp = require('mkdirp')\nvar rimraf = require('rimraf')\nvar isWindows = require('./is-windows')\nvar RunQueue = require('run-queue')\nvar extend = Object.assign || require('util')._extend\n\nfunction promisify (Promise, fn) {\n  return function () {\n    var args = [].slice.call(arguments)\n    return new Promise(function (resolve, reject) {\n      return fn.apply(null, args.concat(function (err, value) {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(value)\n        }\n      }))\n    })\n  }\n}\n\nfunction copy (from, to, opts) {\n  validate('SSO|SS', arguments)\n  opts = extend({}, opts || {})\n\n  var Promise = opts.Promise || global.Promise\n  var fs = opts.fs || nodeFs\n\n  if (opts.isWindows == null) opts.isWindows = isWindows\n  if (!opts.Promise) opts.Promise = Promise\n  if (!opts.fs) opts.fs = fs\n  if (!opts.recurseWith) opts.recurseWith = copyItem\n  if (!opts.lstat) opts.lstat = promisify(opts.Promise, fs.lstat)\n  if (!opts.stat) opts.stat = promisify(opts.Promise, fs.stat)\n  if (!opts.chown) opts.chown = promisify(opts.Promise, fs.chown)\n  if (!opts.readdir) opts.readdir = promisify(opts.Promise, fs.readdir)\n  if (!opts.readlink) opts.readlink = promisify(opts.Promise, fs.readlink)\n  if (!opts.symlink) opts.symlink = promisify(opts.Promise, fs.symlink)\n  if (!opts.chmod) opts.chmod = promisify(opts.Promise, fs.chmod)\n\n  opts.top = from\n  opts.mkdirpAsync = promisify(opts.Promise, mkdirp)\n  var rimrafAsync = promisify(opts.Promise, rimraf)\n\n  var queue = new RunQueue({\n    maxConcurrency: opts.maxConcurrency,\n    Promise: Promise\n  })\n  opts.queue = queue\n\n  queue.add(0, copyItem, [from, to, opts])\n\n  return queue.run().catch(function (err) {\n    // if the target already exists don't clobber it\n    if (err.code === 'EEXIST' || err.code === 'EPERM') {\n      return passThroughError()\n    } else {\n      return remove(to).then(passThroughError, passThroughError)\n    }\n    function passThroughError () {\n      return Promise.reject(err)\n    }\n  })\n\n  function remove (target) {\n    var opts = {\n      unlink: fs.unlink,\n      chmod: fs.chmod,\n      stat: fs.stat,\n      lstat: fs.lstat,\n      rmdir: fs.rmdir,\n      readdir: fs.readdir,\n      glob: false\n    }\n    return rimrafAsync(target, opts)\n  }\n}\n\nfunction copyItem (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var fs = opts.fs || nodeFs\n  var Promise = opts.Promise || global.Promise\n  var lstat = opts.lstat || promisify(Promise, fs.lstat)\n\n  return lstat(to).then(function () {\n    return Promise.reject(eexists(from, to))\n  }, function (err) {\n    if (err && err.code !== 'ENOENT') return Promise.reject(err)\n    return lstat(from)\n  }).then(function (fromStat) {\n    var cmdOpts = extend(extend({}, opts), fromStat)\n    if (fromStat.isDirectory()) {\n      return recurseDir(from, to, cmdOpts)\n    } else if (fromStat.isSymbolicLink()) {\n      opts.queue.add(1, copySymlink, [from, to, cmdOpts])\n    } else if (fromStat.isFile()) {\n      return copyFile(from, to, cmdOpts)\n    } else if (fromStat.isBlockDevice()) {\n      return Promise.reject(eunsupported(from + \" is a block device, and we don't know how to copy those.\"))\n    } else if (fromStat.isCharacterDevice()) {\n      return Promise.reject(eunsupported(from + \" is a character device, and we don't know how to copy those.\"))\n    } else if (fromStat.isFIFO()) {\n      return Promise.reject(eunsupported(from + \" is a FIFO, and we don't know how to copy those.\"))\n    } else if (fromStat.isSocket()) {\n      return Promise.reject(eunsupported(from + \" is a socket, and we don't know how to copy those.\"))\n    } else {\n      return Promise.reject(eunsupported(\"We can't tell what \" + from + \" is and so we can't copy it.\"))\n    }\n  })\n}\n\nfunction recurseDir (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var recurseWith = opts.recurseWith || copyItem\n  var fs = opts.fs || nodeFs\n  var chown = opts.chown || promisify(Promise, fs.chown)\n  var readdir = opts.readdir || promisify(Promise, fs.readdir)\n  var mkdirpAsync = opts.mkdirpAsync || promisify(Promise, mkdirp)\n\n  return mkdirpAsync(to, {fs: fs, mode: opts.mode}).then(function () {\n    var getuid = opts.getuid || process.getuid\n    if (getuid && opts.uid != null && getuid() === 0) {\n      return chown(to, opts.uid, opts.gid)\n    }\n  }).then(function () {\n    return readdir(from)\n  }).then(function (files) {\n    files.forEach(function (file) {\n      opts.queue.add(0, recurseWith, [path.join(from, file), path.join(to, file), opts])\n    })\n  })\n}\n\nfunction copySymlink (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var fs = opts.fs || nodeFs\n  var readlink = opts.readlink || promisify(Promise, fs.readlink)\n  var stat = opts.stat || promisify(Promise, fs.symlink)\n  var symlink = opts.symlink || promisify(Promise, fs.symlink)\n  var Promise = opts.Promise || global.Promise\n\n  return readlink(from).then(function (fromDest) {\n    var absoluteDest = path.resolve(path.dirname(from), fromDest)\n    // Treat absolute paths that are inside the tree we're\n    // copying as relative. This necessary to properly support junctions\n    // on windows (which are always absolute) but is also DWIM with symlinks.\n    var relativeDest = path.relative(opts.top, absoluteDest)\n    var linkFrom = relativeDest.substr(0, 2) === '..' ? fromDest : path.relative(path.dirname(from), absoluteDest)\n    if (opts.isWindows) {\n      return stat(absoluteDest).catch(function () { return null }).then(function (destStat) {\n        var isDir = destStat && destStat.isDirectory()\n        var type = isDir ? 'dir' : 'file'\n        return symlink(linkFrom, to, type).catch(function (err) {\n          if (type === 'dir') {\n            return symlink(linkFrom, to, 'junction')\n          } else {\n            return Promise.reject(err)\n          }\n        })\n      })\n    } else {\n      return symlink(linkFrom, to)\n    }\n  })\n}\n\nfunction copyFile (from, to, opts) {\n  validate('SSO', [from, to, opts])\n  var fs = opts.fs || nodeFs\n  var writeStreamAtomic = opts.writeStreamAtomic || stockWriteStreamAtomic\n  var Promise = opts.Promise || global.Promise\n  var chmod = opts.chmod || promisify(Promise, fs.chmod)\n\n  var writeOpts = {}\n  var getuid = opts.getuid || process.getuid\n  if (getuid && opts.uid != null && getuid() === 0) {\n    writeOpts.chown = {\n      uid: opts.uid,\n      gid: opts.gid\n    }\n  }\n\n  return new Promise(function (resolve, reject) {\n    var errored = false\n    function onError (err) {\n      errored = true\n      reject(err)\n    }\n    fs.createReadStream(from)\n      .once('error', onError)\n      .pipe(writeStreamAtomic(to, writeOpts))\n      .once('error', onError)\n      .once('close', function () {\n        if (errored) return\n        if (opts.mode != null) {\n          resolve(chmod(to, opts.mode))\n        } else {\n          resolve()\n        }\n      })\n  })\n}\n\nfunction eexists (from, to) {\n  var err = new Error('Could not move ' + from + ' to ' + to + ': destination already exists.')\n  err.code = 'EEXIST'\n  return err\n}\n\nfunction eunsupported (msg) {\n  var err = new Error(msg)\n  err.code = 'EUNSUPPORTED'\n  return err\n}\n"]},"metadata":{},"sourceType":"script"}