{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\n\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\n\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\n\nconst addToSetMap = (map, key, value) => {\n  const set = map.get(key);\n\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\n\nclass LimitChunkCountPlugin {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  constructor(options) {\n    if (!options) options = {};\n    validateOptions(schema, options, \"Limit Chunk Count Plugin\");\n    this.options = options;\n  }\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n      compilation.hooks.optimizeChunksAdvanced.tap(\"LimitChunkCountPlugin\", chunks => {\n        const maxChunks = options.maxChunks;\n        if (!maxChunks) return;\n        if (maxChunks < 1) return;\n        if (chunks.length <= maxChunks) return;\n        let remainingChunksToMerge = chunks.length - maxChunks; // order chunks in a deterministic way\n\n        const orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b)); // create a lazy sorted data structure to keep all combinations\n        // this is large. Size = chunks * (chunks - 1) / 2\n        // It uses a multi layer bucket sort plus normal sort in the last layer\n        // It's also lazy so only accessed buckets are sorted\n\n        const combinations = new LazyBucketSortedSet( // Layer 1: ordered by largest size benefit\n        c => c.sizeDiff, (a, b) => b - a, // Layer 2: ordered by smallest combined size\n        c => c.integratedSize, (a, b) => a - b, // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n        c => c.bIdx - c.aIdx, (a, b) => a - b, // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n        (a, b) => a.bIdx - b.bIdx); // we keep a mappng from chunk to all combinations\n        // but this mapping is not kept up-to-date with deletions\n        // so `deleted` flag need to be considered when iterating this\n\n        /** @type {Map<Chunk, Set<ChunkCombination>>} */\n\n        const combinationsByChunk = new Map();\n        orderedChunks.forEach((b, bIdx) => {\n          // create combination pairs with size and integrated size\n          for (let aIdx = 0; aIdx < bIdx; aIdx++) {\n            const a = orderedChunks[aIdx];\n            const integratedSize = a.integratedSize(b, options); // filter pairs that do not have an integratedSize\n            // meaning they can NOT be integrated!\n\n            if (integratedSize === false) continue;\n            const aSize = a.size(options);\n            const bSize = b.size(options);\n            const c = {\n              deleted: false,\n              sizeDiff: aSize + bSize - integratedSize,\n              integratedSize,\n              a,\n              b,\n              aIdx,\n              bIdx,\n              aSize,\n              bSize\n            };\n            combinations.add(c);\n            addToSetMap(combinationsByChunk, a, c);\n            addToSetMap(combinationsByChunk, b, c);\n          }\n\n          return combinations;\n        }); // list of modified chunks during this run\n        // combinations affected by this change are skipped to allow\n        // futher optimizations\n\n        /** @type {Set<Chunk>} */\n\n        const modifiedChunks = new Set();\n        let changed = false; // eslint-disable-next-line no-constant-condition\n\n        loop: while (true) {\n          const combination = combinations.popFirst();\n          if (combination === undefined) break;\n          combination.deleted = true;\n          const {\n            a,\n            b,\n            integratedSize\n          } = combination; // skip over pair when\n          // one of the already merged chunks is a parent of one of the chunks\n\n          if (modifiedChunks.size > 0) {\n            const queue = new Set(a.groupsIterable);\n\n            for (const group of b.groupsIterable) {\n              queue.add(group);\n            }\n\n            for (const group of queue) {\n              for (const mChunk of modifiedChunks) {\n                if (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n                  // This is a potential pair which needs recalculation\n                  // We can't do that now, but it merge before following pairs\n                  // so we leave space for it, and consider chunks as modified\n                  // just for the worse case\n                  remainingChunksToMerge--;\n                  if (remainingChunksToMerge <= 0) break loop;\n                  modifiedChunks.add(a);\n                  modifiedChunks.add(b);\n                  continue loop;\n                }\n              }\n\n              for (const parent of group.parentsIterable) {\n                queue.add(parent);\n              }\n            }\n          } // merge the chunks\n\n\n          if (a.integrate(b, \"limit\")) {\n            chunks.splice(chunks.indexOf(b), 1); // flag chunk a as modified as further optimization are possible for all children here\n\n            modifiedChunks.add(a);\n            changed = true;\n            remainingChunksToMerge--;\n            if (remainingChunksToMerge <= 0) break; // Update all affected combinations\n            // delete all combination with the removed chunk\n            // we will use combinations with the kept chunk instead\n\n            for (const combination of combinationsByChunk.get(b)) {\n              if (combination.deleted) continue;\n              combination.deleted = true;\n              combinations.delete(combination);\n            } // Update combinations with the kept chunk with new sizes\n\n\n            for (const combination of combinationsByChunk.get(a)) {\n              if (combination.deleted) continue;\n\n              if (combination.a === a) {\n                // Update size\n                const newIntegratedSize = a.integratedSize(combination.b, options);\n\n                if (newIntegratedSize === false) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.integratedSize = newIntegratedSize;\n                combination.aSize = integratedSize;\n                combination.sizeDiff = combination.bSize + integratedSize - newIntegratedSize;\n                finishUpdate();\n              } else if (combination.b === a) {\n                // Update size\n                const newIntegratedSize = combination.a.integratedSize(a, options);\n\n                if (newIntegratedSize === false) {\n                  combination.deleted = true;\n                  combinations.delete(combination);\n                  continue;\n                }\n\n                const finishUpdate = combinations.startUpdate(combination);\n                combination.integratedSize = newIntegratedSize;\n                combination.bSize = integratedSize;\n                combination.sizeDiff = integratedSize + combination.aSize - newIntegratedSize;\n                finishUpdate();\n              }\n            }\n          }\n        }\n\n        if (changed) return true;\n      });\n    });\n  }\n\n}\n\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"names":["validateOptions","require","schema","LazyBucketSortedSet","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","constructor","options","apply","compiler","hooks","compilation","tap","optimizeChunksAdvanced","chunks","maxChunks","length","remainingChunksToMerge","orderedChunks","slice","sort","a","b","compareTo","combinations","c","sizeDiff","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","aSize","size","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parent","parentsIterable","integrate","splice","indexOf","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Limit Chunk Count Plugin\");\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"LimitChunkCountPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (chunks.length <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = chunks.length - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mappng from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\tconst integratedSize = a.integratedSize(b, options);\n\n\t\t\t\t\t\t\t// filter pairs that do not have an integratedSize\n\t\t\t\t\t\t\t// meaning they can NOT be integrated!\n\t\t\t\t\t\t\tif (integratedSize === false) continue;\n\n\t\t\t\t\t\t\tconst aSize = a.size(options);\n\t\t\t\t\t\t\tconst bSize = b.size(options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// futher optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (a.integrate(b, \"limit\")) {\n\t\t\t\t\t\t\tchunks.splice(chunks.indexOf(b), 1);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = a.integratedSize(\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = combination.a.integratedSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"]},"metadata":{},"sourceType":"script"}