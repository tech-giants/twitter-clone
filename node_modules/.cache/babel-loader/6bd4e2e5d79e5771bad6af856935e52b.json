{"ast":null,"code":"import { createPath } from \"./node-path\";\nimport { unionTypesMap, nodeAndUnionTypes } from \"./nodes\"; // recursively walks the AST starting at the given node. The callback is invoked for\n// and object that has a 'type' property.\n\nfunction walk(context, callback) {\n  var stop = false;\n\n  function innerWalk(context, callback) {\n    if (stop) {\n      return;\n    }\n\n    var node = context.node;\n\n    if (node === undefined) {\n      console.warn(\"traversing with an empty context\");\n      return;\n    }\n\n    if (node._deleted === true) {\n      return;\n    }\n\n    var path = createPath(context);\n    callback(node.type, path);\n\n    if (path.shouldStop) {\n      stop = true;\n      return;\n    }\n\n    Object.keys(node).forEach(function (prop) {\n      var value = node[prop];\n\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      var valueAsArray = Array.isArray(value) ? value : [value];\n      valueAsArray.forEach(function (childNode) {\n        if (typeof childNode.type === \"string\") {\n          var childContext = {\n            node: childNode,\n            parentKey: prop,\n            parentPath: path,\n            shouldStop: false,\n            inList: Array.isArray(value)\n          };\n          innerWalk(childContext, callback);\n        }\n      });\n    });\n  }\n\n  innerWalk(context, callback);\n}\n\nvar noop = function noop() {};\n\nexport function traverse(node, visitors) {\n  var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  var after = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n  Object.keys(visitors).forEach(function (visitor) {\n    if (!nodeAndUnionTypes.includes(visitor)) {\n      throw new Error(\"Unexpected visitor \".concat(visitor));\n    }\n  });\n  var context = {\n    node: node,\n    inList: false,\n    shouldStop: false,\n    parentPath: null,\n    parentKey: null\n  };\n  walk(context, function (type, path) {\n    if (typeof visitors[type] === \"function\") {\n      before(type, path);\n      visitors[type](path);\n      after(type, path);\n    }\n\n    var unionTypes = unionTypesMap[type];\n\n    if (!unionTypes) {\n      throw new Error(\"Unexpected node type \".concat(type));\n    }\n\n    unionTypes.forEach(function (unionType) {\n      if (typeof visitors[unionType] === \"function\") {\n        before(unionType, path);\n        visitors[unionType](path);\n        after(unionType, path);\n      }\n    });\n  });\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/ast/esm/traverse.js"],"names":["createPath","unionTypesMap","nodeAndUnionTypes","walk","context","callback","stop","innerWalk","node","undefined","console","warn","_deleted","path","type","shouldStop","Object","keys","forEach","prop","value","valueAsArray","Array","isArray","childNode","childContext","parentKey","parentPath","inList","noop","traverse","visitors","before","arguments","length","after","visitor","includes","Error","concat","unionTypes","unionType"],"mappings":"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","sourcesContent":["import { createPath } from \"./node-path\";\nimport { unionTypesMap, nodeAndUnionTypes } from \"./nodes\"; // recursively walks the AST starting at the given node. The callback is invoked for\n// and object that has a 'type' property.\n\nfunction walk(context, callback) {\n  var stop = false;\n\n  function innerWalk(context, callback) {\n    if (stop) {\n      return;\n    }\n\n    var node = context.node;\n\n    if (node === undefined) {\n      console.warn(\"traversing with an empty context\");\n      return;\n    }\n\n    if (node._deleted === true) {\n      return;\n    }\n\n    var path = createPath(context);\n    callback(node.type, path);\n\n    if (path.shouldStop) {\n      stop = true;\n      return;\n    }\n\n    Object.keys(node).forEach(function (prop) {\n      var value = node[prop];\n\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      var valueAsArray = Array.isArray(value) ? value : [value];\n      valueAsArray.forEach(function (childNode) {\n        if (typeof childNode.type === \"string\") {\n          var childContext = {\n            node: childNode,\n            parentKey: prop,\n            parentPath: path,\n            shouldStop: false,\n            inList: Array.isArray(value)\n          };\n          innerWalk(childContext, callback);\n        }\n      });\n    });\n  }\n\n  innerWalk(context, callback);\n}\n\nvar noop = function noop() {};\n\nexport function traverse(node, visitors) {\n  var before = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;\n  var after = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop;\n  Object.keys(visitors).forEach(function (visitor) {\n    if (!nodeAndUnionTypes.includes(visitor)) {\n      throw new Error(\"Unexpected visitor \".concat(visitor));\n    }\n  });\n  var context = {\n    node: node,\n    inList: false,\n    shouldStop: false,\n    parentPath: null,\n    parentKey: null\n  };\n  walk(context, function (type, path) {\n    if (typeof visitors[type] === \"function\") {\n      before(type, path);\n      visitors[type](path);\n      after(type, path);\n    }\n\n    var unionTypes = unionTypesMap[type];\n\n    if (!unionTypes) {\n      throw new Error(\"Unexpected node type \".concat(type));\n    }\n\n    unionTypes.forEach(function (unionType) {\n      if (typeof visitors[unionType] === \"function\") {\n        before(unionType, path);\n        visitors[unionType](path);\n        after(unionType, path);\n      }\n    });\n  });\n}"]},"metadata":{},"sourceType":"module"}