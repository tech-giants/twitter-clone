{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {false | true | string[]} UsedExports */\n\nconst addToSet = (a, b) => {\n  for (const item of b) {\n    if (!a.includes(item)) a.push(item);\n  }\n\n  return a;\n};\n\nconst isSubset = (biggerSet, subset) => {\n  if (biggerSet === true) return true;\n  if (subset === true) return false;\n  return subset.every(item => biggerSet.indexOf(item) >= 0);\n};\n\nclass FlagDependencyUsagePlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n      compilation.hooks.optimizeDependencies.tap(\"FlagDependencyUsagePlugin\", modules => {\n        const processModule = (module, usedExports) => {\n          module.used = true;\n          if (module.usedExports === true) return;\n\n          if (usedExports === true) {\n            module.usedExports = true;\n          } else if (Array.isArray(usedExports)) {\n            const old = module.usedExports ? module.usedExports.length : -1;\n            module.usedExports = addToSet(module.usedExports || [], usedExports);\n\n            if (module.usedExports.length === old) {\n              return;\n            }\n          } else if (Array.isArray(module.usedExports)) {\n            return;\n          } else {\n            module.usedExports = false;\n          } // for a module without side effects we stop tracking usage here when no export is used\n          // This module won't be evaluated in this case\n\n\n          if (module.factoryMeta.sideEffectFree) {\n            if (module.usedExports === false) return;\n            if (Array.isArray(module.usedExports) && module.usedExports.length === 0) return;\n          }\n\n          queue.push([module, module, module.usedExports]);\n        };\n\n        const processDependenciesBlock = (module, depBlock, usedExports) => {\n          for (const dep of depBlock.dependencies) {\n            processDependency(module, dep);\n          }\n\n          for (const variable of depBlock.variables) {\n            for (const dep of variable.dependencies) {\n              processDependency(module, dep);\n            }\n          }\n\n          for (const block of depBlock.blocks) {\n            queue.push([module, block, usedExports]);\n          }\n        };\n\n        const processDependency = (module, dep) => {\n          const reference = compilation.getDependencyReference(module, dep);\n          if (!reference) return;\n          const referenceModule = reference.module;\n          const importedNames = reference.importedNames;\n          const oldUsed = referenceModule.used;\n          const oldUsedExports = referenceModule.usedExports;\n\n          if (!oldUsed || importedNames && (!oldUsedExports || !isSubset(oldUsedExports, importedNames))) {\n            processModule(referenceModule, importedNames);\n          }\n        };\n\n        for (const module of modules) {\n          if (!module.used) module.used = false;\n        }\n        /** @type {[Module, DependenciesBlock, UsedExports][]} */\n\n\n        const queue = [];\n\n        for (const preparedEntrypoint of compilation._preparedEntrypoints) {\n          if (preparedEntrypoint.module) {\n            processModule(preparedEntrypoint.module, true);\n          }\n        }\n\n        while (queue.length) {\n          const queueItem = queue.pop();\n          processDependenciesBlock(queueItem[0], queueItem[1], queueItem[2]);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = FlagDependencyUsagePlugin;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/FlagDependencyUsagePlugin.js"],"names":["addToSet","a","b","item","includes","push","isSubset","biggerSet","subset","every","indexOf","FlagDependencyUsagePlugin","apply","compiler","hooks","compilation","tap","optimizeDependencies","modules","processModule","module","usedExports","used","Array","isArray","old","length","factoryMeta","sideEffectFree","queue","processDependenciesBlock","depBlock","dep","dependencies","processDependency","variable","variables","block","blocks","reference","getDependencyReference","referenceModule","importedNames","oldUsed","oldUsedExports","preparedEntrypoint","_preparedEntrypoints","queueItem","pop","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {false | true | string[]} UsedExports */\n\nconst addToSet = (a, b) => {\n\tfor (const item of b) {\n\t\tif (!a.includes(item)) a.push(item);\n\t}\n\treturn a;\n};\n\nconst isSubset = (biggerSet, subset) => {\n\tif (biggerSet === true) return true;\n\tif (subset === true) return false;\n\treturn subset.every(item => biggerSet.indexOf(item) >= 0);\n};\n\nclass FlagDependencyUsagePlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"FlagDependencyUsagePlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\"FlagDependencyUsagePlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\tconst processModule = (module, usedExports) => {\n\t\t\t\t\t\tmodule.used = true;\n\t\t\t\t\t\tif (module.usedExports === true) return;\n\t\t\t\t\t\tif (usedExports === true) {\n\t\t\t\t\t\t\tmodule.usedExports = true;\n\t\t\t\t\t\t} else if (Array.isArray(usedExports)) {\n\t\t\t\t\t\t\tconst old = module.usedExports ? module.usedExports.length : -1;\n\t\t\t\t\t\t\tmodule.usedExports = addToSet(\n\t\t\t\t\t\t\t\tmodule.usedExports || [],\n\t\t\t\t\t\t\t\tusedExports\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (module.usedExports.length === old) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (Array.isArray(module.usedExports)) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmodule.usedExports = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for a module without side effects we stop tracking usage here when no export is used\n\t\t\t\t\t\t// This module won't be evaluated in this case\n\t\t\t\t\t\tif (module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\tif (module.usedExports === false) return;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tArray.isArray(module.usedExports) &&\n\t\t\t\t\t\t\t\tmodule.usedExports.length === 0\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tqueue.push([module, module, module.usedExports]);\n\t\t\t\t\t};\n\n\t\t\t\t\tconst processDependenciesBlock = (module, depBlock, usedExports) => {\n\t\t\t\t\t\tfor (const dep of depBlock.dependencies) {\n\t\t\t\t\t\t\tprocessDependency(module, dep);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const variable of depBlock.variables) {\n\t\t\t\t\t\t\tfor (const dep of variable.dependencies) {\n\t\t\t\t\t\t\t\tprocessDependency(module, dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const block of depBlock.blocks) {\n\t\t\t\t\t\t\tqueue.push([module, block, usedExports]);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tconst processDependency = (module, dep) => {\n\t\t\t\t\t\tconst reference = compilation.getDependencyReference(module, dep);\n\t\t\t\t\t\tif (!reference) return;\n\t\t\t\t\t\tconst referenceModule = reference.module;\n\t\t\t\t\t\tconst importedNames = reference.importedNames;\n\t\t\t\t\t\tconst oldUsed = referenceModule.used;\n\t\t\t\t\t\tconst oldUsedExports = referenceModule.usedExports;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!oldUsed ||\n\t\t\t\t\t\t\t(importedNames &&\n\t\t\t\t\t\t\t\t(!oldUsedExports || !isSubset(oldUsedExports, importedNames)))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tprocessModule(referenceModule, importedNames);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tif (!module.used) module.used = false;\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {[Module, DependenciesBlock, UsedExports][]} */\n\t\t\t\t\tconst queue = [];\n\t\t\t\t\tfor (const preparedEntrypoint of compilation._preparedEntrypoints) {\n\t\t\t\t\t\tif (preparedEntrypoint.module) {\n\t\t\t\t\t\t\tprocessModule(preparedEntrypoint.module, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (queue.length) {\n\t\t\t\t\t\tconst queueItem = queue.pop();\n\t\t\t\t\t\tprocessDependenciesBlock(queueItem[0], queueItem[1], queueItem[2]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = FlagDependencyUsagePlugin;\n"]},"metadata":{},"sourceType":"script"}