{"ast":null,"code":"\"use strict\"; // Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\n\nconst similarity = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let dist = 0;\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charCodeAt(i);\n    const cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n\n  return dist;\n};\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\n\n\nconst getName = (a, b) => {\n  const l = Math.min(a.length, b.length);\n  let r = \"\";\n\n  for (let i = 0; i < l; i++) {\n    const ca = a.charAt(i);\n    const cb = b.charAt(i);\n    r += ca;\n\n    if (ca === cb) {\n      continue;\n    }\n\n    return r;\n  }\n\n  return a;\n};\n/**\n * @template T\n */\n\n\nclass Node {\n  /**\n   * @param {T} item item\n   * @param {string} key key\n   * @param {number} size size\n   */\n  constructor(item, key, size) {\n    this.item = item;\n    this.key = key;\n    this.size = size;\n  }\n\n}\n/**\n * @template T\n */\n\n\nclass Group {\n  /**\n   * @param {Node<T>[]} nodes nodes\n   * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n   */\n  constructor(nodes, similarities) {\n    this.nodes = nodes;\n    this.similarities = similarities;\n    this.size = nodes.reduce((size, node) => size + node.size, 0);\n    /** @type {string} */\n\n    this.key = undefined;\n  }\n\n}\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\n\n\nmodule.exports = ({\n  maxSize,\n  minSize,\n  items,\n  getSize,\n  getKey\n}) => {\n  /** @type {Group<T>[]} */\n  const result = [];\n  const nodes = Array.from(items, item => new Node(item, getKey(item), getSize(item)));\n  /** @type {Node<T>[]} */\n\n  const initialNodes = []; // lexically ordering of keys\n\n  nodes.sort((a, b) => {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  }); // return nodes bigger than maxSize directly as group\n\n  for (const node of nodes) {\n    if (node.size >= maxSize) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n\n  if (initialNodes.length > 0) {\n    // calculate similarities between lexically adjacent nodes\n\n    /** @type {number[]} */\n    const similarities = [];\n\n    for (let i = 1; i < initialNodes.length; i++) {\n      const a = initialNodes[i - 1];\n      const b = initialNodes[i];\n      similarities.push(similarity(a.key, b.key));\n    }\n\n    const initialGroup = new Group(initialNodes, similarities);\n\n    if (initialGroup.size < minSize) {\n      // We hit an edgecase where the working set is already smaller than minSize\n      // We merge it with the smallest result node to keep minSize intact\n      if (result.length > 0) {\n        const smallestGroup = result.reduce((min, group) => min.size > group.size ? group : min);\n\n        for (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\n        smallestGroup.nodes.sort((a, b) => {\n          if (a.key < b.key) return -1;\n          if (a.key > b.key) return 1;\n          return 0;\n        });\n      } else {\n        // There are no other nodes\n        // We use all nodes and have to accept that it's smaller than minSize\n        result.push(initialGroup);\n      }\n    } else {\n      const queue = [initialGroup];\n\n      while (queue.length) {\n        const group = queue.pop(); // only groups bigger than maxSize need to be splitted\n\n        if (group.size < maxSize) {\n          result.push(group);\n          continue;\n        } // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n\n\n        let left = 0;\n        let leftSize = 0;\n\n        while (leftSize <= minSize) {\n          leftSize += group.nodes[left].size;\n          left++;\n        }\n\n        let right = group.nodes.length - 1;\n        let rightSize = 0;\n\n        while (rightSize <= minSize) {\n          rightSize += group.nodes[right].size;\n          right--;\n        }\n\n        if (left - 1 > right) {\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the group here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          let best = left - 1;\n          let bestSimilarity = group.similarities[best];\n\n          for (let i = left; i <= right; i++) {\n            const similarity = group.similarities[i];\n\n            if (similarity < bestSimilarity) {\n              best = i;\n              bestSimilarity = similarity;\n            }\n          }\n\n          left = best + 1;\n          right = best;\n        } // create two new groups for left and right area\n        // and queue them up\n\n\n        const rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n\n        const rightSimilaries = [];\n\n        for (let i = right + 2; i < group.nodes.length; i++) {\n          rightSimilaries.push(group.similarities[i - 1]);\n          rightNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(rightNodes, rightSimilaries));\n        const leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n\n        const leftSimilaries = [];\n\n        for (let i = 1; i < left; i++) {\n          leftSimilaries.push(group.similarities[i - 1]);\n          leftNodes.push(group.nodes[i]);\n        }\n\n        queue.push(new Group(leftNodes, leftSimilaries));\n      }\n    }\n  } // lexically ordering\n\n\n  result.sort((a, b) => {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  }); // give every group a name\n\n  for (let i = 0; i < result.length; i++) {\n    const group = result[i];\n    const first = group.nodes[0];\n    const last = group.nodes[group.nodes.length - 1];\n    let name = getName(first.key, last.key);\n    group.key = name;\n  } // return the results\n\n\n  return result.map(group => {\n    /** @type {GroupedItems} */\n    return {\n      key: group.key,\n      items: group.nodes.map(node => node.item),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/webpack/lib/util/deterministicGrouping.js"],"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","r","charAt","Node","constructor","item","key","size","Group","nodes","similarities","reduce","node","undefined","module","exports","maxSize","minSize","items","getSize","getKey","result","Array","from","initialNodes","sort","push","initialGroup","smallestGroup","group","queue","pop","left","leftSize","right","rightSize","best","bestSimilarity","rightNodes","rightSimilaries","leftNodes","leftSimilaries","first","last","name","map"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet r = \"\";\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charAt(i);\n\t\tconst cb = b.charAt(i);\n\t\tr += ca;\n\t\tif (ca === cb) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r;\n\t}\n\treturn a;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {number} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t */\n\tconstructor(nodes, similarities) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = nodes.reduce((size, node) => size + node.size, 0);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\tfor (const node of nodes) {\n\t\tif (node.size >= maxSize) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\t// calculate similarities between lexically adjacent nodes\n\t\t/** @type {number[]} */\n\t\tconst similarities = [];\n\t\tfor (let i = 1; i < initialNodes.length; i++) {\n\t\t\tconst a = initialNodes[i - 1];\n\t\t\tconst b = initialNodes[i];\n\t\t\tsimilarities.push(similarity(a.key, b.key));\n\t\t}\n\n\t\tconst initialGroup = new Group(initialNodes, similarities);\n\n\t\tif (initialGroup.size < minSize) {\n\t\t\t// We hit an edgecase where the working set is already smaller than minSize\n\t\t\t// We merge it with the smallest result node to keep minSize intact\n\t\t\tif (result.length > 0) {\n\t\t\t\tconst smallestGroup = result.reduce((min, group) =>\n\t\t\t\t\tmin.size > group.size ? group : min\n\t\t\t\t);\n\t\t\t\tfor (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\t\t\t\tsmallestGroup.nodes.sort((a, b) => {\n\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// There are no other nodes\n\t\t\t\t// We use all nodes and have to accept that it's smaller than minSize\n\t\t\t\tresult.push(initialGroup);\n\t\t\t}\n\t\t} else {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (group.size < maxSize) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 0;\n\t\t\t\tlet leftSize = 0;\n\t\t\t\twhile (leftSize <= minSize) {\n\t\t\t\t\tleftSize += group.nodes[left].size;\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 1;\n\t\t\t\tlet rightSize = 0;\n\t\t\t\twhile (rightSize <= minSize) {\n\t\t\t\t\trightSize += group.nodes[right].size;\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the group here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\tlet best = left - 1;\n\t\t\t\t\tlet bestSimilarity = group.similarities[best];\n\t\t\t\t\tfor (let i = left; i <= right; i++) {\n\t\t\t\t\t\tconst similarity = group.similarities[i];\n\t\t\t\t\t\tif (similarity < bestSimilarity) {\n\t\t\t\t\t\t\tbest = i;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft = best + 1;\n\t\t\t\t\tright = best;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilaries = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilaries));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilaries = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilaries));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tconst first = group.nodes[0];\n\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\tlet name = getName(first.key, last.key);\n\t\tgroup.key = name;\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}