{"ast":null,"code":"'use strict';\n\nvar utils = module.exports;\n\nvar path = require('path');\n/**\n * Module dependencies\n */\n\n\nvar isWindows = require('is-windows')();\n\nvar Snapdragon = require('snapdragon');\n\nutils.define = require('define-property');\nutils.diff = require('arr-diff');\nutils.extend = require('extend-shallow');\nutils.pick = require('object.pick');\nutils.typeOf = require('kind-of');\nutils.unique = require('array-unique');\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nutils.isEmptyString = function (val) {\n  return String(val) === '' || String(val) === './';\n};\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\n\nutils.isWindows = function () {\n  return path.sep === '\\\\' || isWindows === true;\n};\n/**\n * Return the last element from an array\n */\n\n\nutils.last = function (arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n/**\n * Get the `Snapdragon` instance to use\n */\n\n\nutils.instantiate = function (ast, options) {\n  var snapdragon; // if an instance was created by `.parse`, use that instance\n\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\n    snapdragon = ast.snapdragon; // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\n    snapdragon = options.snapdragon; // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, 'parse', function (str, options) {\n    var parsed = Snapdragon.prototype.parse.call(this, str, options);\n    parsed.input = str; // escape unmatched brace/bracket/parens\n\n    var last = this.parser.stack.pop();\n\n    if (last && this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n\n      if (last.type === 'bracket') {\n        if (inner.val.charAt(0) === '[') {\n          inner.val = '\\\\' + inner.val;\n        }\n      } else {\n        open.val = '\\\\' + open.val;\n        var sibling = open.parent.nodes[1];\n\n        if (sibling.type === 'star') {\n          sibling.loose = true;\n        }\n      }\n    } // add non-enumerable parser reference\n\n\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n  return snapdragon;\n};\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\n\nutils.createKey = function (pattern, options) {\n  if (typeof options === 'undefined') {\n    return pattern;\n  }\n\n  var key = pattern;\n\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n\n  return key;\n};\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\n\nutils.arrayify = function (val) {\n  if (typeof val === 'string') return [val];\n  return val ? Array.isArray(val) ? val : [val] : [];\n};\n/**\n * Return true if `val` is a non-empty string\n */\n\n\nutils.isString = function (val) {\n  return typeof val === 'string';\n};\n/**\n * Return true if `val` is a non-empty string\n */\n\n\nutils.isRegex = function (val) {\n  return utils.typeOf(val) === 'regexp';\n};\n/**\n * Return true if `val` is a non-empty string\n */\n\n\nutils.isObject = function (val) {\n  return utils.typeOf(val) === 'object';\n};\n/**\n * Escape regex characters in the given string\n */\n\n\nutils.escapeRegex = function (str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\/\\s]/g, '\\\\$&');\n};\n/**\n * Combines duplicate characters in the provided `input` string.\n * @param {String} `input`\n * @returns {String}\n */\n\n\nutils.combineDupes = function (input, patterns) {\n  patterns = utils.arrayify(patterns).join('|').split('|');\n  patterns = patterns.map(function (s) {\n    return s.replace(/\\\\?([+*\\\\/])/g, '\\\\$1');\n  });\n  var substr = patterns.join('|');\n  var regex = new RegExp('(' + substr + ')(?=\\\\1)', 'g');\n  return input.replace(regex, '');\n};\n/**\n * Returns true if the given `str` has special characters\n */\n\n\nutils.hasSpecialChars = function (str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|[\\]{}]|[+@]\\()/.test(str);\n};\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\n\nutils.toPosixPath = function (str) {\n  return str.replace(/\\\\+/g, '/');\n};\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\n\nutils.unescape = function (str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\n};\n/**\n * Strip the drive letter from a windows filepath\n * @param {String} `fp`\n * @return {String}\n */\n\n\nutils.stripDrive = function (fp) {\n  return utils.isWindows() ? fp.replace(/^[a-z]:[\\\\/]+?/i, '/') : fp;\n};\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\n\nutils.stripPrefix = function (str) {\n  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\\\')) {\n    return str.slice(2);\n  }\n\n  return str;\n};\n/**\n * Returns true if `str` is a common character that doesn't need\n * to be processed to be used for matching.\n * @param {String} `str`\n * @return {Boolean}\n */\n\n\nutils.isSimpleChar = function (str) {\n  return str.trim() === '' || str === '.';\n};\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\n\nutils.isSlash = function (str) {\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\n};\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.matchPath = function (pattern, options) {\n  return options && options.contains ? utils.containsPattern(pattern, options) : utils.equalsPattern(pattern, options);\n};\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\n\nutils._equals = function (filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\n\nutils._contains = function (filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.equalsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\n\nutils.containsPattern = function (pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n  return function (filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\n\nutils.matchBasename = function (re) {\n  return function (filepath) {\n    return re.test(filepath) || re.test(path.basename(filepath));\n  };\n};\n/**\n * Returns the given value unchanced.\n * @return {any}\n */\n\n\nutils.identity = function (val) {\n  return val;\n};\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\n\nutils.value = function (str, unixify, options) {\n  if (options && options.unixify === false) {\n    return str;\n  }\n\n  if (options && typeof options.unixify === 'function') {\n    return options.unixify(str);\n  }\n\n  return unixify(str);\n};\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\n\nutils.unixify = function (options) {\n  var opts = options || {};\n  return function (filepath) {\n    if (opts.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n\n    if (opts.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n\n    if (opts.unixify === true || utils.isWindows()) {\n      filepath = utils.toPosixPath(filepath);\n    }\n\n    return filepath;\n  };\n};","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/nanomatch/lib/utils.js"],"names":["utils","module","exports","path","require","isWindows","Snapdragon","define","diff","extend","pick","typeOf","unique","isEmptyString","val","String","sep","last","arr","n","length","instantiate","ast","options","snapdragon","str","parsed","prototype","parse","call","input","parser","stack","pop","strictErrors","open","nodes","inner","type","charAt","sibling","parent","loose","createKey","pattern","key","prop","hasOwnProperty","arrayify","Array","isArray","isString","isRegex","isObject","escapeRegex","replace","combineDupes","patterns","join","split","map","s","substr","regex","RegExp","hasSpecialChars","test","toPosixPath","unescape","stripDrive","fp","stripPrefix","slice","isSimpleChar","trim","isSlash","matchPath","contains","containsPattern","equalsPattern","_equals","filepath","unixPath","_contains","indexOf","unixify","fn","equal","nocase","lower","toLowerCase","matchBasename","re","basename","identity","value","opts"],"mappings":"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","sourcesContent":["'use strict';\n\nvar utils = module.exports;\nvar path = require('path');\n\n/**\n * Module dependencies\n */\n\nvar isWindows = require('is-windows')();\nvar Snapdragon = require('snapdragon');\nutils.define = require('define-property');\nutils.diff = require('arr-diff');\nutils.extend = require('extend-shallow');\nutils.pick = require('object.pick');\nutils.typeOf = require('kind-of');\nutils.unique = require('array-unique');\n\n/**\n * Returns true if the given value is effectively an empty string\n */\n\nutils.isEmptyString = function(val) {\n  return String(val) === '' || String(val) === './';\n};\n\n/**\n * Returns true if the platform is windows, or `path.sep` is `\\\\`.\n * This is defined as a function to allow `path.sep` to be set in unit tests,\n * or by the user, if there is a reason to do so.\n * @return {Boolean}\n */\n\nutils.isWindows = function() {\n  return path.sep === '\\\\' || isWindows === true;\n};\n\n/**\n * Return the last element from an array\n */\n\nutils.last = function(arr, n) {\n  return arr[arr.length - (n || 1)];\n};\n\n/**\n * Get the `Snapdragon` instance to use\n */\n\nutils.instantiate = function(ast, options) {\n  var snapdragon;\n  // if an instance was created by `.parse`, use that instance\n  if (utils.typeOf(ast) === 'object' && ast.snapdragon) {\n    snapdragon = ast.snapdragon;\n  // if the user supplies an instance on options, use that instance\n  } else if (utils.typeOf(options) === 'object' && options.snapdragon) {\n    snapdragon = options.snapdragon;\n  // create a new instance\n  } else {\n    snapdragon = new Snapdragon(options);\n  }\n\n  utils.define(snapdragon, 'parse', function(str, options) {\n    var parsed = Snapdragon.prototype.parse.call(this, str, options);\n    parsed.input = str;\n\n    // escape unmatched brace/bracket/parens\n    var last = this.parser.stack.pop();\n    if (last && this.options.strictErrors !== true) {\n      var open = last.nodes[0];\n      var inner = last.nodes[1];\n      if (last.type === 'bracket') {\n        if (inner.val.charAt(0) === '[') {\n          inner.val = '\\\\' + inner.val;\n        }\n\n      } else {\n        open.val = '\\\\' + open.val;\n        var sibling = open.parent.nodes[1];\n        if (sibling.type === 'star') {\n          sibling.loose = true;\n        }\n      }\n    }\n\n    // add non-enumerable parser reference\n    utils.define(parsed, 'parser', this.parser);\n    return parsed;\n  });\n\n  return snapdragon;\n};\n\n/**\n * Create the key to use for memoization. The key is generated\n * by iterating over the options and concatenating key-value pairs\n * to the pattern string.\n */\n\nutils.createKey = function(pattern, options) {\n  if (typeof options === 'undefined') {\n    return pattern;\n  }\n  var key = pattern;\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      key += ';' + prop + '=' + String(options[prop]);\n    }\n  }\n  return key;\n};\n\n/**\n * Cast `val` to an array\n * @return {Array}\n */\n\nutils.arrayify = function(val) {\n  if (typeof val === 'string') return [val];\n  return val ? (Array.isArray(val) ? val : [val]) : [];\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isString = function(val) {\n  return typeof val === 'string';\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isRegex = function(val) {\n  return utils.typeOf(val) === 'regexp';\n};\n\n/**\n * Return true if `val` is a non-empty string\n */\n\nutils.isObject = function(val) {\n  return utils.typeOf(val) === 'object';\n};\n\n/**\n * Escape regex characters in the given string\n */\n\nutils.escapeRegex = function(str) {\n  return str.replace(/[-[\\]{}()^$|*+?.\\\\/\\s]/g, '\\\\$&');\n};\n\n/**\n * Combines duplicate characters in the provided `input` string.\n * @param {String} `input`\n * @returns {String}\n */\n\nutils.combineDupes = function(input, patterns) {\n  patterns = utils.arrayify(patterns).join('|').split('|');\n  patterns = patterns.map(function(s) {\n    return s.replace(/\\\\?([+*\\\\/])/g, '\\\\$1');\n  });\n  var substr = patterns.join('|');\n  var regex = new RegExp('(' + substr + ')(?=\\\\1)', 'g');\n  return input.replace(regex, '');\n};\n\n/**\n * Returns true if the given `str` has special characters\n */\n\nutils.hasSpecialChars = function(str) {\n  return /(?:(?:(^|\\/)[!.])|[*?+()|[\\]{}]|[+@]\\()/.test(str);\n};\n\n/**\n * Normalize slashes in the given filepath.\n *\n * @param {String} `filepath`\n * @return {String}\n */\n\nutils.toPosixPath = function(str) {\n  return str.replace(/\\\\+/g, '/');\n};\n\n/**\n * Strip backslashes before special characters in a string.\n *\n * @param {String} `str`\n * @return {String}\n */\n\nutils.unescape = function(str) {\n  return utils.toPosixPath(str.replace(/\\\\(?=[*+?!.])/g, ''));\n};\n\n/**\n * Strip the drive letter from a windows filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripDrive = function(fp) {\n  return utils.isWindows() ? fp.replace(/^[a-z]:[\\\\/]+?/i, '/') : fp;\n};\n\n/**\n * Strip the prefix from a filepath\n * @param {String} `fp`\n * @return {String}\n */\n\nutils.stripPrefix = function(str) {\n  if (str.charAt(0) === '.' && (str.charAt(1) === '/' || str.charAt(1) === '\\\\')) {\n    return str.slice(2);\n  }\n  return str;\n};\n\n/**\n * Returns true if `str` is a common character that doesn't need\n * to be processed to be used for matching.\n * @param {String} `str`\n * @return {Boolean}\n */\n\nutils.isSimpleChar = function(str) {\n  return str.trim() === '' || str === '.';\n};\n\n/**\n * Returns true if the given str is an escaped or\n * unescaped path character\n */\n\nutils.isSlash = function(str) {\n  return str === '/' || str === '\\\\/' || str === '\\\\' || str === '\\\\\\\\';\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern matches or contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.matchPath = function(pattern, options) {\n  return (options && options.contains)\n    ? utils.containsPattern(pattern, options)\n    : utils.equalsPattern(pattern, options);\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path are equal\n * to the given pattern.\n */\n\nutils._equals = function(filepath, unixPath, pattern) {\n  return pattern === filepath || pattern === unixPath;\n};\n\n/**\n * Returns true if the given (original) filepath or unixified path contain\n * the given pattern.\n */\n\nutils._contains = function(filepath, unixPath, pattern) {\n  return filepath.indexOf(pattern) !== -1 || unixPath.indexOf(pattern) !== -1;\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern is the same as a given `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.equalsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function fn(filepath) {\n    var equal = utils._equals(filepath, unixify(filepath), pattern);\n    if (equal === true || options.nocase !== true) {\n      return equal;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._equals(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * pattern contains a `filepath`\n *\n * @param {String} `pattern`\n * @return {Function}\n */\n\nutils.containsPattern = function(pattern, options) {\n  var unixify = utils.unixify(options);\n  options = options || {};\n\n  return function(filepath) {\n    var contains = utils._contains(filepath, unixify(filepath), pattern);\n    if (contains === true || options.nocase !== true) {\n      return contains;\n    }\n    var lower = filepath.toLowerCase();\n    return utils._contains(lower, unixify(lower), pattern);\n  };\n};\n\n/**\n * Returns a function that returns true if the given\n * regex matches the `filename` of a file path.\n *\n * @param {RegExp} `re` Matching regex\n * @return {Function}\n */\n\nutils.matchBasename = function(re) {\n  return function(filepath) {\n    return re.test(filepath) || re.test(path.basename(filepath));\n  };\n};\n\n/**\n * Returns the given value unchanced.\n * @return {any}\n */\n\nutils.identity = function(val) {\n  return val;\n};\n\n/**\n * Determines the filepath to return based on the provided options.\n * @return {any}\n */\n\nutils.value = function(str, unixify, options) {\n  if (options && options.unixify === false) {\n    return str;\n  }\n  if (options && typeof options.unixify === 'function') {\n    return options.unixify(str);\n  }\n  return unixify(str);\n};\n\n/**\n * Returns a function that normalizes slashes in a string to forward\n * slashes, strips `./` from beginning of paths, and optionally unescapes\n * special characters.\n * @return {Function}\n */\n\nutils.unixify = function(options) {\n  var opts = options || {};\n  return function(filepath) {\n    if (opts.stripPrefix !== false) {\n      filepath = utils.stripPrefix(filepath);\n    }\n    if (opts.unescape === true) {\n      filepath = utils.unescape(filepath);\n    }\n    if (opts.unixify === true || utils.isWindows()) {\n      filepath = utils.toPosixPath(filepath);\n    }\n    return filepath;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}