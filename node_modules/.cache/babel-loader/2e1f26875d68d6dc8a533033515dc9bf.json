{"ast":null,"code":"'use strict';\n\nvar regexNot = require('regex-not');\n\nvar toRegex = require('to-regex');\n/**\n * Characters to use in negation regex (we want to \"not\" match\n * characters that are matched by other parsers)\n */\n\n\nvar cached;\nvar NOT_REGEX = '[\\\\[!*+?$^\"\\'.\\\\\\\\/]+';\nvar not = createTextRegex(NOT_REGEX);\n/**\n * Nanomatch parsers\n */\n\nmodule.exports = function (nanomatch, options) {\n  var parser = nanomatch.parser;\n  var opts = parser.options;\n  parser.state = {\n    slashes: 0,\n    paths: []\n  };\n  parser.ast.state = parser.state;\n  parser\n  /**\n   * Beginning-of-string\n   */\n  .capture('prefix', function () {\n    if (this.parsed) return;\n    var m = this.match(/^\\.[\\\\/]/);\n    if (!m) return;\n    this.state.strictOpen = !!this.options.strictOpen;\n    this.state.addPrefix = true;\n  })\n  /**\n   * Escape: \"\\\\.\"\n   */\n  .capture('escape', function () {\n    if (this.isInside('bracket')) return;\n    var pos = this.position();\n    var m = this.match(/^(?:\\\\(.)|([$^]))/);\n    if (!m) return;\n    return pos({\n      type: 'escape',\n      val: m[2] || m[1]\n    });\n  })\n  /**\n   * Quoted strings\n   */\n  .capture('quoted', function () {\n    var pos = this.position();\n    var m = this.match(/^[\"']/);\n    if (!m) return;\n    var quote = m[0];\n\n    if (this.input.indexOf(quote) === -1) {\n      return pos({\n        type: 'escape',\n        val: quote\n      });\n    }\n\n    var tok = advanceTo(this.input, quote);\n    this.consume(tok.len);\n    return pos({\n      type: 'quoted',\n      val: tok.esc\n    });\n  })\n  /**\n   * Negations: \"!\"\n   */\n  .capture('not', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(this.notRegex || /^!+/);\n    if (!m) return;\n    var val = m[0];\n    var isNegated = val.length % 2 === 1;\n\n    if (parsed === '' && !isNegated) {\n      val = '';\n    } // if nothing has been parsed, we know `!` is at the start,\n    // so we need to wrap the result in a negation regex\n\n\n    if (parsed === '' && isNegated && this.options.nonegate !== true) {\n      this.bos.val = '(?!^(?:';\n      this.append = ')$).*';\n      val = '';\n    }\n\n    return pos({\n      type: 'not',\n      val: val\n    });\n  })\n  /**\n   * Dot: \".\"\n   */\n  .capture('dot', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(/^\\.+/);\n    if (!m) return;\n    var val = m[0];\n    this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');\n    return pos({\n      type: 'dot',\n      dotfiles: this.state.dot,\n      val: val\n    });\n  })\n  /**\n   * Plus: \"+\"\n   */\n  .capture('plus', /^\\+(?!\\()/)\n  /**\n   * Question mark: \"?\"\n   */\n  .capture('qmark', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(/^\\?+(?!\\()/);\n    if (!m) return;\n    this.state.metachar = true;\n    this.state.qmark = true;\n    return pos({\n      type: 'qmark',\n      parsed: parsed,\n      val: m[0]\n    });\n  })\n  /**\n   * Globstar: \"**\"\n   */\n  .capture('globstar', function () {\n    var parsed = this.parsed;\n    var pos = this.position();\n    var m = this.match(/^\\*{2}(?![*(])(?=[,)/]|$)/);\n    if (!m) return;\n    var type = opts.noglobstar !== true ? 'globstar' : 'star';\n    var node = pos({\n      type: type,\n      parsed: parsed\n    });\n    this.state.metachar = true;\n\n    while (this.input.slice(0, 4) === '/**/') {\n      this.input = this.input.slice(3);\n    }\n\n    node.isInside = {\n      brace: this.isInside('brace'),\n      paren: this.isInside('paren')\n    };\n\n    if (type === 'globstar') {\n      this.state.globstar = true;\n      node.val = '**';\n    } else {\n      this.state.star = true;\n      node.val = '*';\n    }\n\n    return node;\n  })\n  /**\n   * Star: \"*\"\n   */\n  .capture('star', function () {\n    var pos = this.position();\n    var starRe = /^(?:\\*(?![*(])|[*]{3,}(?!\\()|[*]{2}(?![(/]|$)|\\*(?=\\*\\())/;\n    var m = this.match(starRe);\n    if (!m) return;\n    this.state.metachar = true;\n    this.state.star = true;\n    return pos({\n      type: 'star',\n      val: m[0]\n    });\n  })\n  /**\n   * Slash: \"/\"\n   */\n  .capture('slash', function () {\n    var pos = this.position();\n    var m = this.match(/^\\//);\n    if (!m) return;\n    this.state.slashes++;\n    return pos({\n      type: 'slash',\n      val: m[0]\n    });\n  })\n  /**\n   * Backslash: \"\\\\\"\n   */\n  .capture('backslash', function () {\n    var pos = this.position();\n    var m = this.match(/^\\\\(?![*+?(){}[\\]'\"])/);\n    if (!m) return;\n    var val = m[0];\n\n    if (this.isInside('bracket')) {\n      val = '\\\\';\n    } else if (val.length > 1) {\n      val = '\\\\\\\\';\n    }\n\n    return pos({\n      type: 'backslash',\n      val: val\n    });\n  })\n  /**\n   * Square: \"[.]\"\n   */\n  .capture('square', function () {\n    if (this.isInside('bracket')) return;\n    var pos = this.position();\n    var m = this.match(/^\\[([^!^\\\\])\\]/);\n    if (!m) return;\n    return pos({\n      type: 'square',\n      val: m[1]\n    });\n  })\n  /**\n   * Brackets: \"[...]\" (basic, this can be overridden by other parsers)\n   */\n  .capture('bracket', function () {\n    var pos = this.position();\n    var m = this.match(/^(?:\\[([!^]?)([^\\]]+|\\]-)(\\]|[^*+?]+)|\\[)/);\n    if (!m) return;\n    var val = m[0];\n    var negated = m[1] ? '^' : '';\n    var inner = (m[2] || '').replace(/\\\\\\\\+/, '\\\\\\\\');\n    var close = m[3] || '';\n\n    if (m[2] && inner.length < m[2].length) {\n      val = val.replace(/\\\\\\\\+/, '\\\\\\\\');\n    }\n\n    var esc = this.input.slice(0, 2);\n\n    if (inner === '' && esc === '\\\\]') {\n      inner += esc;\n      this.consume(2);\n      var str = this.input;\n      var idx = -1;\n      var ch;\n\n      while (ch = str[++idx]) {\n        this.consume(1);\n\n        if (ch === ']') {\n          close = ch;\n          break;\n        }\n\n        inner += ch;\n      }\n    }\n\n    return pos({\n      type: 'bracket',\n      val: val,\n      escaped: close !== ']',\n      negated: negated,\n      inner: inner,\n      close: close\n    });\n  })\n  /**\n   * Text\n   */\n  .capture('text', function () {\n    if (this.isInside('bracket')) return;\n    var pos = this.position();\n    var m = this.match(not);\n    if (!m || !m[0]) return;\n    return pos({\n      type: 'text',\n      val: m[0]\n    });\n  });\n  /**\n   * Allow custom parsers to be passed on options\n   */\n\n  if (options && typeof options.parsers === 'function') {\n    options.parsers(nanomatch.parser);\n  }\n};\n/**\n * Advance to the next non-escaped character\n */\n\n\nfunction advanceTo(input, endChar) {\n  var ch = input.charAt(0);\n  var tok = {\n    len: 1,\n    val: '',\n    esc: ''\n  };\n  var idx = 0;\n\n  function advance() {\n    if (ch !== '\\\\') {\n      tok.esc += '\\\\' + ch;\n      tok.val += ch;\n    }\n\n    ch = input.charAt(++idx);\n    tok.len++;\n\n    if (ch === '\\\\') {\n      advance();\n      advance();\n    }\n  }\n\n  while (ch && ch !== endChar) {\n    advance();\n  }\n\n  return tok;\n}\n/**\n * Create text regex\n */\n\n\nfunction createTextRegex(pattern) {\n  if (cached) return cached;\n  var opts = {\n    contains: true,\n    strictClose: false\n  };\n  var not = regexNot.create(pattern, opts);\n  var re = toRegex('^(?:[*]\\\\((?=.)|' + not + ')', opts);\n  return cached = re;\n}\n/**\n * Expose negation string\n */\n\n\nmodule.exports.not = NOT_REGEX;","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/nanomatch/lib/parsers.js"],"names":["regexNot","require","toRegex","cached","NOT_REGEX","not","createTextRegex","module","exports","nanomatch","options","parser","opts","state","slashes","paths","ast","capture","parsed","m","match","strictOpen","addPrefix","isInside","pos","position","type","val","quote","input","indexOf","tok","advanceTo","consume","len","esc","notRegex","isNegated","length","nonegate","bos","append","dot","slice","dotfiles","metachar","qmark","noglobstar","node","brace","paren","globstar","star","starRe","negated","inner","replace","close","str","idx","ch","escaped","parsers","endChar","charAt","advance","pattern","contains","strictClose","create","re"],"mappings":"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","sourcesContent":["'use strict';\n\nvar regexNot = require('regex-not');\nvar toRegex = require('to-regex');\n\n/**\n * Characters to use in negation regex (we want to \"not\" match\n * characters that are matched by other parsers)\n */\n\nvar cached;\nvar NOT_REGEX = '[\\\\[!*+?$^\"\\'.\\\\\\\\/]+';\nvar not = createTextRegex(NOT_REGEX);\n\n/**\n * Nanomatch parsers\n */\n\nmodule.exports = function(nanomatch, options) {\n  var parser = nanomatch.parser;\n  var opts = parser.options;\n\n  parser.state = {\n    slashes: 0,\n    paths: []\n  };\n\n  parser.ast.state = parser.state;\n  parser\n\n    /**\n     * Beginning-of-string\n     */\n\n    .capture('prefix', function() {\n      if (this.parsed) return;\n      var m = this.match(/^\\.[\\\\/]/);\n      if (!m) return;\n      this.state.strictOpen = !!this.options.strictOpen;\n      this.state.addPrefix = true;\n    })\n\n    /**\n     * Escape: \"\\\\.\"\n     */\n\n    .capture('escape', function() {\n      if (this.isInside('bracket')) return;\n      var pos = this.position();\n      var m = this.match(/^(?:\\\\(.)|([$^]))/);\n      if (!m) return;\n\n      return pos({\n        type: 'escape',\n        val: m[2] || m[1]\n      });\n    })\n\n    /**\n     * Quoted strings\n     */\n\n    .capture('quoted', function() {\n      var pos = this.position();\n      var m = this.match(/^[\"']/);\n      if (!m) return;\n\n      var quote = m[0];\n      if (this.input.indexOf(quote) === -1) {\n        return pos({\n          type: 'escape',\n          val: quote\n        });\n      }\n\n      var tok = advanceTo(this.input, quote);\n      this.consume(tok.len);\n\n      return pos({\n        type: 'quoted',\n        val: tok.esc\n      });\n    })\n\n    /**\n     * Negations: \"!\"\n     */\n\n    .capture('not', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(this.notRegex || /^!+/);\n      if (!m) return;\n      var val = m[0];\n\n      var isNegated = (val.length % 2) === 1;\n      if (parsed === '' && !isNegated) {\n        val = '';\n      }\n\n      // if nothing has been parsed, we know `!` is at the start,\n      // so we need to wrap the result in a negation regex\n      if (parsed === '' && isNegated && this.options.nonegate !== true) {\n        this.bos.val = '(?!^(?:';\n        this.append = ')$).*';\n        val = '';\n      }\n      return pos({\n        type: 'not',\n        val: val\n      });\n    })\n\n    /**\n     * Dot: \".\"\n     */\n\n    .capture('dot', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\.+/);\n      if (!m) return;\n\n      var val = m[0];\n      this.state.dot = val === '.' && (parsed === '' || parsed.slice(-1) === '/');\n\n      return pos({\n        type: 'dot',\n        dotfiles: this.state.dot,\n        val: val\n      });\n    })\n\n    /**\n     * Plus: \"+\"\n     */\n\n    .capture('plus', /^\\+(?!\\()/)\n\n    /**\n     * Question mark: \"?\"\n     */\n\n    .capture('qmark', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\?+(?!\\()/);\n      if (!m) return;\n\n      this.state.metachar = true;\n      this.state.qmark = true;\n\n      return pos({\n        type: 'qmark',\n        parsed: parsed,\n        val: m[0]\n      });\n    })\n\n    /**\n     * Globstar: \"**\"\n     */\n\n    .capture('globstar', function() {\n      var parsed = this.parsed;\n      var pos = this.position();\n      var m = this.match(/^\\*{2}(?![*(])(?=[,)/]|$)/);\n      if (!m) return;\n\n      var type = opts.noglobstar !== true ? 'globstar' : 'star';\n      var node = pos({type: type, parsed: parsed});\n      this.state.metachar = true;\n\n      while (this.input.slice(0, 4) === '/**/') {\n        this.input = this.input.slice(3);\n      }\n\n      node.isInside = {\n        brace: this.isInside('brace'),\n        paren: this.isInside('paren')\n      };\n\n      if (type === 'globstar') {\n        this.state.globstar = true;\n        node.val = '**';\n\n      } else {\n        this.state.star = true;\n        node.val = '*';\n      }\n\n      return node;\n    })\n\n    /**\n     * Star: \"*\"\n     */\n\n    .capture('star', function() {\n      var pos = this.position();\n      var starRe = /^(?:\\*(?![*(])|[*]{3,}(?!\\()|[*]{2}(?![(/]|$)|\\*(?=\\*\\())/;\n      var m = this.match(starRe);\n      if (!m) return;\n\n      this.state.metachar = true;\n      this.state.star = true;\n      return pos({\n        type: 'star',\n        val: m[0]\n      });\n    })\n\n    /**\n     * Slash: \"/\"\n     */\n\n    .capture('slash', function() {\n      var pos = this.position();\n      var m = this.match(/^\\//);\n      if (!m) return;\n\n      this.state.slashes++;\n      return pos({\n        type: 'slash',\n        val: m[0]\n      });\n    })\n\n    /**\n     * Backslash: \"\\\\\"\n     */\n\n    .capture('backslash', function() {\n      var pos = this.position();\n      var m = this.match(/^\\\\(?![*+?(){}[\\]'\"])/);\n      if (!m) return;\n\n      var val = m[0];\n\n      if (this.isInside('bracket')) {\n        val = '\\\\';\n      } else if (val.length > 1) {\n        val = '\\\\\\\\';\n      }\n\n      return pos({\n        type: 'backslash',\n        val: val\n      });\n    })\n\n    /**\n     * Square: \"[.]\"\n     */\n\n    .capture('square', function() {\n      if (this.isInside('bracket')) return;\n      var pos = this.position();\n      var m = this.match(/^\\[([^!^\\\\])\\]/);\n      if (!m) return;\n\n      return pos({\n        type: 'square',\n        val: m[1]\n      });\n    })\n\n    /**\n     * Brackets: \"[...]\" (basic, this can be overridden by other parsers)\n     */\n\n    .capture('bracket', function() {\n      var pos = this.position();\n      var m = this.match(/^(?:\\[([!^]?)([^\\]]+|\\]-)(\\]|[^*+?]+)|\\[)/);\n      if (!m) return;\n\n      var val = m[0];\n      var negated = m[1] ? '^' : '';\n      var inner = (m[2] || '').replace(/\\\\\\\\+/, '\\\\\\\\');\n      var close = m[3] || '';\n\n      if (m[2] && inner.length < m[2].length) {\n        val = val.replace(/\\\\\\\\+/, '\\\\\\\\');\n      }\n\n      var esc = this.input.slice(0, 2);\n      if (inner === '' && esc === '\\\\]') {\n        inner += esc;\n        this.consume(2);\n\n        var str = this.input;\n        var idx = -1;\n        var ch;\n\n        while ((ch = str[++idx])) {\n          this.consume(1);\n          if (ch === ']') {\n            close = ch;\n            break;\n          }\n          inner += ch;\n        }\n      }\n\n      return pos({\n        type: 'bracket',\n        val: val,\n        escaped: close !== ']',\n        negated: negated,\n        inner: inner,\n        close: close\n      });\n    })\n\n    /**\n     * Text\n     */\n\n    .capture('text', function() {\n      if (this.isInside('bracket')) return;\n      var pos = this.position();\n      var m = this.match(not);\n      if (!m || !m[0]) return;\n\n      return pos({\n        type: 'text',\n        val: m[0]\n      });\n    });\n\n  /**\n   * Allow custom parsers to be passed on options\n   */\n\n  if (options && typeof options.parsers === 'function') {\n    options.parsers(nanomatch.parser);\n  }\n};\n\n/**\n * Advance to the next non-escaped character\n */\n\nfunction advanceTo(input, endChar) {\n  var ch = input.charAt(0);\n  var tok = { len: 1, val: '', esc: '' };\n  var idx = 0;\n\n  function advance() {\n    if (ch !== '\\\\') {\n      tok.esc += '\\\\' + ch;\n      tok.val += ch;\n    }\n\n    ch = input.charAt(++idx);\n    tok.len++;\n\n    if (ch === '\\\\') {\n      advance();\n      advance();\n    }\n  }\n\n  while (ch && ch !== endChar) {\n    advance();\n  }\n  return tok;\n}\n\n/**\n * Create text regex\n */\n\nfunction createTextRegex(pattern) {\n  if (cached) return cached;\n  var opts = {contains: true, strictClose: false};\n  var not = regexNot.create(pattern, opts);\n  var re = toRegex('^(?:[*]\\\\((?=.)|' + not + ')', opts);\n  return (cached = re);\n}\n\n/**\n * Expose negation string\n */\n\nmodule.exports.not = NOT_REGEX;\n"]},"metadata":{},"sourceType":"script"}