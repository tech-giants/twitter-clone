{"ast":null,"code":"// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nexport function extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\nexport function inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\nexport function getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\nexport function highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/hamzakhan/Documents/twitter-react/twitter/node_modules/@webassemblyjs/leb128/esm/bits.js"],"names":["extract","buffer","bitIndex","bitLength","defaultBit","Error","undefined","defaultByte","result","lastBit","startByte","Math","floor","startBit","endByte","endBit","get","index","inject","value","lastByte","length","atByte","atBit","getSign","highOrder","bit","fullyWrongByte","byteToCheck","i"],"mappings":"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","sourcesContent":["// Copyright 2012 The Obvious Corporation.\n\n/*\n * bits: Bitwise buffer utilities. The utilities here treat a buffer\n * as a little-endian bigint, so the lowest-order bit is bit #0 of\n * `buffer[0]`, and the highest-order bit is bit #7 of\n * `buffer[buffer.length - 1]`.\n */\n\n/*\n * Modules used\n */\n\"use strict\";\n/*\n * Exported bindings\n */\n\n/**\n * Extracts the given number of bits from the buffer at the indicated\n * index, returning a simple number as the result. If bits are requested\n * that aren't covered by the buffer, the `defaultBit` is used as their\n * value.\n *\n * The `bitLength` must be no more than 32. The `defaultBit` if not\n * specified is taken to be `0`.\n */\n\nexport function extract(buffer, bitIndex, bitLength, defaultBit) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  if (defaultBit === undefined) {\n    defaultBit = 0;\n  } else if (defaultBit !== 0 && defaultBit !== 1) {\n    throw new Error(\"Bad value for defaultBit.\");\n  }\n\n  var defaultByte = defaultBit * 0xff;\n  var result = 0; // All starts are inclusive. The {endByte, endBit} pair is exclusive, but\n  // if endBit !== 0, then endByte is inclusive.\n\n  var lastBit = bitIndex + bitLength;\n  var startByte = Math.floor(bitIndex / 8);\n  var startBit = bitIndex % 8;\n  var endByte = Math.floor(lastBit / 8);\n  var endBit = lastBit % 8;\n\n  if (endBit !== 0) {\n    // `(1 << endBit) - 1` is the mask of all bits up to but not including\n    // the endBit.\n    result = get(endByte) & (1 << endBit) - 1;\n  }\n\n  while (endByte > startByte) {\n    endByte--;\n    result = result << 8 | get(endByte);\n  }\n\n  result >>>= startBit;\n  return result;\n\n  function get(index) {\n    var result = buffer[index];\n    return result === undefined ? defaultByte : result;\n  }\n}\n/**\n * Injects the given bits into the given buffer at the given index. Any\n * bits in the value beyond the length to set are ignored.\n */\n\nexport function inject(buffer, bitIndex, bitLength, value) {\n  if (bitLength < 0 || bitLength > 32) {\n    throw new Error(\"Bad value for bitLength.\");\n  }\n\n  var lastByte = Math.floor((bitIndex + bitLength - 1) / 8);\n\n  if (bitIndex < 0 || lastByte >= buffer.length) {\n    throw new Error(\"Index out of range.\");\n  } // Just keeping it simple, until / unless profiling shows that this\n  // is a problem.\n\n\n  var atByte = Math.floor(bitIndex / 8);\n  var atBit = bitIndex % 8;\n\n  while (bitLength > 0) {\n    if (value & 1) {\n      buffer[atByte] |= 1 << atBit;\n    } else {\n      buffer[atByte] &= ~(1 << atBit);\n    }\n\n    value >>= 1;\n    bitLength--;\n    atBit = (atBit + 1) % 8;\n\n    if (atBit === 0) {\n      atByte++;\n    }\n  }\n}\n/**\n * Gets the sign bit of the given buffer.\n */\n\nexport function getSign(buffer) {\n  return buffer[buffer.length - 1] >>> 7;\n}\n/**\n * Gets the zero-based bit number of the highest-order bit with the\n * given value in the given buffer.\n *\n * If the buffer consists entirely of the other bit value, then this returns\n * `-1`.\n */\n\nexport function highOrder(bit, buffer) {\n  var length = buffer.length;\n  var fullyWrongByte = (bit ^ 1) * 0xff; // the other-bit extended to a full byte\n\n  while (length > 0 && buffer[length - 1] === fullyWrongByte) {\n    length--;\n  }\n\n  if (length === 0) {\n    // Degenerate case. The buffer consists entirely of ~bit.\n    return -1;\n  }\n\n  var byteToCheck = buffer[length - 1];\n  var result = length * 8 - 1;\n\n  for (var i = 7; i > 0; i--) {\n    if ((byteToCheck >> i & 1) === bit) {\n      break;\n    }\n\n    result--;\n  }\n\n  return result;\n}"]},"metadata":{},"sourceType":"module"}